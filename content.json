{"meta":{"title":"Limoer的记事小本","subtitle":null,"description":null,"author":"Limoer","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-08-26T02:12:55.757Z","updated":"2017-02-09T09:22:58.000Z","comments":true,"path":"googlee22a7e1de18f983c.html","permalink":"http://yoursite.com/googlee22a7e1de18f983c.html","excerpt":"","text":"google-site-verification: googlee22a7e1de18f983c.html"},{"title":"","date":"2019-09-15T06:12:50.485Z","updated":"2019-09-15T06:12:50.485Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Nickname: Limoer CHAT WITH ME! Profession: software engineering Profile: I’m a student from SDU. I’m focusing on browser side developing. I like the amazing and ridiculous language - JavaScript!"}],"posts":[{"title":"Battery Status API 以及useBattery","slug":"use-battery","date":"2020-02-21T07:50:32.000Z","updated":"2020-02-21T10:08:42.674Z","comments":true,"path":"2020/02/21/use-battery/","link":"","permalink":"http://yoursite.com/2020/02/21/use-battery/","excerpt":"","text":"Battery Status API提供了系统层级的电池信息(电量/充电信息等)，并且在这些状态改变的时候提供了一系列的eventListener。 有了这些信息，我们可以对应用进行优化。例如： 用户使用电池供电，想要达到好的续航效果，我们可以降低对资源的使用。 用户电量低，我们可以先对用户操作和数据进行缓存，避免数据丢失。 持续收集用户数据，进行用户群体分析。 …… 兼容性 Battery Status API的支持度有限，目前只有Chrome和Opera以及Android webview支持度是比较好的，并且官方并不推荐使用该功能，未来或被移除。 navigator.getBatterygetBattery返回一个Promise对象，resolve后返回一个battery对象，该对象包含了{ charging, chargingTime, dischargingTime, level }分别表示是否在充电，充电时长，剩余可用时间，电池电量。例如，{ &quot;charging&quot;: true, &quot;level&quot;: 1, &quot;chargingTime&quot;: 0, &quot;dischargingTime&quot;: null }。 除此之外，battery对象还包含了4个eventlistener(chargingchange/chargingtimechange/dischargingtimechange/levelchange)，用于监听4个属性的改变。 下面来写一个例子，获取某一时刻的系统电量信息: 1234567891011121314async function getBattery() &#123; const nav = navigator if (!nav || typeof nav.getBattery !== 'function') &#123; return &#123;&#125; &#125; const battery = await navigator.getBattery() console.log(battery.level) return battery&#125;getBattery() .then(battery =&gt; &#123; // do something &#125;) useBattery 如果我们要在React中使用Battery Status API，我们仍然可以向上面一样，也可以配合上React hooks来实现一个useBattery hook。 在开始写这个钩子之前，我们先理一下，由于获取电量信息是一个异步的过程，所以这个钩子除了返回上面提到的4个电量信息属性以外，还需要额外的一个属性用于记录数据是否获取完毕。 判断浏览器兼容性只需要判断navigator对象是否包含getBattery函数即可 1const isSupported = navigator &amp;&amp; typeof navigator.getBattery === 'function' 获取某一时刻电量信息的hook如下： 123456789101112131415161718192021222324import &#123; useState, useEffect &#125; from 'react'const isSupported = navigator &amp;&amp; typeof navigator.getBattery === 'function'function useBattery() &#123; if(!isSupported) &#123; return &#123;&#125; &#125; const [state, setState] = useState(&#123; fetching: true &#125;) useEffect(() =&gt; &#123; navigator.getBattery() .then(battery =&gt; &#123; const newState = &#123; fetching: false, charging: battery.charging, level: battery.level, dischargingTime: battery.dischargingTime, chargingTime: battery.chargingTime, &#125; setState(newState) &#125;) &#125;, []) return state&#125; 在某些情况下，我们可能并不仅仅需要某一时刻的电量信息，显然这一版本的useBattery并不能满足需要。我们需要监听eventListeners，并且在改变后变更状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123; useState, useEffect &#125; from 'react'const isSupported = navigator &amp;&amp; typeof navigator.getBattery === 'function'import &#123; isEqual &#125; from 'lodash'let bat;function useBattery() &#123; if(!isSupported) &#123; return &#123;&#125; &#125; const [state, setState] = useState(&#123; fetching: true &#125;) useEffect(() =&gt; &#123; function dealChange() &#123; const newState = &#123; fetching: false, charging: battery.charging, level: battery.level, dischargingTime: battery.dischargingTime, chargingTime: battery.chargingTime, &#125; if (!isEqual(state, newState)) &#123; setState(newState) &#125; &#125; navigator.getBattery() .then(battery =&gt; &#123; bat = battery dealChange() bat.addEventListener('chargingchange', dealChange) bat.addEventListener('chargingtimechange', dealChange) bat.addEventListener('dischargingtimechange', dealChange) bat.addEventListener('levelchange', dealChange) return () =&gt; &#123; bat.removeEventListener('chargingchange', dealChange) bat.removeEventListener('chargingtimechange', dealChange) bat.removeEventListener('dischargingtimechange', dealChange) bat.removeEventListener('levelchange', dealChange) &#125; &#125;) &#125;, []) return state&#125; 上面版本的useBattery已经比较完善了，针对每个属性都添加了eventHandler，当属性改变时获取新的state，并通过比较决定是否应用更改。 useEffect第一个参数如果返回一个函数，那么将在unmount的时候执行，所以，上面的代码进行了removeEventListener。 尾巴最近两周本该是上班的时间，由于疫情，我不得不在家待岗。起初的一周，睡睡懒觉， 看会儿NBA，再玩玩游戏，一天就浑浑噩噩的过了。可当游戏也玩得无聊了，懒觉也睡够了，我才发现我是真的没什么事做了，这种日子过得真的很难受！ 今天给好久没打开过的Mac充电，翻翻上学时的记忆，无论是文档，代码，邮件…思绪回到六七年前，高中时代的自己，就是因为我对智能手机的狂热追求，我才选择了如今的职业。除此之外，还有一层不变的对游戏的热爱。我喜欢玩游戏，也曾想过做游戏，在上海的那一段日子，我畏畏缩缩的迈出过第一步(想法/剧本)，后来也不了了之。 是时候重新出发，在未来的很长一段时间里，想要摸索着迈出第二步。 完。","categories":[],"tags":[{"name":"HTML5 API","slug":"HTML5-API","permalink":"http://yoursite.com/tags/HTML5-API/"}]},{"title":"React 实现全局组件","slug":"global-component","date":"2019-12-19T10:04:50.000Z","updated":"2019-12-19T10:06:09.513Z","comments":true,"path":"2019/12/19/global-component/","link":"","permalink":"http://yoursite.com/2019/12/19/global-component/","excerpt":"","text":"React 实现全局组件 有一个这样的需求：用户进入首页时可能会有不同类型的对话框弹出，默认的情况下所有对话框都是打开的，这很影响用户体验。在无法减少对话框的前提下，需要实现一种机制，能够让对话框依次弹出。 在React-Native中，一种不那么好的实现就是使用DeviceEventEmitter(一种类似Node中的事件机制)，并且创建一个容器组件用于管理对话框弹出，关闭。最终把容器组件挂载到页面中即可。 为了实现这样的需求，除了消息的收发管理，难点还在于如何把容器组件挂载到应用中，由于React-Native中并不存在DOM，所以要采用其它的方式，确保该容器挂载后，整个App使用阶段不会被卸载即可。 就此打住。 React中实现全局组件的思想与之类似，下面就来实现一个message全局组件。 最终的实现应该是这样使用的：1234567891011...import message from './message'class App extends React.Component &#123; ... handleClick = () =&gt; &#123; message('这是一条message') &#125; render() &#123; return &lt;Button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/Button&gt; &#125;&#125; 容器组件容器组件用于管理message（提供一系列增删接口），并且渲染到DOM。 一个简易的容器组件可以是下面这样：12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react';import './style.css';class Message extends Component &#123; state = &#123; messageList: [] &#125; add = (content) =&gt; &#123; const &#123; messageList &#125; = this.state this.setState(&#123; messageList: [content, ...messageList]&#125;) &#125; remove = (key) =&gt; &#123; const &#123; messageList &#125; = this.state const result = messageList.filter(item =&gt; item.key !== key) this.setState(&#123; messageList: result &#125;) &#125; clear() &#123; this.setState(&#123; messageList: [] &#125;) &#125; render() &#123; const &#123; messageList &#125; = this.state const nodes = messageList.map(item =&gt; item.component ? item.component : &lt;div className=\"message-item\"&gt;&#123;item.content&#125;&lt;/div&gt;) return ( &lt;div className=\"message-container\"&gt; &#123; nodes &#125; &lt;/div&gt; ) &#125;&#125; 上面实现的容器组件提供了add/remove/clear三个方法来对message进行管理，并最终渲染当前messageList中所有的消息。 接下来需要考虑如何把容器组件渲染到DOM，也可以说是把容器组件插入到DOM中。有多种方式可以选择： ReactDOM.render(element, container[, callback])，这个方法的作用是把React元素渲染到指定的容器中，也是我们最常用的一种渲染到DOM的方法。 ReactDOM.createPortal(child, container)，该方法的作用是将子节点渲染到存在于父组件以外的 DOM 节点中，该方法是这样使用的：123456789// 见：[https://zh-hans.reactjs.org/docs/portals.html]render() &#123; // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。 // `domNode` 是一个可以在任何位置的有效 DOM 节点。 return ReactDOM.createPortal( this.props.children, domNode );&#125; 既然是全局message组件，那么其一个理想的挂载的地方可以是body或者指定的DOM节点。下面，分别实现以上两种方式。 12345678910Message.init = container =&gt; &#123; // 创建内容容器 let root = document.createElement('div') if (container) &#123; container.appendChild(root) &#125; else &#123; document.body.appendChild(root) &#125; render(&lt;Message /&gt;, root)&#125; 在Message上新增了一个静态函数init，调用该函数就会把Message组件渲染到指定的DOM元素或者是document.body上。 这里有一个疑问，Message组件中提供了一系列接口来管理message，但通过以上的方式地区把Message组件挂载到DOM上了，却没法暴露接口供外部方法。这里有多种方式，第一种是ReactDOM.render(element, container[, callback])的返回值是其实是组件实例的引用，有了这个引用，外部就可以调用这些接口。这种方式已经不推荐使用，而推荐的方式也就是第二种方式callback ref，我们可以给组件绑定一个回调类型的ref，而这个callback以组件实例作为参数，我们可以通过这种方式来向外部暴露组件实例。123456789101112131415161718192021222324Message.init = (container, callback) =&gt; &#123; // 创建内容容器 let root = document.createElement('div') if (container) &#123; container.appendChild(root) &#125; else &#123; document.body.appendChild(root) &#125; // callback function ref(message) &#123; callback(&#123; add(content)&#123; message.add(content) &#125;, remove(key) &#123; message.remove(key) &#125;, clear() &#123; message.clear() &#125; &#125;) &#125; render(&lt;Message ref=&#123;ref&#125; /&gt;, root)&#125; 我们给init方法增加了一个callback参数，通过这个callback就可以把组件实例暴露到外部中去。在callback ref中，我们调用init传入的callback参数，并把组件实例作为callback的参数，实际上，暴露整个组件实例是非常危险的，因此这里只是暴露了实例的几个外部调用接口。 外部接口接下来实现外部接口，也就是我们外部调用的方法message(content)。实现容器组件的时候，我们实现了一个静态方法Message.init，该方法初始化了一个容器并挂载到DOM，并通过callback的方式对外暴露接口来管理messageList。因此，这个外部调用的方式只需要去实现实现这个callback。例如，我们实现的这个message(content)调用后三秒后就会消失。 123456789101112131415161718192021222324252627import Message from './message'let messageInstance;let index = 0;function addMessage(content) &#123; const key = `$&#123;index++&#125;_MESSAGE_UNIQ_KEY` messageInstance.add(&#123; key, content &#125;) setTimeout(() =&gt; &#123; messageInstance.remove(key) &#125;, 3000)&#125;function message(content) &#123; function callback(instance) &#123; messageInstance = instance addMessage(content) &#125; if(!messageInstance) &#123; Message.init(null, callback) &#125; else &#123; addMessage(content) &#125;&#125;export default message 上面的代码通过callback拿到了组件对外的接口并对外缓存messageInstance，针对每条消息生成了一个UNIQUE_KEY用于后续的消息移除。这里需要注意的是，Message只能实例化一次。 总结至此，一个全局组件message已经完成了。当然，如果你想要看到更好的效果，还需要对容器和消息本身添加样式。我们还可以自定义消息组件，将接口通过props传入到组件中，更好的管理消息。 React也提供了ReactDOM.unmountComponentAtNode(container)方法来卸载一个组件，当message组件不再需要的时候，最好将它从DOM中移除。 前面提到过ReactDOM.createPortal(child, container)同样可以将节点渲染到DOM。不多想要这种方式并不是很适合这种场景，因为对外暴露接口是一个难题，这里就不在演示了。 完。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React-Navigation实现动态Tab路由","slug":"dynamic-navigator","date":"2019-11-30T04:49:36.000Z","updated":"2019-11-30T04:52:27.170Z","comments":true,"path":"2019/11/30/dynamic-navigator/","link":"","permalink":"http://yoursite.com/2019/11/30/dynamic-navigator/","excerpt":"","text":"有一个需求：在用户未登录和已经登陆的情况下，需要渲染不同的底部导航菜单，而该导航栏其实是react-navigation-tabs的实例，并且不支持动态导航。 这个是一个很常见的需求，在这个issue下面有很多讨论，针对此需求，也提供了一系列解决方案。 动态导航我们使用createBottomTabNavigator(RouteConfigs, TabNavigatorConfig)来创建tab导航，其中RouteConfigs接受一个导航名称和路由的映射对象，一般情况下，RouteConfigs是确定的，比如： 12345678910111213141516171819// tab nav配置const RouteConfigs: TabOptions = &#123; Home: &#123; screen: Home &#125;, Purchase: &#123; screen: Purchase &#125;, Brand: &#123; screen: Brand &#125;, Sell: &#123; screen: Sell &#125;, Management: &#123; screen: Management &#125;&#125;// 创建底部tab路由const BottomTabRoutes = createBottomTabNavigator(RouteConfigs, &#123; ...TabNavigatorConfig&#125;)// 接入到App路由中const AppNavigator = createStackNavigator( &#123; TabRouter: &#123; screen: BottomTabRoutes &#125;, ...pageRoutes &#125;) createBottomTabNavigator接收RouteConfigs作为参数，返回一个类型为NavigationContainer的值：12// NavigationContainer 类型定义interface NavigationContainer extends React.ComponentClass&lt;NavigationContainerProps NavigationNavigatorProps&lt;any&gt;&gt; &#123;...&#125; 通过查看NavigationContainer的定义，可以发现其是一个React组件。所以第一种方式就是自定义一个组件，在该组件中返回NavigationContainer实例即可。 1234567891011121314151617class DynamicTabNavigater extends Compoent &#123; _genNav() &#123; let NavConfig = [....] // 对`NavConfig`的一系列的处理 return createBottomTabNavigator(NavConfig, &#123; ...otherConfig &#125;) &#125; render() &#123; const Tabs = this._genNav() return &lt;Tabs /&gt; &#125;&#125;const AppNavigator = createStackNavigator( &#123; TabRouter: &#123; screen: DynamicTabNavigator &#125;, ...otherRouter &#125;) 这种方式在该issue被证实是可行的，但是在React Navigation3.x版本中报错，显示缺少AppContainer，所以还需要使用createAppContainer创建一个容器。 12345...render() &#123; const Tabs = createAppContainer(this._genNav()) return &lt;Tabs /&gt;&#125; 这样动态路由就实现了，并且能够在绝大部分情况下使用正常，由于使用createAppContainer创建了一个容器，如果该容器并无法包含所有路由，那么还需要的AppContainer，此时就会导航异常。 实现二继续关注createBottomTabNavigator(RouteConfigs, TabNavigatorConfig)方法，第二个参数TabNavigatorConfig包含一个属性tabBarComponent?: React.ReactType，该属性用于设置tabBar如何显示，该属性设置为一个组件。 所以机会来了！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import * as React from 'react'import &#123; BottomTabBar &#125; from 'react-navigation-tabs'import &#123; DeviceEventEmitter &#125; from 'react-native'interface NavigatorState &#123; showBrandPage: boolean&#125;class DynamicTabNavigator extends React.Component&lt;any, NavigatorState&gt; &#123; state: NavigatorState = &#123; showBrandPage: true &#125; subscribe: any componentDidMount() &#123; this.subscribe = DeviceEventEmitter.addListener( 'showBrand', (data: boolean) =&gt; &#123; this.setState(&#123; showBrandPage: data &#125;) &#125; ) &#125; componentWillUnmount() &#123; // tslint:disable-next-line: no-unused-expression this.subscribe &amp;&amp; this.subscribe.remove() &#125; _tabNav = () =&gt; &#123; const &#123; routes, index &#125; = this.props.navigation.state const finalRoutes = [...routes] const &#123; showBrandPage &#125; = this.state // ...一系列的操作 return &#123; state: &#123; index: finalRoutes.findIndex(route =&gt; currentRoute.key === route.key), routes: finalRoutes &#125; &#125; &#125; render() &#123; const &#123; navigation, ...restProps &#125; = this.props const tabNavConfig = this._tabNav() return &lt;BottomTabBar &#123;...restProps&#125; navigation=&#123;tabNavConfig&#125; /&gt; &#125;&#125;export default DynamicTabNavigatorconst BottomTabRoutes = createBottomTabNavigator(tabNav, &#123; tabBarComponent: DynamicTabNavigator&#125;) 通过eventListener的方式接收路由变更信号，最终渲染BottomTabBar时使用修改过后的配置即可。 这种方式其实是一种障眼法，我们需要在配置静态Tab路由RouteConfigs时配置所有的Tab路由，在DynamicTabNavigator中通过props注入的navigation.state.routes拿到配置的静态路由，并经过一系列的处理最终得到渲染到BottomTabBar中的路由。需要注意的是，如果最终的路由相比静态路由有调整，那么需要更新index，否则点击路由跳转时会出现错误。 总结 针对React Navigation无法支持动态路由的问题，以上给出了两种方案，能够在一定程度解决。 第一种方案按需挂载路由，可以算是“真”动态路由； 第二种方案从可定制的tabBarComponent入手，不改变路由配置，而是在渲染层进行控制，条件渲染BottomTabBar。","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"从@babel/preset-env谈多浏览支持构建","slug":"polyfill","date":"2019-08-21T11:35:57.000Z","updated":"2019-08-21T11:37:27.795Z","comments":true,"path":"2019/08/21/polyfill/","link":"","permalink":"http://yoursite.com/2019/08/21/polyfill/","excerpt":"","text":"从@babel/preset-env谈多浏览支持构建最近需要把一个在特定浏览器环境运行的Web应用移植到多浏览器，特别是要支持部分IE浏览器。项目打包完成，在IE 11下运行，并不能成功，提示Map()未定义。很显然，IE浏览器并不支持ES6语法，而在构建中也没有使用相应的填补。 在基于Webpack + Babel构建的应用中，我们一般会使用到@babel/preset-env这个包，它使用了各种工具转译我们编写的ES6代码，我们一般这么使用它： 1234567891011121314151617181920212223// .babelrc&#123; \"presets\": [\"@babel/preset-env\"]&#125;// 或// webpack.config.js&#123; ... module: &#123; rules: [ &#123; test: /\\.jsx?$/, loader: 'babel-loader', options: &#123; presets: [ \"@babel/preset-env\" ] &#125; &#125; ] &#125; ...&#125; 不做额外配置的情况下，@babel/preset-env并不知道哪些ES6+的语法需要转译，所以最终的结果就是并没有转译。 @babel/preset-env的targets属性为了兼容多浏览器，我们需要告知哪些应用构件时需要支持哪些浏览器，@babel/preset-env提供了targets属性进行配置，例如为IE 10构建，可以这样配置：123&#123; targets: \"ie 10\"&#125; 我们可以使用browserslist包来指定构建的目标浏览器，可以在.browserslistrc或是package.json中进行配置： 123456\"browserslist\": [ \"&gt;0.2%\", \"not dead\", \"not ie &lt;= 10\", \"not op_mini all\"], 上面的配置中包含4条查询语句，&gt;0.2%表示大于0.2%的市场份额，not dead表示近24个月还在支持的浏览器，所有查询语句见npm。 配置完成后，可以运行npx browserslist查看具体支持的浏览器版本。 必不可少的useBuiltIns属性设置browserslist后构建的代码仍然不能很好的运行，这是因为项目中并没有加入polyfill，并且也未告知@babel/preset-env该如何处理pliyfill。useBuiltIns正是用来解决这一问题。1useBuiltIns: false | \"entry\" | \"usage\" 当useBuiltIns设置为&quot;entry&quot; | &quot;usage&quot;的时候，@babel/preset-env将会使用core-js提供的填补。 &quot;entry&quot;的意思就是，当我们在某个文件中import &#39;core-js&#39;但是该文件中只使用了到了ES6中的String.prototype.padStart方法，那么就上一句import就会在构建的时候被替换成import &#39;core-js/modules/es.string.pad-start&#39;。 &quot;usage&quot;的作用同其字面意义，即为：按需加载。如果我们在某个文件中使用了Map，如果构建目标支持Map，那么就不会使用相应填补，否则会在构建时加上import &#39;core-js/modules/es.map&#39;。 现在设置useBuiltIns: &quot;usage&quot;。 core-js及其使用core-js是一个ES6+语法的polyfill，简单而言就是使用ES3的语法实现了到目前为止几乎所有ES新特性。并且可以按需加载且不会污染全局命名空间。 core-js有2.x和3.x两个版本，其区别就是2.x不支持目前最新的语法，这里可以按需选择2.x或者3.x版本安装。 安装core-js：1yarn add core-js 使用core-js的需要注意的是该包需要在入口文件顶部导入，因为只有这样填补才会被完全用到。对已使用webpack构建的项目可以在config中在入口中引入：1entry: ['core-js/stable', 'index.js'] 也可以在入口文件(一般为src/index.js)的顶部引入：12// index.jsimport 'core-js/stable' 引入完毕，再进行构建，不出意外已经能够在指定版本的浏览器中运行了。 其它ES6+语法的多浏览器兼容的确告一段落了，但是浏览器API，CSS兼容还有很多问题，浏览器兼容才刚刚开始。 比如，IE并不支持fetch API，所以要么我们需要一个polyfill，要么就修改业务代码。1yarn add whatwg-fetch 然后在入口文件中引入，1import 'whatwg-fetch'; 某些CSS3支持得也不够好，需要我们一个个去考虑。 兼容性是前端开发无法规避的问题，而解决兼容的过程是”痛苦的”，特别是当业务开发完成后才考虑兼容的问题，痛苦加倍。 痛苦并快乐着。 完。","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"从globalCompositeOperatio到蒙版弹幕","slug":"barrage","date":"2019-08-07T12:29:05.000Z","updated":"2019-08-07T12:39:26.524Z","comments":true,"path":"2019/08/07/barrage/","link":"","permalink":"http://yoursite.com/2019/08/07/barrage/","excerpt":"","text":"从globalCompositeOperation到蒙版弹幕globalCompositeOperation属性Canvas 有一个不那么常用的属性globalCompositeOperation，作用是设置如何将一个源图像绘制到目标图像上。该如何理解？ 在使用Canvas绘制图像时，我们可以多次调用ctx.drawImage()或者是其它绘图函数ctx.fillRect()等进行绘制。而globalCompositeOperation属性就指定了当前将要绘制的图像在画布上如果和已绘制的图形重合该怎样显示。该属性有多个可选值： source-over默认值，目标图像重合部分将显示在上方(源图像被覆盖)。 source-in目标图像中显示源图像。源图像只显示重合的部分，目标图像透明。 source-out在目标图像之外显示源图像。只会显示非重合的部分，目标图像透明。 lighter 显示源图像+目标图像。 copy 只显示源图像。 xor 亦或。 destination-* 例如：当设置属性值为source-over时，下例将会显示为：1234567const canvas = document.getElementById('canvas');const ctx = canvas.getContext('2d');ctx.fillStyle = 'red';ctx.fillRect(10, 10, 80, 40);ctx.globalCompositeOperation = 'source-over';ctx.fillStyle = 'green';ctx.fillRect(20, 20, 80, 40); 可以看到，后绘制的绿色图像(源图像)和先绘制的红色图像(目标图像)发生了重叠，而源图像在层叠上层。 再来看看属性值为source-in的情况： 源图像和目标图像发生了重合，结果只显示了源图像的重合部分。 蒙版弹幕不考虑弹幕内容、显示等因素，使用Canvas实现弹幕就是一个不断擦除和绘制的过程，弹幕本身是绘制在画布上的，和内容(视频、图片等)是分层显示的，并无直接关系。 Canvas弹幕且不论性能，如果弹幕过多往往会挡住内容本身，体验并不好。B站的弹幕使用了名为蒙版弹幕的技术，这种技术可以让弹幕不遮挡内容主体。这里不讨论B站的蒙版弹幕是如何实现的，先来看看CSS中一个名叫mask的属性。 mask属性用来设置遮罩，那么何为遮罩呢？简单点来说就是使用一张图片来遮住另一张图片，并且如果用于遮罩的图片包含透明的部分，透明部分将会被遮住，非透明部分将会显示为被遮罩图片的内容。 mask的内容到此为止，是不是和globalCompositeOperation = &#39;source-in&#39;很像？其实我认为不是很像。 修改上面的例子，如果将两个图形绘制的区域完全重合，那么设置globalCompositeOperation = &#39;source-in&#39;后，不出意外，源图像将会完全覆盖目标图像。 如果我们把目标图像和源图像均换成两张等宽高的图片，那么源图片将会完全遮挡目标图片。 如果目标图像和源图像存在透明区域(RGBA 中 Alpha 为0的区域)，那么源图像会完全遮住目标图像，但是目标图像的透明区域仍然是透明的。 如果反向抠图后，目标图像只有主体是透明的，那么源图像将会覆盖目标图像的非主体区域，主体区域由于是透明的，无能为力。 把目标图像换成蒙版图片，把源图像换成包含弹幕的图像，那么，蒙版图像透明区域不会被覆盖。 此时再把覆盖后的图片渲染在Canvas上，大功告成。 回顾一下globalCompositeOperation = &#39;source-in&#39;的解释：目标图像中显示源图像。源图像只显示重合的部分，目标图像透明。目标图像会被完全覆盖，而源图像只显示重合的部分，由于透明区域并不属于目标图像，所以在透明区域并不会显示源图像。 先来看一个例子： 12345678910ctx.fillStyle = 'red';ctx.beginPath();ctx.moveTo(0, 0);ctx.lineTo(0, 150);ctx.lineTo(150, 0);ctx.fill();ctx.moveTo(150, 0);ctx.lineTo(300, 150);ctx.lineTo(300, 0);ctx.fill(); 在300*150的画布上先绘制两个红色的三角形，作为目标图像，此时画布中间的区域是透明的。 123ctx.globalCompositeOperation = 'source-in';ctx.fillStyle = 'green';ctx.fillRect(0, 0, 300, 150); 然后再绘制一个充满画布的矩形覆盖到目标图像上，此时的结果是这样的： 目标图像(两个红色的三角形)已经被完全覆盖了，而透明区域仍然透明。 简易实现为了实现蒙版弹幕，需要准备： 原版图像 蒙版图像 Canvas弹幕 这里原版图像使用下面这张菊花图： 经过抠图(主体变成透明)，生成的蒙版图片如下： 弹幕系统的实现不做过多的介绍，这里只关注绘制，和上例的绘制过程一致，首先绘制蒙版图像，再绘制弹幕内容到蒙版上进行覆盖。 123456789101112131415161718192021222324252627282930313233drawBarrages() &#123; let context = this.useMask ? this.bgCtx : this.ctx; if(this.barrageList.length) &#123; context.clearRect(0, 0, this.width, this.height); for(let i=0; i &lt; this.barrageList.length; i++) &#123; // 此时弹幕将要移除画布 let barrage = this.barrageList[i]; if(barrage.left + barrage.width &lt;= 0) &#123; this.barrageList.splice(i, 1); // 移除该弹幕 i -= 1; continue; &#125; if((barrage.left + barrage.width+600) &lt; this.width &amp;&amp; barrage.isChecked === false) &#123; // 此时已经完全出跑道并且还没有发起检查。 let index = vm.statics.findIndex((item) =&gt; item === barrage.top); barrage.isChecked = true; used[index] = 0; &#125; barrage.left = barrage.left - barrage.offset; this.drawOneBarrage(barrage); &#125; // #1 擦除上次绘制 this.ctx.clearRect(0, 0, this.width, this.height); // #2 绘制蒙版图像 this.ctx.putImageData(this.maskImage, 0, 0); // #3 设置compose类型 this.ctx.globalCompositeOperation = 'source-in'; // #4 绘制弹幕 this.ctx.drawImage(this.bgCanvas, 0, 0, this.width, this.height); &#125; this.stop = requestAnimationFrame(this.drawBarrages.bind(this));&#125; 上面的代码是完整绘制一帧的逻辑，跳过绘制弹幕文本的循环，关注整体绘制和层叠逻辑。其中绘制总分为四步，擦除上一帧结果，绘制蒙版(作为目标图像)，设置compose类型为source-in，绘制弹幕(作为源图像)。 注意到，蒙版图像使用ctx.putImageData绘制，这表示蒙版图像是ImageData类型，可以通过ctx.getImageData()拿到(需先绘制在画布上)，这里也可以png图片作为蒙版图片直接绘制在画布上。 this.ctx.drawImage(this.bgCanvas, 0, 0, this.width, this.height)用于绘制弹幕，this.bgCanvas是绘制了弹幕文本的Canvas画布，这里使用了离屏Canvas 技术，该画布并不会单独绘制在屏幕上。 绘制结果如下图： 可以看到，弹幕并没有遮挡我们的主体(菊花)，实现了蒙版弹幕的预期效果。 尾巴我们的确实现了蒙版弹幕，其主体是使用Canvas绘制蒙版图片和弹幕在同一张画布上，并且设置globalCompositeOperation = &#39;source-in&#39;来达到弹幕完全覆盖蒙版的效果。 简易实现的内容主体是一张静态的图片，如果要实现视频蒙版弹幕效果，需要提供每一帧的蒙版图像。在渲染某一帧时，最终的结果使用该帧的蒙版图像和实时弹幕组合而成。 其实蒙版弹幕的关键是提供蒙版图像，对于单个图片还好，我们可以针对这张图片单独制作一张蒙版图像。但是对于视频蒙版弹幕，我们需要逐帧生成蒙版图像，工作量之大可想而知。并且如何生成蒙版图像，如何标注主体是关键中的关键。这一部分理应借助机器学习，进行图像识别和分割。 一个可行的办法是事先针对每个视频，先逐帧生成蒙版图像，在进行流媒体播放的时候同时传递蒙版图像，最终在前端进行组装，完成视频蒙版弹幕。 完。","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"记一次React Hooks的使用","slug":"hooks","date":"2019-07-07T00:48:50.000Z","updated":"2019-07-07T00:53:26.800Z","comments":true,"path":"2019/07/07/hooks/","link":"","permalink":"http://yoursite.com/2019/07/07/hooks/","excerpt":"","text":"有这么一个需求：需要渲染一个表格，表格的内容会随着用户的操作而重新请求数据，并且在用户离开这个表格所在的页面(路由)后缓存数据，再次进入该页面的时使用已缓存数据。 目前在使用的表格组件是纯函数组件，只负责渲染，数据请求则写在其父组件，数组则存在Redux中。经过考虑，需要把数据请求的逻辑移入表格组件中，使得表格组件承担更多的职责，在React 16.8之前，我们不得不把表格组件写成class组件。 而现在，可以使用hooks，以最少的更改，来实现这一需求。 需要哪些hooks?我们的需求是把请求数据的逻辑移入到表格组件中，表格的数据仍然保存在Redux中。众所周知，数据获取是一个有副作用的操作，而useEffect这个hooks就是用来处理有副作用的操作。 在使用hooks之前，我们一般在componentDidMount和componentDidUpdate或者是很少使用的componentWillUnMount来进行DOM操作，数据请求等副作用操作。而useEffect则可以简单的看做是这三个生命周期函数的合集，其在组件的这三个生命周期时，都会被调用到。 所以，使用useEffect解决了所有问题。 “真”解决了所有问题？先把代码写起来:12345678910import React, &#123; useEffect &#125; from 'react';const MyTable = (&#123; fetchData, param &#125;) =&gt; &#123; useEffect(() =&gt; &#123; fetchData(param); &#125;, [param]) return ( &lt;Table /&gt; );&#125;export default connect(stateToProps,actionToProps)(MyTable); 仅仅三行代码，就搞定了。更改params，一切正常；从其它页面进入，看起来也很正常。可为什么是看起来正常呢？因为你打开控制台，查看network xhr，再进入页面，请求发送了！并没有使用缓存的数据！ 所以，问题并没有解决。 如何更好的利用缓存数据 问题：既然useEffect能够在上述三个生命周期中都执行，那么有没有办法区分出首次渲染和更新呢？ 答案是肯定的！在上面的代码中，我们使用了useEffect(func, [param])的形式，其实useEffect的第二个参数如果指定，那么useEffect就不是每次都执行了，而是只有param改变了才会执行。并且特别的，如果第二个参数传入[]空数组，那么useEffect只会执行一次，也就是说，useEffect只会在componentDidMount执行！代码写起来：123456// 其它代码不变，再加一个hookuseEffect(() =&gt; &#123; if (data.status !== 'fulfilled') &#123; fetchData(param); &#125;&#125;, []) 上面的hook会在初次渲染完成后执行，如果缓存数据的状态不是fulfilled，才请求数据。 问题仍然没有解决 很显而易见的是，即便是加了一个hook，而第二个useEffect仍然会执行，所以仍然会在初次加载完成后请求数据。 这时候，就需要另一个hook出场了，那就是useState，我们需要在组件中维持一个是否是首次渲染的状态，只有当非首次渲染的时候，才会去执行第一个hook，因此可以避免不必要的的数据请求。代码码起来：123456789101112const [isInitial, changeInitialToFalse] = useState(true);useEffect(() =&gt; &#123; if (!isInitial) &#123; fetchData(param); &#125;&#125;, [param]);useEffect(() =&gt; &#123; changeInitialToFalse(false); if (data.status !== 'fulfilled') &#123; fetchData(param); &#125;&#125;, []); 经过测试，这一次是真一切正常了，缓存也已经用上。 尾巴这是一次再普通不过的组件改造，这也是我在实际项目中第一次使用hooks。并且经历了从最开始遇到需求到决定使用hooks来最小化修改，到遇到问题差点改成更熟悉的class组件，到最终解决问题。最大的收货是，我对useEffect的了解又深刻了一些。把数据请求逻辑移到组件内部，除了降低组件间的耦合，更大程度上可以配合前一篇提到的ScrollLoad来做真正的滚动加载。毕竟数据才是组件的灵魂，数据都不懒加载，组件懒加载的意义就减了一半，手动狗头。 完。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Webpack resolve解析","slug":"resolve","date":"2019-07-07T00:48:39.000Z","updated":"2019-07-07T00:56:28.722Z","comments":true,"path":"2019/07/07/resolve/","link":"","permalink":"http://yoursite.com/2019/07/07/resolve/","excerpt":"","text":"虽然在实际开发过程中，我们经常会使用脚手架来初始化一个项目，而脚手架一般都包含了完善的webpack配置，例如create-react-app这个脚手架，其把所有关于构建的内容封装在了react-scripts包中，在实际开发中，我们只需要运行yarn run start/build/test即可，它就可以帮我们搞定代码压缩、分隔，jsx和es6代码编译到es5等。 回到webpack，我们都知道一个完整的webpack配置必定是要包含入口(entry)、输出(output)，可能还需要模块-加载器(loader)来处理不同类型的模块、或是使用插件(plugin)来在构建过程中自定义某些动作。除此之外，还有webpack4中才引入的用于性能和构建优化的optimization，还有用于开发环境的开发服务器(devServer)。还有不那么常用和深入人心的解析(resolve)。本篇将以react-scripts包的webpack配置中关于resolve的使用为基础，介绍如何在实际项目中可能会用到的自定义解析。 他们是怎么写的首先来看看react-scripts关于resolve的配置：123456789101112131415resolve: &#123; modules: ['node_modules', paths.appNodeModules].concat( modules.additionalModulePaths || [] ), extensions: paths.moduleFileExtensions .map(ext =&gt; `.$&#123;ext&#125;`) .filter(ext =&gt; useTypeScript || !ext.includes('ts')), alias: &#123; 'react-native': 'react-native-web', &#125;, plugins: [ PnpWebpackPlugin, new ModuleScopePlugin(paths.appSrc, [paths.appPackageJson]), ],&#125;, modules属性：其指定了webpack在进行模块解析时应该搜索的目录，该属性可通过数组的方式指定一系列的路径，默认值是: [&quot;node_modules&quot;]，也就是说，在不指定该属性的情况下，如果我们引入import xx from xx，则webpack会默认在根目录的node_modules目录下查找该模块。上面的配置中指定了额外两种模块解析路径，其分别是path.appNodeModules和modules.additionalModulePaths，其中path.appNodeModules最终指向的是path.resolve(fs.realpathSync(process.cwd()), &#39;node_modules&#39;)也就是说，在默认情况下，该路径是node_modules的决定路径。modules.additionalModulePaths指向一个自定义路径，并通过getAdditionalModulePaths(config)方法生成该路径，如果config等于{}，则返回process.env.NODE_PATH(经过一些列的处理)，否则的话如果config.baseUrl存在且等于modules.additionalModulePaths或者appSrc则返回，否则抛出错误。也就是说，我们可以通过jsconfig.json来指定baseUrl属性，并且该属性只能是node_modules目录或src目录。 extensions属性：自动解析的确定的扩展，默认值是[&#39;.js&#39;, &#39;.json&#39;]，也就是说，在默认情况下，我们import ClsA from &#39;./clsa&#39;，可以解析到clsa.js或是cls.json。上面的配置重写了extensions，定义了更多的扩展，并根据当前是否是typescript项目而是用对应的拓展。paths.moduleFileExtensions定义如下： 12345678910111213const moduleFileExtensions = [ 'web.mjs', 'mjs', 'web.js', 'js', 'web.ts', 'ts', 'web.tsx', 'tsx', 'json', 'web.jsx', 'jsx',]; 如何判别当前项目是typescript项目呢？useTypeScript是这样定义的：const useTypeScript = fs.existsSync(paths.appTsConfig);，很明显，通过判断是否存在paths.appTsConfig指向的文件也就是tsconfig.json，如果存在该文件，则表示该项目是中可以引用那些以ts为后缀的文件而不需要指定扩展名。 alias属性：创建模块的别名，确保在引入某些模块时可以变得简单。在上面中alias的配置是：123alias: &#123; 'react-native': 'react-native-web',&#125;, 也就是在我们使用名为react-native的模块时，其默认指向的是react-native-web模块，例如：1import &#123; View &#125; from 'react-native'; 此时项目中根本没安装react-native，仅安装了react-native-web，也就是说react-native成了react-native-web的别名。那么问题来了：为什么我们不直接写import { View } from &#39;react-native-web&#39;呢？ 其实这涉及到React-Native强调的一次编写，处处使用，这里的使用并不仅仅是iOS和Android代码共用，而是React-Native和Web之间的代码共享。react-native-web就是这样一个库，它把react-native实现的组件实现成为Web组件，并且表现和react-native组件一致。这样，如果我们拿到的是一份react-native的代码，添加别名过后，就无需把所有的react-native全都改成react-native-web，这样就保证了两端代码的统一。 扯远了，继续。 plugins属性：如果在配置解析的过程中需要插件的话，就可以在这里指定。上面的代码使用了pnp-webpack-plugin和react-dev-utils/ModuleScopePlugin，pnp-webpack-plugin是为了解决require()时过多的I/O操作带来的性能消耗，pnp思想来自Yarn团队，目的是为了解决安装和引用依赖效率过低问题。其建立了一张映射表，这张表记录了依赖版本关联和依赖与依赖之间的关联以及依赖存放的位置。有了这张表，就可以跳过繁琐的查找过程直接确定依赖在文件中的位置，从而提高性能。详情见stackoverflow。ModuleScopePlugin插件的官方解释是：该插件可以确保来自源程序目录(也就是/src)的相对导入不会使用到外部依赖。new ModuleScopePlugin(paths.appSrc, [paths.appPackageJson])接收两个参数，分别指定了源程序目录/src和allowedFiles指向了package.json文件。 更多的配置 mainFields属性：该属性是为了指定在不同环境中，默认使用哪个webpack的字段作为导入的入口。例如某个模块的package.json文件中执行了以下入口:12345&#123; module: 'index.js', main: 'build/index.node.js', browser: 'build/index.js',&#125; 那么在Node环境下，默认会使用build/index.node.js导入，而在浏览器环境中，默认使用build/index.js导入。 mainFiles属性：解析目录是默认使用的文件名。这个在实际开发中使用得比较多，例如我们开发的某个页面，文件路径为/src/views/Home/index.js，那么在实际使用这个页面的时候直接使用import Home from &#39;./src/views/Home&#39;即可，因为mainFiles默认的配置是：[&#39;index&#39;]，这个属性不建议自定义。 resolve还有很多属性，可以让我们充分自定义整个解析过程，但从react-scripts的实践上来看，其也是针对某些属性进行了定制，并没有一味的自定义。在对某个属性不是很熟悉并且没有过实践，建议不要盲目的修改。并且resolve的所有属性都提供了适应绝普通场景的默认值。最后，resolve使用愉快。 完。","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"来，实现一个“滚动加载”","slug":"scrollload","date":"2019-06-27T12:37:20.000Z","updated":"2019-06-27T12:41:52.632Z","comments":true,"path":"2019/06/27/scrollload/","link":"","permalink":"http://yoursite.com/2019/06/27/scrollload/","excerpt":"","text":"从问题入手，实现一个滚动加载实现原理懒加载的实现很简单，例如图片需要懒加载的时候，在初始加载时并不直接加载图片，而是用一个其它的图片或者占位符占位，当其它优先级更高的内容加载完成后，再使用真实的图片替换占位图。具体呢就是在初始加载时并不知道图片的src或者src指向一个占位图片，而真实图片的路径则是放在data-src这样的自定义属性中，当需要加载时，使用data-src替换src即可。 在React中，如果我们需要懒加载一个组件，实现原理也类似：当不需要加载的时候渲染占位符，当需要加载的时候再去加载真正的加载。滚动加载就是懒加载的一种特殊情况，其触发方式是滚动，只有当组件在可视区域中时，才开始加载。 实现滚动加载并不简单，我们需要考虑以下几个问题： 如何找到组件所处的滚动容器。 如何判定组件是否可见。 如何使用“更好”组件占位符。 处理性能瓶颈。 ScrollLoad实现懒加载使用最为广泛的实现是react-lazy-load，使用起来也很方便：&lt;LazyLoad&gt;&lt;MyComponent /&gt;&lt;/LazyLoad&gt;，使用提供的LazyLoad组件包裹需要懒加载的组件即可，并且它提供了多个属性，例如height可以设置当内容未加载时的高度，offset则可以指定组件开始加载时需要偏移的距离(单位:px)，除此之外，我们还可以指定懒加载是否使用防抖和节流来提升性能，具体的使用见react-lazy-load。 虽然react-lazy-load是一个使用广泛的懒加载解决方案，但是在最近的项目中，我却不得不放弃使用它。因为react-lazy-load会更改原有的DOM结构!!!，所以如果要使用react-lazy-load，我必须更改原本的样式，这将会是一个浩大的工程。 所以，接下来将会实现一个不需要额外DOM结构的滚动加载组件ScrollLoad组件。 问题1：如果找到组件所在的可滚动元素这个问题其实是：如何找到组件所在的最近的可滚动的父元素。 但是为什么需要找到那个可滚动的父元素呢？因为需要在该父元素上绑定scroll eventListener，当父元素在滚动时，就可以根据监听函数实时获取滚动的距离，并依此决定组件显示与否。 那怎么样才能找到最近可滚动父元素呢？为了定位父元素，我们需要定位当前元素，然后再向上遍历，去查找overflow显式设置为auto|scroll的元素。 查找可滚动父元素代码如下：123456789101112131415161718192021222324252627282930function getScrollParent(element) &#123; const style = (elem, prop) =&gt; &#123; if (getComputedStyle !== undefined) &#123; return getComputedStyle(elem, null).getPropertyValue(prop); &#125; return elem.style[prop]; &#125;; const overflow = node =&gt; style(node, 'overflow') + style(node, 'overflow-x') + style(node, 'overflow-y'); // 循环判断父节点是否可滚动这里暂不添加，直接去直接父元素 if (!(element instanceof HTMLElement)) &#123; return window; &#125; let parent = element; while (parent) &#123; // 当前节点是body或者document if (parent === document.body || parent === document.documentElement) &#123; break; &#125; // 当期元素无父节点 if (!parent.parentNode) &#123; break; &#125; // 判断节点是否含有overflow等属性的值 if (/(scroll|auto|inherit)/.test(overflow(parent))) &#123; return parent; &#125; parent = parent.parentNode; &#125; return window;&#125; 实现参考了react-lazy-load的实现，通过当前节点向上查找直到找到第一个可滚动的父元素或遍历到顶层元素，并且每进行一次遍历，会通过正则检查当前元素的样式的overflow overflow-x overflow-y，如果为scroll|auto，则返回该父元素。 那么怎么得到当前元素呢？可以通过ReactDOM.findDOMNode(component)访问真实的DOM节点，如果有多个子节点的话，默认返回第一个。因为ScrollLoad组件并没有添加额外的DOM结构，所以通过findDOMNode(this)拿到的节点就是目标节点，也就是占位节点(因为就算组件初始状态下可见，那么也要等应用挂载后才去判断，所以首次渲染的是占位组件)。 问题2：如何判定组件是否可见如果只考虑上下滚动的话，一个很简单的判断公式是：offsetTop &lt; seenHeight + scrollTop，就是：组件相对于可滚动父元素的偏移 &lt; 可滚动父元素的可视高度 + 可滚动父元素的滚动距离。上面的三个计算量中offsetTop和seenHeight都是固定不变的，所以一个组件是否可见取决于父元素当前滚动的距离。seenHeight很好计算：parent.clientHeight即可，scrollTop也很简单：parent.scrollTop，offsetTop计算稍微复杂。 如何计算offsetTop？如果最近可滚动父元素是直接父元素的话，直接通过elem.offsetTop就可以得到，如果包含多层嵌套，那么offsetTop就需要每一层元素相对于父元素的offsetTop相加，直到父元素等于目标父元素。简单的实现如下：12345678910// 该函数没有考虑节点异常的情况let getNodeOffsetTop = (node, parent) =&gt; &#123; let current = node; let offsetTop = 0; while (current !== parent) &#123; offsetTop += current.offsetTop; current = current.parentElement; &#125; return offsetTop;&#125; 最后是判断组件是否可见的实现：12345678910111213141516171819202122let checkVisible = (node, parent) =&gt; &#123; if (!node || !parent) &#123; this.setState(&#123; visible: true &#125;); return null; &#125; return () =&gt; &#123; const &#123; visible &#125; = this.state; if (visible) &#123; this.parent.removeEventListener('scroll', this.scrollHandler); return; // 直接返回不执行当次eventListener &#125; let seenHeight = parent.clientHeight; let scrollHeight = parent.scrollTop; let currentNode = findDOMNode(this); // 获取最新的dom结构 let offsetTop = this.getNodeOffsetTop(currentNode, parent); // 1. 当偏移高度小于可见高度 // 2. 初始不可见的时候，当可视高度+滚动高度大于了偏移高度 if (offsetTop &lt;= seenHeight + scrollHeight) &#123; this.setState(&#123; visible: true &#125;); &#125; &#125;;&#125; 问题3：如何使用“更好”组件占位符理想情况下，一个好的占位组件应该是和真实组件一样大的size，这样的话初始情况和加载完成的情况下滚动条的长度都是一样长的，且在组件由不可见到可见这个过程中页面并不会因为组件前后的size而出现抖动。 而实际的情况是，我们并不能很好的拿到目标组件的样式并作用到占位组件上，因为占位组件总是先渲染。所以折中的做法是让ScrollLoad的使用者去提供占位组件，这样就把如何提供一个好的占位组件交给了使用者。 还有一种办法是，既然一个好的(只是我认为的)占位组件的size是等于目标组件的，那么我直接把用于布局的样式从目标组件上拿过来不就行了！所以无论是目标组件渲染后的真实DOM上的className id style...全部拿过来，如果高度是内容撑开的话，我们就拿渲染完成的高度直接设置到占位组件上。经过尝试，这种方法的确可行，但是需要付出的代价是需要花费时间在获取目标组件的样式和样式整理上，并且代码的可读性将一定程度的降低。 所以，关于占位组件，我暂时没有好的方法。 问题4：性能瓶颈在前面介绍react-lazy-load的时候提到过我们可以决定是否使用节流或防抖来解决性能问题。所以，在ScrollLoad上，也是用了节流来控制scroll触发的频率。代码如下：12this.scrollHandler = throttle(this.checkVisible(dom, parent), 100);parent.addEventListener('scroll', this.scrollHandler, &#123; passive: true &#125;); 这里使用了lodash/throttle来实现节流，这样默认情况下，scroll事件只会每隔100ms触发一次。 上面的代码在使用addEventListener绑定监听函数时还是用到了该函数的第三个参数：{ passive: true }，passive的意思是消极的、被动的，如果不指定，在新版的Chrome中会有性能提示：[Violation] Added non-passive event listener to a scroll-blocking &lt;some&gt; event. Consider marking event handler as &#39;passive&#39; to make the page more responsive. 其实在监听滚动事件是，我们可以通过event.preventDefault()来阻止浏览器的默认滚动行为，可当滚动触发时，浏览器并不知道我们的监听函数中是否阻止了默认行为，所以浏览器会等待，直到监听函数执行完，此时浏览器才会选择滚动与否。而执行监听函数往往需要时间，性能就会受到影响。 而设置{ passive: true }，可以在执行监听函数之前就告诉浏览器，并没有阻止默认滚动，因此在滚动触发时，浏览器就不会等待，直接滚动。显然ScrollLoad是需要执行浏览器滚动的，因此设置{ passive: true }可以提升性能。 在checkVisible函数中，有一段代码：1234const &#123; visible &#125; = this.state;if (visible) &#123; this.parent.removeEventListener('scroll', this.scrollHandler);&#125; 这段代码很好理解，除了在组件卸载之前需要移除listener之外，一旦当某个组件可见，那么此时就没必要再监听滚动了，所以需要移除监听函数。 上面的代码还有一个问题，如果当某两次触发监听函数组件的状态刚好从visible为false切换到true，此时移除了监听函数，但当次函数还会再次执行，所以在移除监听函数后，直接返回，可以避免执行下面不必要的逻辑。因此，这段代码应该是：12345const &#123; visible &#125; = this.state;if (visible) &#123; this.parent.removeEventListener('scroll', this.scrollHandler); return; // 直接返回不执行当次eventListener&#125; 结尾到此为止，一个基本可用的ScrollLoad组件就实现了，其实对于不同的使用场景，ScrollLoad的实现也可以略有不同，例如如果当前需要scrollload的组件是一些列表项组件，每个组件的样式外观都是一致的。这样的话，我们在写lazyload组件的时候，就可以把所有组件使用一个LazyLoad组件包裹起来，然后绑定一个监听函数，使用可显示的组件个数作为组件状态，每次滚动时监听函数根据已经滚动的高度去计算可见组件的个数，最后在渲染的时候遍历this.props.children，选择渲染组件或是占位组件即可。 附 LazyLoad实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import React from 'react';import &#123; findDOMNode &#125; from 'react-dom';import throttle from 'lodash/throttle';import &#123; Spin &#125; from '@xx/xx-ui';import ReactPlaceHolder from 'react-placeholder';function getScrollParent(element) &#123; const style = (elem, prop) =&gt; &#123; if (getComputedStyle !== undefined) &#123; return getComputedStyle(elem, null).getPropertyValue(prop); &#125; return elem.style[prop]; &#125;; const overflow = node =&gt; style(node, 'overflow') + style(node, 'overflow-x') + style(node, 'overflow-y'); // 循环判断父节点是否可滚动这里暂不添加，直接去直接父元素 if (!(element instanceof HTMLElement)) &#123; return window; &#125; let parent = element; while (parent) &#123; // 当前节点是body或者document if (parent === document.body || parent === document.documentElement) &#123; break; &#125; // 当期元素无父节点 if (!parent.parentNode) &#123; break; &#125; // 判断节点是否含有overflow等属性的值 if (/(scroll|auto|inherit)/.test(overflow(parent))) &#123; return parent; &#125; parent = parent.parentNode; &#125; return window;&#125;let EmptyCompBox = (&#123; ...props &#125;) =&gt; ( &lt;div &#123;...props&#125;&gt; &lt;Spin size=\"large\" className=\"lazyload-center-spin\" /&gt; &lt;/div&gt;);class ScrollLoad extends React.Component &#123; state = &#123; visible: false, &#125;; componentDidMount() &#123; let dom = findDOMNode(this); // 取得当前节点 let parent = getScrollParent(dom); this.parent = parent; let visible = this.checkVisible(dom, parent); // 初始化检查是否可见 visible(); this.scrollHandler = throttle(this.checkVisible(dom, parent), 100); parent.addEventListener('scroll', this.scrollHandler, &#123; passive: true &#125;); &#125; componentWillUnmount() &#123; this.parent.removeEventListener('scroll', this.scrollHandler); &#125; getNodeOffsetTop = (node, parent) =&gt; &#123; let current = node; let offsetTop = 0; while (current !== parent) &#123; offsetTop += current.offsetTop; current = current.parentElement; &#125; return offsetTop; &#125;; checkVisible = (node, parent) =&gt; &#123; if (!node || !parent) &#123; this.setState(&#123; visible: true &#125;); return null; &#125; let seenHeight = parent.clientHeight; let scrollHeight = parent.scrollTop; return () =&gt; &#123; const &#123; visible &#125; = this.state; if (visible) &#123; this.parent.removeEventListener('scroll', this.scrollHandler); return; // 直接返回不执行当次eventListener &#125; let currentNode = findDOMNode(this); // 获取最新的dom结构 let offsetTop = this.getNodeOffsetTop(currentNode, parent); // 1. 当偏移高度小于可见高度 // 2. 初始不可见的时候，当可视高度+滚动高度大于了偏移高度 if (offsetTop &lt;= seenHeight + scrollHeight) &#123; this.setState(&#123; visible: true &#125;); &#125; &#125;; &#125;; render() &#123; const &#123; visible &#125; = this.state; const &#123; id, className, style &#125; = this.props; return ( &lt;ReactPlaceHolder ready=&#123;visible&#125; customPlaceholder=&#123;&lt;EmptyCompBox id=&#123;id&#125; className=&#123;className&#125; style=&#123;style&#125; /&gt;&#125; &gt; &#123;this.props.children&#125; &lt;/ReactPlaceHolder&gt; ); &#125;&#125;export default ScrollLoad;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"关于eject需要知道的","slug":"eject","date":"2019-06-05T00:37:22.000Z","updated":"2019-06-05T00:41:57.693Z","comments":true,"path":"2019/06/05/eject/","link":"","permalink":"http://yoursite.com/2019/06/05/eject/","excerpt":"","text":"整理：使用create-react-app构建的项目在yarn run eject后的一些问题。 eject之前create-react-app脚手架把关于webpack配置和其它脚本封装到了一个叫做react-scripts的package里。默认情况下所有的配置是不可见的，但是可以通过react-app-rewired在不eject的条件下修改某些webpack配置。这样的方式在绝大多数情况下是可行的，但是如果我们想更精确的控制，比如修改默认的css打包方式、使用less、组件库按需加载等，即使也能够做，但或多或少会用到hack的方式。 在运行yarn run eject后，所有关于webpack配置将会暴露出来，在根目录会生成config和scripts两个目录，并且react-script将不复存在，所有react-script的依赖都将注入到项目中。 eject是单项操作，一旦完成，就没办法还原，这就意味着复杂的webpack管理将交由我们自己管理。 eject进行时 步骤1 运行yarn run eject，稍等片刻，观察到生成新增了config和scripts两个目录，并且package.json文件被修改。 打开package.json文件，由于我们已经不使用react-scripts了，所以这里需要修改start build test等命令。使用scripts目录中对应的脚本即可，例如： 123456\"scripts\": &#123; \"start\": \"node scripts/start.js\", \"build\": \"node scripts/build.js\", \"test\": \"node scriprs/test.js\" ...&#125; 运行yarn start，不出意外的话，项目正常运行，如果提示can’t find module xxx，删除node_modules和yarn.lock(如果有的话)，重新运行yarn install安装依赖即可。 eject后出现了问题如果是eject后运行项目报错，重新安装依赖后仍然报错，那么就要考虑是依赖版本的问题了。就比如笔者的这个项目，使用老版本的react-react-app生成，并且在中期升级了react-scripts和react等，且使用了特定版本的eslint规则。在根据报错提示进行修复后，运行项目仍然报错且无任何报错提示。 我们需要弄清楚到底是什么依赖有问题，这个过程是复杂且繁琐的，并且可能由于依赖前后版本已经发生了巨大的变化，即使找到存在问题的依赖也可能不能仅通过升级该依赖的版本解决问题。 所以一个备选方案是把项目整体迁移到新版本的create-react-app上，这里有两个做法：使用create-react-app新生成一个项目，我们把源码和依赖都迁移到新项目中，在新的项目中进行eject；使用create-react-app生成一个空的项目并eject，使用新的config和scripts替换当前项目的脚本和配置，并且比较packahe.json，更新依赖的版本，重新安装依赖，大功告成。 在实际的情况下，受制于项目版本控制、团队协作、迁移成本等，第一种方式，基本不可用。 解决完问题，接下来我们需要将写在config-overrides.js中的自定义配置进行迁移。 自定义配置 在进行自定义配置之前，如果项目因eslint规则，无法运行成功，可以尝试在config/webpack.config.js中找到eslint-loader并且注释掉这个配置，此时在开发模式下，eslint并不会对源码进行规则校验。 less支持因为create-react-app脚手架并不支持less，我们需要手动添加对less的支持。首先安装less-loader，并在webpack.config.js中的module.rules下添加：12345678910111213141516const lessRegex = /\\.less$/;module: &#123; rules: [ ... &#123; test: lessRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125;, 'less-loader' ), &#125; ]&#125; 注意到这里使用到了一个封装好的函数getStyleLoaders，其针对不同的css预处理器，生成适用的loader，源码非常简单：123456789101112131415161718192021222324252627282930313233343536373839const getStyleLoaders = (cssOptions, preProcessor) =&gt; &#123; const loaders = [ isEnvDevelopment &amp;&amp; require.resolve('style-loader'), isEnvProduction &amp;&amp; &#123; loader: MiniCssExtractPlugin.loader, options: shouldUseRelativeAssetPaths ? &#123; publicPath: '../../' &#125; : &#123;&#125;, &#125;, &#123; loader: require.resolve('css-loader'), options: cssOptions, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), require('postcss-preset-env')(&#123; autoprefixer: &#123; flexbox: 'no-2009', &#125;, stage: 3, &#125;), postcssNormalize(), ], sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125;, &#125;, ].filter(Boolean); if (preProcessor) &#123; loaders.push(&#123; loader: require.resolve(preProcessor), options: &#123; sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125;, &#125;); &#125; return loaders; &#125;; 我们知道如果使用了css预处理器，在设置loader的时候，可能需要多个loaders，例如: less-loader: 把less编译成css css-loader: 解决css使用import、require引入的问题 style-loader: 通过style标签把css注入到DOM中。 生产环境下可能还需要生成单独的css文件，css压缩等。 而getStyleLoaders就是生成这些loaders的一个公共方法。 组件库按需加载在开发过程中，如果使用到了组件库且该组件库支持按需加载(例如antd)，那么我们可以根据相关的教程配置即可。 比如在当前项目中使用到了xx-ui这个组件库，该组件库支持babel-plugin-import按需加载，在安装好依赖后，我们只需要在package.json的babel下配置plugin：123456789101112131415\"babel\": &#123; \"presets\": [ \"react-app\" ], \"plugins\": [ [ \"import\", &#123; \"libraryName\": \"@wind/xx-ui\", \"libraryDirectory\": \"es\", \"style\": true &#125; ], ]&#125; 这和传统的.babelrc中进行plugin配置无区别，但总算不用再维护额外的一个文件了。 其它比如我们在构建时需要对代码进行拆分，我们可以在webpack.config.js的optimization中使用splitChunks进行自定义、分离runtimeChunk等。 比如我们构建时不想使用默认的static/js/[name].[contenthash:8].chunk.js作为chunks的文件名，直接修改即可。注意，在代码分割时，相应的css也会被分割，如果想修改css的配置可以直接找到MiniCssExtractPlugin进行修改即可。 最后经过上面所有的步骤，项目已经能够完全正常运行，和eject之前一样。接下来我们可以详细阅读webpack.config.js，进行更进一步的定制，也可以删除某些项目中不需要的配置，减轻webpack.config.js的复杂性。 如果项目是老项目的话，为了项目能够在eject后不会因为eslint报错而无法正常运行，可以注释掉eslint-loader来避免每次构建时候的预检，但此时对代码风格的约束只限于编辑器本身eslint的支持，对代码质量和团队代码风格可能造成一定的影响。 更好的方式是使用一个适合这个项目的eslint规则，如eslint-config-airbnb-base，并且对这个第三方规则进行定制，直至这个规则适合这个项目。 完。","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"老项目Webpack构建优化","slug":"老项目Webpack构建优化","date":"2019-06-01T14:34:56.000Z","updated":"2019-06-05T00:41:49.276Z","comments":true,"path":"2019/06/01/老项目Webpack构建优化/","link":"","permalink":"http://yoursite.com/2019/06/01/老项目Webpack构建优化/","excerpt":"","text":"最近在接手一个项目的时候，由于其开发已经一年有余，整个项目使用了create-react-app脚手架，Webpack版本停留在3.x，React版本15.x，并且在线上使用效果并不好，首页加载缓慢。对于这样一个典型的老项目，进行构建优化。 在webpack 3.x之前的构建中，该项目使用CommonChunkPlugin对特定的package进行了抽取，例如react、图表库、组件库，其余使用到的package和业务代码被打包在了一起，Gzip过后差不多1MB。通过分析可以得知，分离出的第三方库和业务代码存在重复打包的情况，并且页面初始加载并不需要用到图标库，而组件库只使用到了部分组件却被完全打包了。 升级Webpack由于使用的是create-react-app脚手架，其自带了react-scripts作为webpack的配置，本项目使用的是老版本脚手架生成，Webpack版本是3.x。分析后，在不更新脚手架的前提下，直接升级Webpack，可以使用splitChunk进行代码分隔，配合新版本的React的lazy &amp; Suspense，可不引入三方库的情况下实现按需加载。 升级Webpack比较容易，直接升级最新版的react-scripts即可（注意不是react-script）。1yarn add --exact react-scripts@2.1.1 安装完后yarn start运行项目，不出意外会有报错提示，因为某些react-scripts依赖的库版本过低，此时只要删除yarn.lock和package-lock.json和node_modules，并且运行yarn install重新安装依赖即可。 安装完成后，不出意外项目可以正常运行了，此时Webpack已升级。 代码分隔 考虑到初次构建的时候仅仅分离部分第三方库导致第三方包和业务代码之间存在代码冗余，在新构建的版本中，需要对公用代码进行抽取，这样可以直接避免冗余。具体的splitChunk配置这里不再列出，抽取完成后例如lodash、moment这样的公共库被抽取到了公共包中，构建完成后生成了三个包：业务代码及未抽取的第三方包、特定的第三方包、公共代码包，构建体积明显减少。 由于业务的特殊性，首页并不包含任何图表，因此不需要加载图表库，并且图表库打包完成后大小为700KB（未Gzip），因此考虑使用基于路由的按需加载来去除首页不需要加载的资源。 进行代码分隔依赖于运行时加载，也就是import()，这是一个ES提案，目前还未标准化(babel已实现)。不同于import语法在预编译时链接代码，import()可以在运行时异步加载资源。而Webpack在解析到这种语法的时候，就会自动的进行代码分隔。 目前React懒加载的方案有很多，比如react-loadable，但由于新版的React已经支持了代码分隔，就没必要引入额外的库。React.lazy函数能够让你像处理常规组件一样处理懒加载组件。该函数接收一个函数作为参数，这个函数必须使用到import()动态加载组件，import()返回一个Promise，在resolve后返回这个React组件。Suspense是一个组件，其主要的作用是在懒加载块没有加载完成时使用占位组件进行UI 的优雅降级。 经过分析，基于路由的分隔可能最适合本项目。涉及到图表库的三个页面使用懒加载进行代码分隔，其余页面打包在一起，并且完全分离第三方库和业务代码。 1234567891011121314import &#123; lazy, Suspense &#125; from 'react';import &#123; render &#125; from 'react-dom';import Loading from '@/components/loading'const ChartPage = lazy(() =&gt; import(/* webpackChunkName: \"detail\" */'@/views/chartPage'));const App = () =&gt; ( &lt;Router&gt; &lt;Suspense fallback=&#123;Loading&#125;&gt; &lt;Switch&gt; &lt;Route path='/detail' component=&#123;ChartPage&#125; /&gt; ... &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/Router&gt;); 直接运行yarn start，观察打包结果，发现已经按照路由进行了分隔，在总打包大小基本不变的情况下，初始加载的包只有230KB，减少了一大半。 观察打包结果，发现公共包的命名是0.hash.chunk.js，对于已经在注释中指定了webpackChunkName，这显然是不正常的，可能是react-scripts默认分隔策略的问题。为了修复这个命名问题并且进一步分隔runtime chunk，对splitChunk进行少量的配置。12345678910const SplitCodeConfig = &#123; optimization: &#123; splitChunks: &#123; chunks: 'all', &#125;, runtimeChunk: &#123; name: 'runtime' &#125; &#125;&#125; 只需要进行简单的配置，设置splitChunks的chunks为all, Webpack就会使用默认的规则进行打包：抽取公共包，抽取node_modules第三方包等等，具体见Webpack官网 -&gt; 文档 -&gt; 代码分离。 至此，项目构建已经完成，构建的包可以直接用于生产换环境。 思考 在项目中使用到的组件库包含近百个通用组件和业务组件，但是项目中只使用到了十余个，并且通过观察打包结果，可以看到未被使用到的组件也被打包进来了，这显然不合理。针对这个问题，我们可以查看对应组件库的按需加载方案，并且在Webpack进行相应的配置即可。这里由于使用的是内部开发的组件库，就不在举例。 除了使用的组件库，我们需要找到所有能够按需加载却在项目中没有使用的第三方库。例如我要使用lodash的debounce函数进行防抖，我在项目中是这样使用的： 12import _ from 'lodash';window.onscroll = _.debounce(handler); 在构建的时候，整个lodash会被打包，如果只需要打包debounce函数，在import的时候直接import debounce from &#39;lodash/debounce&#39;即可。 其它 为了直观的查看构建结果，推荐使用webpack-bundle-analyzer插件，它会在构建完成后打开一个页面，该页面可以看到每个bundle的打包情况。使用也很简单: 1234567const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;&#123; ... plugins: [ new BundleAnalyzerPlugin(), ]&#125; 如果想测试Gzip后的文件大小，在webpack-dev-server的配置项中添加compress: true即可。但如果查看生产环境下构建的Gzip包大小，可以使用compression-webpack-plugin插件，该插件会在构建完成后生成对应bundle的Gzip包。 1234567const CompressionPlugin = require('compression-webpack-plugin');&#123; ... plugins: [ new CompressionPlugin(&#123; threshold: 8192 &#125;), // 只有大于8KB的资源才压缩 ]&#125; 在一般的情况下开启Gzip只需要设置生产服务器即可，并不需要在构建时生成Gzip包，但如果每次请求时再Gzip无疑会加大服务器的负担，因此事先准备好gzip包，服务器不必压缩而是直接返回，这不失为一个好的选择。 开启Gzip会极大的减小传输体积，但无论是压缩还是解压都需要大量的运算，对于某些较小的资源，使用Gzip可能反而会降低性能，因此建议只对较大的资源进行Gzip压缩，而较小的资源直接传输。 完。","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"Webpack 4.x 简易使用指南","slug":"webpack-in-thinking","date":"2019-02-25T12:54:33.000Z","updated":"2019-02-25T13:00:48.923Z","comments":true,"path":"2019/02/25/webpack-in-thinking/","link":"","permalink":"http://yoursite.com/2019/02/25/webpack-in-thinking/","excerpt":"","text":"本篇来自于之前在团队内部分享webpack时的笔记，内容比较浅显，主要讲webpack基本配置，同时webpack运行原理，自定义loader和plugin也有涉及。 Webpack4.x使用指南零配置使用Webpack 从Webpack4开始支持零配置，在不进行任何配置的形式下，直接运行webpack，webpack从src/index.js作为入口，最终结果输出到/dist。 在默认情况下，webpack只会对只会从入口开始遍历所有依赖文件，由于没有配置loaders，因此无法处理jsx/css/图片等。 在默认情况下运行webpack，打包完成后控制台会提示在配置打包的模式。在cli中通过设置--mode=production|development可以指定默认，在开发模式|产品模式下，webpack会默认启用不同插件对打包进行优化。 webpack基本配置 入口(entry)入口的配置形式有多种，例如： 123456entry: './src/index.js', // #1entry: &#123; home: './home.js', about: './about.js',&#125;, // #2entry: ['./home.js', './about.js'] // #3 第一种方式配置单一入口，所有文件将会被打包到同一个文件中，例如默认将会打包到main.js中；第二种方式是多页面(MPA)的配置方式，配置多个入口，最终将会生成多个bundle，配合html-webpack-plugin可以将对应的bundle注入到对应的html中；第三种配置的形式指定了多个入口，但是会将最终结果打包到一个文件中。 输出(output)输出指定了webpack将结果输出到哪里，如何进行输出，甚至是使用何种方式构建等，配置比较复杂。常用配置举例： 12345678910output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist'),&#125;, // #1output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist'), library: 'xxLibrary', libraryTarget: 'amd',&#125;, // #2 第一种配置方式是最基本的输出配置，它配置了输入文件的存放的目录以及文件命名，filename支持模板语法，[name].[hash].js表示使用模块名称(入口配置)以及模块标识符来命名文件。第二种配置增加了’library’, ‘libraryTarget’两个属性，而library值的作用取决于libraryTarget的值。例2中配置libraryTarget: &#39;amd&#39;表示使用amd的方式打包，而library的值将作为模块名。 123define('xxLibrary', [], function() &#123; return _entry_return_;&#125;) 而当libraryTarget: &#39;commonjs2&#39;时，表示该模块将使用commonjs的方式打包，用于node环境，而library将不起作用。此外libraryTarget的值还可以是var(默认)、this等。 加载器(loader)在webpack中module决定了如何处理项目中不同类型的模块，而加载器(loader)则是具体的处理逻辑。 noParse：指定不需要进行构建的文件。例如，指定项目中不需要对jquery进行构建，可以进行如下配置: 123noParse: function(content) &#123; return /jquery/.test(content);&#125;, 规则(rules)的配置同样比较复杂，常用的配置如下： 1234567891011121314151617181920212223242526272829303132333435rules: [ &#123; test: /\\.(js|jsx)$/, exclude: /(node_modules|bower_components)/, include: /src/, use: 'babel-loader' &#125;, // #1 &#123; test: /\\.(png|jpeg|gif)$/, oneOf: [ &#123; resourceQuery: /inline/, use: 'url-loader', &#125;, &#123; resourceQuery: /external/, use: 'file-loader', &#125; ] &#125;, // #2 &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ &#123; loader: 'css-loader', options: &#123; modules: true &#125;, &#125;, ], &#125;), &#125;,], // #3 上面列举了常用的配置loader的三种情况，第一种处理js|jsx文件时，使用exclude和include指定构建目录和不需要构建的目录，对于明确不需要构建的模块进行指定可以加快构建速度。第二种情况则是根据具体情况选择对应的loader进行处理。例如当我们使用import emoj from &#39;./emoj.png?inline&#39;时，则会使用url-loader对该png文件进行处理，对于external类型的图片，则使用file-loader处理。第三种情况则是使用多个loader并且可以传递options，例如处理css文件，这里使用了style-loader和css-loader两个加载器，并且配置了css-loader的optionsmodules: true。这里需要关注loader执行顺序，loader执行的顺序是先配置后执行，例如这里先使用css-loader解析css，再使用style-loader配置将生成好的css文件通过&lt;style&gt;标签注入到DOM中。options配置了modules: true，则开启css-modules，写法如下： 1234import style from 'index.css';let IButton = (&#123;children&#125;) =&gt; ( &lt;span className=&#123;style.btn&#125;&gt;&#123;children&#125;&lt;/span&gt;); 插件(plugin)插件(plugin)用于以各种方式自定义webpack构建过程。webpack附带了非常多的插件，可以直接使用webpack.pluginname使用，也存在非常多的第三方插件。例如： 123456789101112plugins: [ new CleanWebpackPlugin(['dist']), // #1 new HtmlWebpackPlugin(&#123; title: 'index', chunks: ['index'], &#125;), // #2 new BundleAnalyzerPlugin(&#123; analyzerMode: 'server', analyzerHost: '127.0.0.1', analyzerPort: 8889, &#125;), // #3], 上例使用了三个插件，第一个插件CleanWebpackPlugin作用是在构建输出前清空文件夹；第二个插件用于生成入口html，例如该html的title，指定其需要注入的bundle(MPA)。第三个插件则是用于分析构建结果的插件，它会在本地启动一个开发服务器，并且通过canvas来绘制构建可视化结果，方便进行构建分析和优化。 开发服务器(devServer)webpack-dev-server方便我们进行快速开发应用，它会对代码进行监控，一旦发生更改，它会立即构建，并通过补丁的方式应用更改，使得应用能够快速应用更改。并且其提供了一个基于Express开发的简易服务器，所有资源文件都存在内存中，访问速度极快，并且通过配置可以支持热替换。介绍一下常见的webpack-dev-server配置。1234567devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, inline: true, historyApiFallback: true, allowedHosts: ['host1.com', 'host2.com'],&#125; contentBase主要用于指定静态文件的存放路径，例如所需要图片等，如不指定则无法找到对应文件; compress表示是否开启Gzip压缩; inline表示是否启用内联模式，内联模式：实时重载的脚本会被插入到bundle中，构建消息将会出现在控制台。此外还有iframe模式。 historyApiFallback主要针对的是访问不存在的页面时的活动，historyApiFallback: true时访问不存在的页面会直接跳转到index.html，也可以传入一个对象更精确的进行控制跳转。 allowedHosts用于指定允许该devServer的主机。 hot是否开启热替换，如果为true的话，则会使用webpack.HotModuleReplacementPlugin插件。通过CLI的方式传递。1webpack-dev-server --hot Webpack 运行流程 概括上来说：初始化配置参数 -&gt; 绑定事件钩子回调 -&gt; 确定Entry开始遍历 -&gt; 使用loader编译文件 -&gt; 输出 webpack就像一条生产线，经过一系列处理流程后才能将源文件转换成输出结果。 每个流程的处理职责是单一的，流程之间存在依赖关系，只有当前处理完成后才能交由下一个流程处理。 插件像是插入到生产线上的一个功能，在特定的时机对资源进行处理。 webpack 通过 Tapable来组织这一切。 Webpack在运行过程中会广播事件，插件只监听它关心的事件。 —《深入浅出webpack》 Tapable的核心代码可以简化成。 12345678910111213class SyncHook &#123; constructor() &#123; this.hooks = []; &#125; // 订阅事件 tap(name, func) &#123; this.hook.push(func); &#125; // 发布 call() &#123; this.hooks.forEach(hook =&gt; hook(...arguments)); &#125;&#125; Webpack具体的流程如图所示。 初始化构建参数(依据webpack.config.js)，插件实例化，生成Compiler供插件使用，挂载自定义钩子。 依据入口递归遍历文件，并且使用对应的loader进行编译。 将编译好的文件解析成AST(抽象语法树)，分析依赖逐个拉取济源。 编译完成，输出。 编写自定义loader 在webpack中，真正起编译作用的就是各种各样的loader。loader其实是一个function，其传入匹配到的文件内容(String)，然后对这些内容做处理即可。 一个最简单的loader可以使下面这样：123module.exports = function(content) &#123; return \"&#123;&#125;;\" + content;&#125; 在config中进行配置如下：123456789101112module: &#123; rules: [ &#123; test: /\\.js$/, loader: path.resolve(__dirname, './loaders/index.js'), options: &#123; param1: 1, param2: 2, &#125; &#125; ]&#125; 这样在编译JS的时候就会在每个JS文件前加上{}; 获取自定义配置 可以使用loader-utils模块来拿到自定义配置。1234567const loaderUtils = require('loader-utils');module.exports = function(content) &#123; let options = loaderUtils.getOptions(this); console.log(options.param1); // 1 console.log(options.param2); // 2 return \"&#123;&#125;;\" + content;&#125; 数据导出 loader可以通过return来返回处理后的结果；当然，更好的方式是使用this.callback的形式。因为它更加灵活，除了content以外，还可以传递其它参数。 this.callback(error, content, sourceMap, ast)可以传入四个参数： error loader向外抛出一个错误 content 经过loader编译后的内容 sourceMap ast 本次编译生成的AST，之后执行的loader可以直接使用，而不需要再次生成 1234567const loaderUtils = require('loader-utils');module.exports = function(content) &#123; let options = loaderUtils.getOptions(this); console.log(options.param1); // 1 console.log(options.param2); // 2 this.callback(null, \"&#123;&#125;;\" + content);&#125; 异步loader对于异步loader，可以使用this.async来获取callback函数。 1234567891011const loaderUtils = require('loader-utils');module.exports = function(content) &#123; let options = loaderUtils.getOptions(this); let callback = this.async(); this.cacheable(false); // 是否缓存结果 console.log(options.param1); // 1 console.log(options.param2); // 2 setTimeout(function() &#123; callback(null, \"&#123;&#125;;\" + content); &#125;, 1000);&#125; pitch钩子可以在loader文件中exports一个名为pitch的函数，它会先于所有的loaders执行。可以在这个过程中传参，而当前rule的所有loaders都可以拿到这个参数。123456789101112131415const loaderUtils = require('loader-utils');module.exports = function(content) &#123; let options = loaderUtils.getOptions(this); let callback = this.async(); this.cacheable(false); // 是否缓存结果 console.log(options.param1); // 1 console.log(options.param2); // 2 console.log(this.data.hello); // hello setTimeout(function() &#123; callback(null, \"&#123;&#125;;\" + content); &#125;, 1000);&#125;module.exports.pitch = function(remaining, preceding, data) &#123; data.hello = 'hello';&#125; Plugin 初探 Plugin起始是一个简单的class，有一个必须要实现的apply方法。 123456789class LPlugin &#123; constructor(options) &#123; this.options = options; console.log('options', options); &#125; apply(compiler) &#123; console.log('run this plugin'); &#125;&#125; 使用12345678910const LPlugin = require('./plugins/LPlugin');module.exports = &#123; ..., plugins: [ new LPlugin(&#123; param1: 1, param2: 2, &#125;) ]&#125; plugin在初始化参数就进行实例化(事件流开始时)，因此类似于CleanWebpackPlugin在构建之前进行文件操作删除掉某些目录也是很好实现的。 Tapable &amp; Hook Tapable是Webpack构建过程中的核心所在，其暴露了tap tapAsync tapPromoise等方法，可以使用这些方法，来注入一些逻辑，这些逻辑将会在构建过程的不同时机触发。 例如:123compiler.hooks.compile.tap('LPlugin', params =&gt; &#123; console.log('触发了钩子函数');&#125;) 该钩子函数将会在compile阶段触发。 *** 自定义钩子函数1234567891011121314const &#123; SyncHook &#125; = require('tapable');class LPlugin &#123; constructor(options) &#123; this.options = options; console.log('options', options); &#125; apply(compiler) &#123; compiler.hooks.LPlugin = new SyncHook(['data']); compiler.hooks.enviroment.tap('MyPlugin', function() &#123; compiler.hooks.LPlugin.call('hello'); &#125;) console.log('run this plugin'); &#125;&#125; 1234567class LLPlugin &#123; apply(compiler) &#123; compiler.hooks.LPlugin.tap('LLPlugin', function(data) &#123; console.log('data', data); // data hello &#125;); &#125;&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"使用Webpack DllPlugin","slug":"webpack-dllplugin","date":"2019-01-06T11:52:32.000Z","updated":"2019-01-06T12:04:20.947Z","comments":true,"path":"2019/01/06/webpack-dllplugin/","link":"","permalink":"http://yoursite.com/2019/01/06/webpack-dllplugin/","excerpt":"","text":"DllPlugin 简易使用指南 创建webpack.dll.config.js 用于对特定的模块打包成dll webpack --config webpack.dll.config.js 生成dll以及其描述文件 在webpack.common.config.js中使用DllReferencePlugin引入打包好的dll文件。 打包。此时遇到相应的模块时直接引入而不会重新打包。 创建webpack.dll.config.js 这里以分别打包moment和lodash为例 1234567891011121314151617181920212223242526// config.jsmodule.exports = &#123; entry: &#123; lodash: ['lodash'], moment: ['moment'], &#125;&#125;// webpack.dll.config.jsconst webpack = require('webpack');const path = require('path');const config = require('./config');module.exports = &#123; entry: config.entry, output: &#123; path: path.resolve(__dirname, '/static/dll'), filename: '[name].dll.js', library: '[name]_library' &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, '/static/dll', '[name]-manifest.json'), name: '[name]_library', context: __dirname, &#125;) ]&#125; 解释： 推荐把入口配置信息写在单独文件中，易于维护。 DllPlugin类接受一个配置对象，该对象有三个属性：context(绝对路径), manifest文件中请求上下文；name,暴露的dll函数名；path：manifest文件存放的位置(绝对路径)。 使用DllReferencePlugin123456789101112// webpack.common.config.jsconst config = require('./config');module.exports = &#123; ... // 省略其它配置 plugins: [ ...Object.keys(dllConfig.entry).map((name) =&gt; new new webpack.DllReferencePlugin(&#123; context: __dirname, manifest: require(`./static/dll/$&#123;name&#125;-manifest.json`), &#125;)) ]&#125; DllReferencePlugin 接受一个对象用于初始化 context: manifest的上下文(绝对路径)，需和DllPlugin中的context一致 manifest: manifest文件，使用require引入或指定绝对路径 可选参数： content：模块id的映射，默认为 manifest.content name: dll文件的名称，默认为 manifest.name scope: dll 内容前缀 sourceType: dll如何暴露的？amd commonjs2 … scope: ‘abc’， 则该dll中的xyz文件可以通过require(‘abc/xyz’)来引用例如在一个dll中打包了lodash和axios两个库，并且指定了{scope: &#39;lib&#39;}，则在需要使用axios的时候使用require(&#39;lib/axios&#39;)即可。 测试1：把echarts，windui，react及其周边分别抽取成dll文件。抽取的dll文件大小分别为：753KB 1603KB，385KB。 构建方式 平均构建时间 包大小 普通 97s 4.1MB 使用Dll 71s 2.6MB dll文件 24s 2.7MB 经过对比发现，由于无法使用按需加载，所以整个windui打包的大小差不多为1.6MB，而普通的打包方式windui的大小仅为365KB。 在使用windui链接库后生成的打包，发现vendors模块中仍然含有windui，大小为330KB，仅windui中的node_modules文件夹下的rc-trigger和rc-dropdown被重用，因此这里可能重复打包了。 windui中依赖的rc-*部分模块仍然被打包。 方式二 仅对react相关模块和echarts进行打包抽取的两个dll文件的大小为393KB 769KB 构建方式 平均构建时间 包大小 普通 97s 4.1MB 使用DLL 77s 3.08MB dll 11s 1.16MB windui的大小基本不变，而windui依赖的rc-*系列组件基本没被打包。 vendors模块从0.61MB到1.67MB 使用html-webpack-include-assets-plugin 把dll注入到index.html12345const HtmlWebpackIncludeAssetsPlugin = require('html-webpack-include-assets-plugin');const dllIntoHtml = new HtmlWebpackIncludeAssetsPlugin(&#123; assets: ['./static/dll/echarts.dll.js', './static/dll/react.dll.js'], // 需要注入的dll文件路径 append: false, // 是否尾注入？push ： unshift&#125;); 因为先构建dll，再进行项目构建，在项目构建过程中会删除整个build目录，所以在构建完后再把dll文件夹拷贝进build/static/。 总结 windui进行dll打包后会因为无法按需加载而导致总大小偏高(且可能会产生冗余)；而不进行的话，包的总大小基本不变。 初始时需要加载的chunk从3个变为6个/5个 升级到webpack4.x升级到webpak4.x后无论是dll还是最终生成块，都有小幅度的下降。与此同时，构建总时间(dll构建时间+项目build时间)略微减小。 关于使用已存在的模块直接作为dll文件引入的可能性 目前无相关方面的实践。 DllPlugin抽取特定的模块构建dll文件后会生成一个manifest文件。该存储了各个模块的和公共模块的对应关系。该文件会对已经打包成dll的模块中的文件进行描述，会给每个文件指定id，并且该json文件中的name属性对应dll的library。 在进行项目构建的时候，如需要打包某个模块，会在manifest文件中查找，如果该模块已经存在于dll中，依据manifest中的信息进行链接即可，不必重新打包。 构建的dll块和使用splitChunk或者直接使用babel打包出来的块不一致。其依赖构建dll时指定的library等，而manifest文件也是和该块一一对应的。所以从理论上，使用其它方式提供dll文件由于构建方式和无法提供manifest文件，在构建过程中并不能被重用。 PS: 本片文章来自于我在团队内部分享的笔记，任何关于webpack-dll-plugin的理解和使用方式请在该插件的Webpack介绍页查看。","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"前端路由拦截和http响应拦截","slug":"前端路由拦截和http响应拦截","date":"2018-04-05T05:12:41.000Z","updated":"2018-04-05T06:08:28.000Z","comments":true,"path":"2018/04/05/前端路由拦截和http响应拦截/","link":"","permalink":"http://yoursite.com/2018/04/05/前端路由拦截和http响应拦截/","excerpt":"","text":"问题由来最近在制作毕业设计的时候，遇到一个问题，那就是用户的访问控制。简单点来说，就是未登录用户只能访问某些特定的页面、API。最初我的想法是用户登录后返回一个凭证，用户以后的每次http请求都带上该凭证，进行验证，只有验证成功才能继续请求。然后在每个页面进行判断，如果用户是未登录或者凭证失效，则进行相应的提示和路由跳转。刚开始的时候，这个方法是完全可行的，但是在开发过程中，随着业务逻辑变得复杂、页面增多，重复代码太多，这样的方式也许并不合适。 如何解决首先是后端，我使用了jsonwebtoken，用户登录成功都会生成一个具有一定时效的 token，这个token会发回到客户端，并且接下来每次发起http请求，都在http头的authorization字段带上这个token。我这里使用了axios这个http请求库，只需要在拿到token后：1axios.defaults.headers.common.authorization = `Bearer $&#123;token&#125;`; 就可以了。 由于在开发过程中涉及到跨域，这里我使用CORS来解决：通过设置一系列Access-Control-Allow-*响应头进行访问控制，上面提到了在请求头的authorization字段中设置token，因此发出的请求都不是简单请求，所以注意在每次发起http请求时，就会自动发起一个OPTIONS请求。 我服务器端用的是Express框架，我们需要写一个中间件来处理每一个请求。处理逻辑为：针对每个OPTIONS请求，直接放行；对于某些请求，如果在白名单中(例如登录、注册等不需要验证的路由)，放行；对于其他请求，我们拿到其携带的token，并且进行验证，如果验证通过，放行，否则结束请求，返回未授权。具体的代码如下，这里我使用jsonwebtoken这个package，用于生成token和进行token验证。 123456789101112131415161718192021222324252627282930313233app.use((req, res, next) =&gt; &#123; console.log('methods' ,req.method); if( req.method === 'OPTIONS' ) &#123; console.log('option请求直接通过'); next(); &#125;else &#123; // 除去某些特定的API，其余的都做token的验证 let &#123; path &#125; = req; if(path === '/api/users/auth' || path === '/api/users/auth_vc' || path === '/api/users/check_id_validation' || path === '/api/users/regist' || path === '/api/users/send_reset_email' || path === '/api/users/reset_password' ) &#123; console.log('本次请求不需要验证权限'); next(); &#125;else &#123; const token = req.headers.authorization ? req.headers.authorization.split(' ')[1] : ''; req.token = token; jwt.verify(token, KEY, (err, decoded) =&gt; &#123; if(err) &#123; res.status(401).json(&#123; status: 3, error: '用户认证失败', data: '' &#125;) &#125;else &#123; console.log('验证权限通过'); req.decoded = decoded; next(); &#125; &#125;) &#125; &#125;&#125;) 然后是前端，我想如果能像后端拦截每个请求一样，写一个逻辑拦截所有的相应，并进行处理，信号，axios自带拦截器，我们只需要写我们的逻辑就可以了。我的想法是，拦截每一个相应，如果其状态码是401，那么久提示token失效，并且进行路由跳转。以vue-cli构建的应用为例，在main.js中，下面是实现： 1234567891011121314axios.interceptors.response.use(data =&gt; data, (error) =&gt; &#123; if(error.response) &#123; switch(error.response.status) &#123; case 401: &#123; localStorage.removeItem('token'); router.replace(&#123; path: '/auth', query: &#123;redirect: router.currentRoute.fullPath&#125; &#125;) &#125; &#125; &#125; return Promise.reject(error);&#125;) 值得说明的是，如果我们在某个访问的过程中，token失效，我们需要跳转到登录页面，但是想登录过后再跳转回来，所以这里在进行路由跳转的时候，我设置了一个参数, redirect，表示传入当前的路径，当我们登录成功后，在跳转回来即可。 最后是路由拦截，这里我使用了vue-router，其实vue-router的路由对象提供一个钩子函数beforeEach，其会在每一次路由跳转之前，执行这个函数，我们就在这里进行路由拦截。原理很简单，使用一个标志位标明每个路由是否需要用户权限，如果需要的话，我们检查保存在本地的凭证，一般存在localStorage中，如果不含凭证就直接跳转到登录页面。 好了，找到根路由文件，添加： router.beforeEach((to, from , next) =&gt; { if(to.matched.some(res =&gt; res.meta.requireAuth)) { if(localStorage.getItem('token')) { next(); }else { next({ path: '/auth', query: { redirect: to.fullPath } }) } }else { next(); } }) 这里要注意的是，res.meta.requireAuth是你自己在声明路由的时候自定义的。 总结差不多，这算是一个比较好的解决方案了。但是有这样一个情况：如果用户凭证有效期是1小时，那么如果我浏览网页超过一个小时了，凭证还是保存在本地的，当我们进行路由跳转的时候，并没有验证凭证是否失效，所以还是会进行路由跳转。这里不用担心，因为进入进入了一个路由后，一旦发起http请求，token失效，http相应拦截就会生效，进而跳转到登录页面。 加油！","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"SQL参数化查询","slug":"SQL参数化查询","date":"2017-10-23T02:08:27.000Z","updated":"2017-10-23T05:34:10.000Z","comments":true,"path":"2017/10/23/SQL参数化查询/","link":"","permalink":"http://yoursite.com/2017/10/23/SQL参数化查询/","excerpt":"","text":"SQL注入想必是每个人都听过，其原理和XSS攻击很相似，都是把用户的输入当做程序去执行。防御办法也很类似，就是对用户的输入进行转义，但是同样转义十分麻烦，因为SQL注入攻击的方式和变种实在太多，转义需要考虑到的情况也复杂多变；而另外一种方式就是使用参数化查询–Prepared Statements。 SQL注入在先介绍参数化查询的时候我们先复习一下SQL注入，上面提到其原理是把用户的输入当做了SQL语句程序的一部分去执行，因为我们经常使用字符串拼接来构建SQL语句。 在这里开始演示一下(使用MySQL): 在我的数据库中我数据库中我建立了一个名为urls的表，其结构和数据如下： 123456789101112131415161718mysql&gt; desc urls;+-------------+------------------+------+-----+-------------------+----------------+| Field | Type | Null | Key | Default | Extra |+-------------+------------------+------+-----+-------------------+----------------+| id | int(11) unsigned | NO | PRI | NULL | auto_increment || url | varchar(255) | NO | | | || insert_time | timestamp | NO | | CURRENT_TIMESTAMP | || tid | bigint(20) | YES | | NULL | |+-------------+------------------+------+-----+-------------------+----------------+mysql&gt; select * from urls;+----+-----------------------+---------------------+------+| id | url | insert_time | tid |+----+-----------------------+---------------------+------+| 1 | http://www.limoer.cc | 0000-00-00 00:00:00 | NULL || 2 | http://baidu.com/news | 0000-00-00 00:00:00 | NULL || 3 | http://do.io | 0000-00-00 00:00:00 | NULL || 5 | http://github.iod | 0000-00-00 00:00:00 | NULL |+----+-----------------------+---------------------+------+ 该表有4字段并且有4条记录，现在我们如果想要查询id=1的那条记录，应该这样写:select * from urls where id=1。执行该条语句，正确返回结果，现在我们修改一下这条语句，改成：select * from urls where id=1 and 1=1,执行这条语句，同样没问题，返回结果正常；我们接下来再把and 改成 or再执行，结果出乎我们的意料，我们把所有的记录都查询了出来，id=1的限定条件失效了。至于如何导致其失效，是因为or后面的条件1=1是恒等的，所以前面的限定条件已经不重要了，and也是如此，我们想要获取正确的结果，那么and后面的限定条件必须要正确才可以。 说到这里，其实我们就已经进行了一次SQL注入的攻击，并且窃取了数据库的所有记录(更严重的删库、窃取管理员密码也很easy)！ 其实不光是上面演示到的使用and or来进行SQL注入，还有很多神奇的SQL语法让SQL注入有了可乘之机，例如我们常用的union等等。 解决办法如果我们把上面情景放在实际开发过程中，我们可能现在有一个输入框，用户可以输入任意一个数据来查看某条记录，服务端的SQL语句也许是这样的：select * from urls where id=${userInput}。如果某个淘气的用户不遵守约定输入了非数字，例如10 or 1=1，SQL语句拼接过后就成了这样:select * from urls where id=10 or 1=1，表中的信息一次被完全暴露！ 针对上面的情况，我最想想到的不是转义输入也不是使用参数化查询，而是针对本问题，我们直接对其进行输入验证即可，既然其必须限定用户输入数字，那么在进行SQL拼接之前，对用户输入进行验证即可！ 例如，在Node.js环境下，我们可以使用parseInt(userInput)就可以完成对用户输入进行强制性的验证。 第二种也就是最常用的解决办法就是转义，和防御XSS攻击一样，我们需要构建用于转义的函数，对用户的输入进行转义，还是上面的那个例子：1select * from urls where `id`= $&#123;id&#125;; 如果用户输入1 or 1=1，那么毫无疑问将会导致一次非常严重的SQL注入攻击，现在假设我们已经写好了我们的转义函数escape，我们只需要在进行字符串拼接之前，做一次转义即可。 例如对于用户的输入1 or 1=1经过转义后变成了&#39;1 or 1=1&#39;，经过SQL拼接过后则变成了:1select * from urls where `id`='1 or 1=1'; 不出意外，我们得到了正确的结果。 关于转义函数escape如何实现，这里就不不再多说，很多数据库的驱动工具都带有相应的工具函数，我们在实际开发过程中一定要注意对用户的输入进行转义，来避免SQL注入攻击；当然，如果你使用参数化查询的话，就完全没有必要了。 参数化查询最开始提到参数化查询的时候，我提到了Prepared Statements也就是预处理语句，其实我们可以把参数化查询理解为预处理，我们把完整的一次SQL查询分成两部分，第一步是预先查询，第二步使用参数得到结果。具体该怎么理解呢，还是接着上面的那个例子，现在我们使用参数化查询执行select * from urls where id=1。其分为两步，第一步执行select * from urls where id=?，注意这里的?，其实代表了未来将要传入的参数；第二步，传入用户的输入作为具体的id值，并且输出结果。这里要注意，因为执行完第一步的时候期待第二步传入的是一个用户的id(这里必须是数字)，这时候用户传入的非法输入就不会生效，这也就从根本上杜绝了了SQL注入攻击。 好了，参数化查询(预处理)可以完全避免SQL注入，其还有其他的优点例如更加可读(相比于字符串拼接)，多次查询性能会有提升(因为会对预处理语句进行缓存再利用)等。 说了这么多，那么如何使用参数化查询呢？很简单，使用一个支持该特性的数据库连接工具就可以了，比如我们下面要演示的Node环境下MySQL的参数化查询。 Demo我们在Node环境下进行演示，首先通过npm install mysql2命令安装数据库连接工具，这里是mysql2,能够支持参数化查询。 如下： 12345678910111213141516171819202122232425262728293031const mysql2 = require('mysql2');const conn = mysql2.createConnection(&#123; host: 'localhost', user: 'admin', password: '123', database: 'news'&#125;);// 不使用任何防护手段(将导致SQL注入攻击)const userInput = '1 or 1=1';conn.query( `select * from urls where id=$&#123;userInput&#125;`, (err, result) =&gt; &#123; console.log(result); &#125;);// 使用转义(这里默认进行了转义)conn.query( 'select * from urls where `id`=?', ['1 or 1=1'], (err, result) =&gt; &#123; console.log(result); &#125;);// 使用参数化查询conn.execute( 'select * from urls where `id`=?', ['1 or 1=1'], (err, result, fields) =&gt; &#123; console.log(result); &#125;); 尾巴关于SQL注入和参数化查询就介绍到这里，如果你觉得参数化查询两步走我说得并不明确，你可以使用抓包工具来加深理解；还有最后的Demo，其实query和execute的区别就是一个支持了参数化查询而另外一个不支持；如果你运行Demo，仔细看，区别就藏在里面(Tips：B &amp; T)；最后，请总是使用参数化查询！","categories":[],"tags":[]},{"title":"使用react-transition-group实现路由切换动画","slug":"使用react-transition-group实现路由切换动画","date":"2017-09-01T01:14:52.000Z","updated":"2017-09-01T02:35:14.000Z","comments":true,"path":"2017/09/01/使用react-transition-group实现路由切换动画/","link":"","permalink":"http://yoursite.com/2017/09/01/使用react-transition-group实现路由切换动画/","excerpt":"","text":"我们在使用React开发SPA的时候，使用react-router可以完成路由切换，但是这样路由切换是非常生硬的。有什么解决办法呢？我们可以使用react-transition-group来实现自定义的路由切换效果。 需要注意的是react-transition-group目前有两个版本，v1和v2版本的差距十分巨大，本教程使用的是最新的V2版本，你可以使用npm install --save react-transition-group来安装，如果想安装v1版本，则只需使用npm install --save react-transition-group@1.x命令即可。 react-transition-group主要提供三个组件Transition、TransitionGroup、CSSTransition。从名字当中我们知道TransitionGroup作为一个容器组件，而其它两个组件才是实现动画的关键。这里我只介绍CSSTransition如何使用以及其注意的点。如需了解更多react-transition-group,请查看官方文档。 CSSTransition这个组件主要是使用css来控制组件的转场。它使用了在缓动中appear、enter、exit的三个状态，并且提供钩子类让我们自定义效果。 我们常用到的类有： .className-enter .className-enter.className-enter-active .className-exit .className-exit.className-exit-active 这里className是你自定义动画的名称，和V1版本大体相同的钩子类，只不过把leave改成了更加语义化的exit，这里需要注意。 CSSTransition有多个十分重要的属性： classNames属性接收一个字符串类名，注意这里是classNames而不是className。 timeout用于规定动画执行的时间，如果enter和exit的持续时间相同的话可以使用timeout={number}即可，如果持续时间不一样，则timeout接收一个字典,两个键分别是enter和exit。 其他参数例如onEnter、onExit你可以自定义逻辑在动画进行到某个阶段后触发。 动画进行的阶段：enter-&gt;entering-&gt;entered-&gt;exit-&gt;exiting-&gt;exited。 例子123456789101112131415161718192021222324252627282930let App = () =&gt; ( &lt;BrowserRouter&gt; &lt;Route render=&#123;(&#123;location&#125;) =&gt; &#123; return &lt;div&gt; &lt;Route exact path=\"/\" render=&#123;() =&gt; ( &lt;Redirect to=\"/home\"/&gt; )&#125;/&gt; &lt;TransitionGroup&gt; &lt;CSSTransition key=&#123;location.pathname.split('/')[1]&#125; classNames=\"transitionWrapper\" // 这里一定要注意的是：classNames 而不是className timeout=&#123;400&#125; mountOnEnter=&#123;true&#125; unmountOnExit=&#123;true&#125; &gt; &lt;div className=\"wrapper\"&gt; &lt;Switch location=&#123;location&#125;&gt; &lt;Route exact path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/inspiration\" render=&#123;() =&gt;&lt;NavLink style=&#123;&#123;marginRight: '20px', marginLeft: '20px'&#125;&#125; to=\"/home\"&gt;HOME&lt;/NavLink&gt; &#125;/&gt; &lt;Route path=\"/mood\" render=&#123;() =&gt; &lt;h1&gt;this is page3 mood!&lt;/h1&gt;&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/CSSTransition&gt; &lt;/TransitionGroup&gt; &lt;/div&gt; &#125;&#125;/&gt; &lt;/BrowserRouter&gt;);","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"使用antd和css-modules冲突的解决办法","slug":"使用antd和css-modules冲突的解决办法","date":"2017-08-28T13:29:03.000Z","updated":"2017-11-04T14:15:48.000Z","comments":true,"path":"2017/08/28/使用antd和css-modules冲突的解决办法/","link":"","permalink":"http://yoursite.com/2017/08/28/使用antd和css-modules冲突的解决办法/","excerpt":"","text":"在暑假做项目实训的时候前端就使用到React构建并且使用了Ant Design作为组件库，当时就使用了extract-text-webpack-plugin把css单独抽离出来成为一个单独的css文件并引入，当时就遇到一个问题，当我使用css-loader来处理css时，并不能处理自定义的css，但是我把CSS直接写进组件中是可行的，由于当时项目比较小并且时间比较赶，就直接使用了这种方式，在开发过程中也有苦说不清，但总算是完成了。 最近想写一点东西，又用到antd了，当然是相同的问题，只不过时过境迁，我有足够多的时间来处理这个遗留下来的问题。可是即使有那么多的时间，可是还是踩坑无数，最终还是完成了。相信遇到这个问题的并不止我一个人，这里就先记录下来，希望能对你有所帮助。 解决办法经过查询和思考，解决这样的问题最好是单独处理antdCSS和自定义的CSS。好了问题解决办法已经很明显了，我们需要些两个不同的规则来出来css，就像这样：12345678910111213141516...&#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: 'css-loader' &#125;)&#125;,&#123; test: /\\.css$/, exclude: /node_modules/, use: 'css-loader'&#125;,...plugins: [ new ExtractTextPlugin('style.css')] 上面的代码我建立了两规则分别处理自定义css和antd 预定义css，我们可以正常的使用import &#39;./style.css&#39;的形式引入css，但是我们查看页面，并没有加载我们自定义的css。 好吧，既然这样再试试css-modules的方式算了，我们把第二个规则改成下面这样：123456789101112...&#123; test: /\\.css$/, exclude: /node_modules/, use: [ loader:'css-loader', options: &#123; modules: true, localIndentName: '[local]--[hash:base64:5]' &#125; ]&#125; 现在我们可以通过import style from &#39;./style.css&#39;的形式引入自定义css，并且通过style.className的形式给元素设置类。这次倒好，直接build不成功了，我一气之下索性不搞了；为了继续捣鼓下去，我直接又把CSS写在组件中了，直到我要使用react-transition-group来做路由切换动画，不得不倒回来解决。这次比以往更加冷静，我仔细阅读了extract-text-webpack-plugin的readme过后，恍然大悟，原来我们可以在一个项目中使用多个ExtractTextPlugin实例来生成多个css文件！好了，这次还是通过两个规则处理css，并且构建两个css文件，一个是自定义的css，一个是antd css，问题迎刃而解，又可以开心的捣鼓了！ 好了，show you the code!:1234567891011121314151617181920212223242526272829303132333435363738394041const ExtractTextPlugin = require('extract-text-webpack-plugin');const extractANTDCSS = new ExtractTextPlugin('[name]-antd.css');const extractNormalCSS = new ExtractTextPlugin('[name]-normal.css');module.exports = &#123; ... module:&#123; rules: [ &#123; test: /\\.css$/, include: /node_modules/, loader: extractANTDCSS.extract(&#123; fallback: 'style-loader', use: [&#123; loader: 'css-loader', options: &#123;modules: false&#125; &#125;] &#125;) &#125;, &#123; test: /\\.css$/, exclude: /node_modules/, use: extractNormalCSS.extract(&#123; fallback: 'style-loader', use: [&#123; loader: 'css-loader', options: &#123; modules: true, localIndentName: '[local]--[hash:base64:5]' &#125; &#125;] &#125;) &#125; ] &#125;, plugins: [ extractANTDCSS, extractNormalCSS, ... ]&#125; 以上的两个loader会生成两个css文件，分别是vendor-antd.css和main-normal.css，我们只需要在正确的位置引入这两个css文件就好了！ 尾巴我在前面提到我把CSS直接写在元素/组件的style标签中，其实这种方式实不可取的，它会让你在编码和代码review中苦不堪言，因为一旦项目变得很大，当你想修改某个样式的时候，花在定位CSS的时间是非常多的；并且，可读性和可复用性也会大打折扣；而且我们经常在写样式的过程中使用的各种选择器、伪类、伪元素都无法发挥其灵活的作用。所以，无论你是以何种方式写前端，请尽量不以这种方式写CSS。 当然，我们也要从性能上去考虑。因为css是在页面解析正式前就加载好了的(写在header)里面，在我们再解析页面的时候，加载速度就会变得更快；再有，如果我们使用把CSS写在组件中后，无可避免的会产生更多的重绘和回流，这会严重影响渲染性能。比如我们使用JS修改我们在style属性中标明的样式，那么必然会触发一次repaint。 好了，到此打住！如果你想学习reflow和repaint，点击这里，也许会帮助你！","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Three.js","slug":"three-js","date":"2017-08-24T07:44:03.000Z","updated":"2017-11-04T14:29:02.000Z","comments":true,"path":"2017/08/24/three-js/","link":"","permalink":"http://yoursite.com/2017/08/24/three-js/","excerpt":"","text":"最近貌似Node又有了新的fork ayo.js(怎么读！哎呦？)，加之前端一不留神就出框架的节奏，在2016年就开始用Next(wtf！你能看出来其是一个前端框架？)来命名，以后恐怕就得future.js、plus.js的节奏…贵圈真乱啊！ 当然当然，这和我们今天的主角three.js并没有太大的关系，比起这些看了名字不知所云的xxx.js，Three.js这个就和明显了，其是一个3d JavaScript库，更准确的说是用JavaScript编写的WebGL三方库，那么什么是WebGL呢？这个我不解释，有兴趣的小伙伴可以去探索。 作为我最想学却一直学不会的技术之一，WebGL的确对于大部分的前端猿们来说有些复杂和繁琐了，早些时候我花了大量的时间去啃API，学习如何使用，可到目前脑子还是一团乱麻。既然这样的话，我们得另辟蹊径，不能因为有困难就放弃学习不是！所以我了解到了Three.js，其化繁为简，做同样的事，其只需要少于1/5的代码量就可以完成，并且API也十分通俗易懂，学习难度降低了不少，可以让我们关注使用WebGL创造而不是痛苦的学习和编码。 如果你还不理解WebGL是什么，这是官方文档上的原话： WebGL (Web Graphics Library) is a JavaScript API for rendering interactive 3D and 2D graphics within any compatible web browser without the use of plug-ins. WebGL does so by introducing an API that closely conforms to OpenGL ES 2.0 that can be used in HTML5 canvas elements. 如果你对Three.js比较有兴趣的话可以直接进去官网，其中首页展示了很多featured projects，个人比较喜欢这个Paper Planes。 你也可以去gayhub把Three.js代码download下来，里面有很多很多(大约几百个例子)可供学习，当然如果你想学习Three.js，来百度云下载，这是目前少有的全方面介绍Three.js的书籍。 好了，差不多介绍完该跑了。但是我好想发现了我竟然连副标题都没取，好吧，还是再多讲一会儿，为了彰显Three.js的简单易用的特性，我讲决定再写一个全面但是简单的例子，并且配上必要的讲解。 例子？不存在的！这是一个很小的例子，它将会展示Three.js使用流程，并且是经过测试没有错误(也许有！)，请放心食用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf8\"&gt; &lt;title&gt;使用Three.js&lt;/title&gt; &lt;script src='./three.js'&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"three-container\"&gt;&lt;/div&gt; &lt;script type='text/javascript'&gt; // three.js中有几个非常重要的知识点，为了构成一个3D程序，我们至少需要以下几部分。 // 1. Scene 场景，用于承载一些必要元素 let scene = new THREE.Scene(); // 2. Camera 相机(此相机非你想的那个相机哦！) // Three.js中提供了两种相机，透视相机和正交相机，这里使用的是透视相机(类似于人眼看到的) let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerWidth, 1, 1000); camera.position.set(-20, 40, 20); // 3. renderer 渲染器， 也可以在canvas中渲染，但是复杂场景可能有性能问题 let renderer = new THREE.WebGLRenderer(); renderer.setClearColor(0x708090); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMapEnabled = true; // 4. 物体 let cubegeo = new THREE.CubeGeometry(10, 10, 10); // 5. 材质 用于物体表面，不同材质包含不同特性，可设置颜色等。 let material = new THREE.MeshLambertMaterial(&#123; color: 0xffffff &#125;); // 组合物体与材质成为一个网格 let cube = new THREE.Mesh(cubegeo, material); // 设置物体能够产生光源阴影 cube.castShadow = true; scene.add(cube); // 6. 光源 Three.js中存在多种光源 let light = new THREE.SpotLight(0xfffff); light.position.set(-30, 40, -20); light.castShadow = true; scene.add(light); // 设置相机看向场景远点(空间坐标系原点) camera.lookAt(scene.position); // 添加到HTML中 document.getElementById('three-container').appendChild(renderer.domElement); // 为了更加直观，这里设置一下空间坐标系 let axes = new THREE.AxisHelper(30); scene.add(axes); // 动起来吧！添加动画 function animation() &#123; // 比如移动转动方块， 这里设置在x、y轴转动平面 cube.rotation.x += 0.1; cube.rotation.y += 0.1; requestAnimationFrame(animation); renderer.render(scene, camera); &#125; requestAnimationFrame(animation); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 尾巴即使是这样一个简单的例子，我如今也没有办法在不参考官方文档的情况下一口气写下来，原因无非在于，虽然其简化了开发，但是概念还是偏多并且需要记住每个API也是在有难度。 但是，如果我们能够十分清楚的理解制作3D应用的流程，至少是使用Three.js的流程，按照流程十分有条理的写下去，代码总归是十分清晰的。 time waiting for no one，这是我最近在看《穿越时空的少女》看到的。对啊，时间不等人，珍惜好为说不多的’自由’而’枯燥’的时间吧！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"从Decorator到Mobx","slug":"从decorator到Mobx","date":"2017-08-02T06:03:25.000Z","updated":"2017-08-07T02:13:56.000Z","comments":true,"path":"2017/08/02/从decorator到Mobx/","link":"","permalink":"http://yoursite.com/2017/08/02/从decorator到Mobx/","excerpt":"","text":"最近在开发一款视频编辑器，其中就用到了Mobx作为状态管理工具。Mobx中很重要的概念例如可观察(observable)的状态，可计算(computed)的值都用到了decorator(当然在使用Mobx时可以不用)。Decorator作为ES7引入的新特性，用于给类/属性添加新行为。对于不少初学者而言，可能对其并不是很了解，所以在这里从装饰器开始，聊聊我对Decorator和Mobx的理解。如果你正在学习Mobx，希望能对你快速上手Mobx能有所帮助。 先说装饰器(Decorator)装饰器是ES7中引入的，其目的在于修改类/方法的行为。例如我们可以在不修改“类”的情况下为其增加新的功能。 例如：我们定义了一个学生“类”，其中有name，age两个属性，以及showInfo一个方法。 123456789class Student &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; showInfo = () =&gt; &#123; console.log(`name:$&#123;this.name&#125;, age: $&#123;this.age&#125;`) &#125;&#125; 如果此时我们想为这个类添加一个属性school用于标明学校，，在不修改“类”的情况下，我们可以使用装饰器这么做： 1234567891011121314151617function addSchool(target) &#123; target.prototype.school = 'SDU';&#125;@addIdclass Student &#123; // ...&#125;/** @decorator class A&#123;&#125; 等价于 A = decorator(A);*/let limoer = new Student('limoer', 21);console.log(limoer.school); // &gt; SDU addSchool()给Student“类”的原型对象上添加了一个属性，现在所有实例都可以取到school这个属性。 更深入一步，上面看到用于装饰的函数只接收一个目标“类”作为参数，如果我们有多个参数的话，可以写成高阶函数的形式(即返回一个函数)。同样是上面的例子，现在学校由参数指定，我们可以这样写： 12345678910111213function addSchool(school_name) &#123; return function(target) &#123; target.prototype.school = school_name; &#125;&#125; @addSchool('CQMU')class Student &#123; // ...&#125;let lin = new Student('lin', 20);console.log(lin.school); // &gt; CQMU 装饰器不但可以装饰“类”，也可以对方法(…属性)进行修饰，使用的方式类似于对“类”的修饰，不过用于修饰的函数接收三个参数,target将要被修饰的对象, name被修饰的属性名, descriptor被修饰的属性的描述对象(ES5中详细介绍过)。 写一个简单的例子： 12345678910111213141516171819202122function showCount(target, name, descriptor) &#123; let prev = descriptor.value; descriptor.value = function() &#123; console.log('count:' + StudentList.list.length); prev.call(null, arguments); &#125; return descriptor;&#125;class StudentList &#123; static list = ['limoer', 'lin']; @showCount showNames () &#123; console.log(StudentList.list.join(' ')); &#125;&#125;let list = new StudentList();list.showNames(); // count:2 \\n limoer lin 上面的代码给StudentList类的showNames方法添加了打印数量的功能，并且是在不改变原有“类”结构的情况下。 说明，在现有的浏览器环境和Node都不能运行上面的代码(暂不支持装饰器)，如果想运行的话，可以借用babel 并且使用相关插件(babel-plugin-transform-decorators-legacy)的前提下进行compile，之后就可以进行了。推荐开发过程中webpack和babel结合使用，效果更佳！ 好了，关于Decorator简单介绍到此到一段落，更多的相关知识请自行发掘和学习。接下来，是时候了解并使用Mobx了！ Mobx？想说爱你不容易！在文章最开头谈到我在最近的学习开发中使用了Mobx作为状态管理工具，最主要的原因是其相比Redux，学习和快速上手成本的确消了很多，并且它足够简单。但是在后来的开发过程中，虽然其可以没有redux中action，也不存在reducer，更是告别了单一而庞大的store，我们可以定义多个state用于保存状态，让每个状态或者是每个类属性添加注解，让其编程可观察的状态，而为了能够自动的更新值，我们可以通过使用computed这个装饰器或者autorun函数来完成。可是，在使用过程中，定义多少个状态，每个状态的结构又是如何，等等等等，都困扰着我，远没有使用redux来得清晰和直观。这也许是因为我对mobx目前刚好达到基本使用的程度，并没有深入的了解。基于此，接下来，我只谈谈Mobx入门，至于该如何优雅的使用，请自行摸索。 几个概念 可观察的状态 这也许是Mobx最基础也是最重要的概念了。我们可以使用Mobx提供的observable装饰器，让基本的数据结构(数组、对象、原始值等)变成可观察的。使用的方式如下： 12345678910let TimeState = observable(&#123; currentTime: Date.now()&#125;)TimeState.set(\"currentTime\", new Date().toString());class AppState &#123; @observable list = ['limoer', 'lin'];&#125;let state = new AppState();console.log(state.list.length); // &gt; 2 好了，最简单的例子就是这样，我们使用ES5和ES6 decorator的方式分别创建了两个state，第一个state我们适应装饰器让一个对象(Map)变得可观察，而第二个我们则是对一个“类”属性(为一个数组)进行了修饰，让其变成可观察的。 这里值得注意的是，如果一个数据结构变得可观察，那么其类型也会发生改变，例如我们让一个数据变得可观察，此时其已经变成了一个 Observable Array， 这是一种Mobx定义的数据结构，拥有其独特的API，此时使用Array.isArray(state.list)讲返回false，因为Observable Array 并不是一种数组类型。 好了，当看到这里，你是否有这样一个疑问：让一个数据结构变得可观察，其作用到底在哪里呢？其实很简单，我们都知道Mobx是React的小伙伴，其目的是在于替换React本身的state，我们都知道对于React而言，如果一旦state发生改变，就将导致页面更新并且重新渲染，基于此，让数据结构变得可观察，其目的是在于当被观察的数据发生改变，React也能做出相应的更新和重绘操作等，并且，这样的重绘是经过Mobx优化的，只进行必要的重绘来增加性能！ 可计算值 可计算值是通过现有状态和其它可计算值派生出来的值。这很好理解，我们在使用React的时候，往往要通过state衍生出很多的值，例如如果state的一部分是一个数组，那么我们通过衍生得到的数组长度就是一个计算值，并且在Mobx中，一旦可观察的state或者其他computed value 发生改变，可计算值就会重新计算。其实，在实际的React项目中，我们在很多地方都使用到了计算值。 还是上面AppState的例子，现在我们给其增加一个计算值， 12345678910class AppState &#123; @observable list = ['limoer', 'lin']; @computed get count() &#123; return this.list.length; &#125;&#125;let state = new AppState();console.log(state.count); // &gt; 2state.list.push('lindo');console.log(state.count); // &gt; 3 count是一个计算值，一旦list发生变化，其就会自动重新计算，可以保证，count的值每次都是最新的，并且都是等于list数组的长度。 autorun 其作用和函数名一样好理解，其会自动执行；autorun其本身是一个响应式函数，其使用到的依赖关系state/computed value等一旦发生改变，其就会自动执行一次，效果和计算值类似，但是计算值和autorun的应用场景是不一样的，computed value通常会产生一个新值而autorun达到某种目的而不产生新值，例如生成日志，处理网络请求等。还是上面的例子，我们继续扩展： 1234class AppState &#123; // ...省略前面的代码 let logcount = autorun(() =&gt; &#123;console.log('count: ' + this.count)&#125;);&#125; 这里我们在autorun中使用了computed value， 一旦发生count改变，就会自动打印出新的count值；当然，初始化state实例对象的时候，就会先执行一次。 action 动作是用来修改状态的。并且只应该对修改状态的函数使用action，要使用动作很简单，使用@action修饰一个函数或者使用action(fn)，把要修饰的函数作为参数即可。继续上面的例子：12345678910111213class AppState &#123; // 省略上面的代码 @action.bound addOne(name) &#123; this.list.push(name); &#125; // 或者 @action addOne = (name) =&gt; &#123; this.list.push(name); &#125;&#125; 上面我们定义了一个函数，用于向列表中添加一个姓名。请注意，ES6 class的写法无法自动绑定到对象，所以使用`@action.bound` 或者是使用ES6中引入的箭头函数(推荐)。 与React使用 observerobserver是由mobx-react包(需独立安装)提供的用于让组件变成响应式组件的decorator。官方文档中写到：它用 mobx.autorun 包装了组件的 render 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件。 123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from 'react';import &#123; render &#125; from 'react-dom';// 其余依赖省略@observerclass NameList extends Component &#123; addUser = (e) =&gt; &#123; e.preventDefault(); if(this.uname.value)&#123; this.props.appstate.addOne(this.uname.value); &#125;else&#123; console.log('must input user name!'); &#125; &#125; render() &#123; return &lt;div&gt; &lt;ul&gt; &#123; this.props.appstate.list.map((index, name) =&gt; &#123; return &lt;li key=&#123;index + 10&#125;&gt;&#123;name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;div&gt; &lt;p&gt;当前用户人数：&#123;this.props.appstate.count&#125;&lt;/p&gt; &lt;label for=\"uname\"&gt;姓名&lt;/label&gt; &lt;input type=\"text\" name=\"uname\" ref=&#123;(ref) =&gt; this.uname = ref&#125;/&gt; &lt;button onClick=&#123;this.addUser&#125;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &#125;&#125;render(&lt;NameList appstate=&#123;appstate&#125; /&gt;, document.getElementById('app')); 上面是一个响应式组件的例子，结合了上面定义的状态，我们可以查看所有的姓名、数量，并且可以通过点击按钮来改变state。其实observer对非响应式组件仍然有效，同样是上面的例子： 1234567const List = observer((&#123;appstate&#125;) =&gt; &#123; return &lt;ul&gt; appstate.list.map((index, name) =&gt; &#123; return &lt;li key=&#123;index + 19&#125;&gt;&#123;name&#125;&lt;/li&gt; &#125;) &lt;/ul&gt;&#125;) 好了，对于observer的介绍就告一段落，更多的Mobx和React连接的方式，以及Mobx提供的生命钩子函数等相关知识你可以查看官方文档来了解。 尾巴 自从放了暑假回了家，效率下降特别多，在学校的时候以为回家可以安心学习，到了家才知道一切都变了，该做的事情还没做，还有更多的知识要学习。所以，早早回学校也许是一个不错的选择！所以再过几天，就要启程回学校了，在最后一年里，期待所有的努力都没有白费，期待一个新(好)的开始！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"响应式布局的那些事","slug":"响应式布局的那些事","date":"2017-07-31T10:16:53.000Z","updated":"2017-07-31T13:14:00.000Z","comments":true,"path":"2017/07/31/响应式布局的那些事/","link":"","permalink":"http://yoursite.com/2017/07/31/响应式布局的那些事/","excerpt":"","text":"响应式设计在如今的web开发过程中已经是必不可少，它可以针对不同的设备环境对页面进行调整，并且可以在PC端和移动端达到很好效果的情况下，不用开发多套页面，可以提升开发速度，可维护性打打增强。 响应式布局响应式布局的一种实现方式的原理是使用CSS3新引入的Media Query来调整元素在不同分辨率下的显示效果，并且通过JavaScript进行交互。总结起来，响应式布局有以下几个需要注意的点： 设置Viewport 我们知道，在移动设备中，页面被放置在虚拟的窗口中，这个窗口也称作视口(Viewport),对于未进行移动端适配或者是未进行响应式设计的页面，往往页面的宽高都会大于移动设备的宽高，所以为了能够在移动设备上进行页面交互，缩放是不可避免的，但是频繁的放大缩小带来的浏览体验肯定不会好。所以，在响应式设计的第一步，就是要禁止移动设备的缩放，这很容易实现，我们只需要在html页面中的head元素下添加一个meta标签用于规定禁止缩放就可以了： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no, maxinum-scale=1.0\" /&gt; 使用Media Query 媒介查询才是响应式布局的关键所在，我们使用Media Query 来实现在不同尺寸下使用不同的样式。Media Query的规则有很多，例如@media screen and (max-width: 980px){...}就表示了在980px下的屏幕下使用在此定义的各种样式，同样还有min-width、orientation(设备方向)等属性，我们需要按需进行设置。 使用JavaScript 如果能做到上面的两点，在一般情况下，响应式布局是可以实现的。但是如果在布局的过程中需要改变交互，那么JavaScript久必须派上用场了。例如一个菜单栏，在十分小的屏幕下需要折叠，那么就需要用到JavaScript。 Code上面是我能够想到的响应式布局的一些要点，在实际学习过程中，我并没有在一些项目中使用相应式设计的方式(貌似很悲哀…)。在目前移动为先的时代，为移动端做更好的优化是不可避免的，无论是使用重新写一套移动端页面，还是使用响应式布局，或者使用其他的例如Flex Box来进行布局。作为一个工作在浏览器端的🐒，这都是我们必须具备的素质。 好了，写一个简单的小例子吧。如果你从未接触过响应式布局，那么希望接下来的code会帮助你更快地了解并应用它。 我们来写一个菜单栏，其HTML结构‍如下：123456789&lt;div id=\"nav\"&gt; &lt;ul id=\"nav-list\"&gt; &lt;li&gt;&lt;a href=\"#\" id=\"home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" id=\"topic\"&gt;Topic&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" id=\"today\"&gt;Today&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" id=\"about\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" id=\"concat\"&gt;Concat&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; CSS如下： 12345678910111213141516171819202122232425262728293031323334353637* &#123; margin: 0; padding: 0; &#125;#nav &#123; position: relative;&#125;#nav-list ul li &#123; list-style: none; box-sizing: border-box; width: 20%;&#125;#nav-list ul li a &#123; display: block; text-align: center; text-decoration: none; color: #FFF; line-height: 4em; font-size: 1.4em;&#125;#nav-list ul li:nth-child(1) a &#123; background-color: #bcbcbc;&#125;#nav-list ul li:nth-child(2) a &#123; ... /*添加背景色*/&#125;#nav-list ul li:nth-child(1) a:hover &#123; background-color: rgba(188, 188, 188, .8); /*添加鼠标移上去的样式*/&#125;#nav-list ul li:nth-child(1) a::before &#123; content: '' /*使用伪类来添加图标字体等*/&#125; 现在，我们来为屏幕宽度小于768px写一个样式： 12345678910111213141516@media screen and (max-width: 768px) &#123; ul li a::before &#123; font-size: 20px; line-height: 60px; &#125; ul li a &#123; font-size: 0; height: 60px; &#125; /* 上面的的样式指明了再768px宽度及以下，我们设置a标签的font-size为0，不显示字体。 设置伪元素所在的图标字体的行高等于a标签的宽度，使其垂直居中。 通过上面的简单设置，我们在小于768px跨度的屏幕下，对于该菜单就只能看到图标了。 */&#125; 接着，我们可以为更窄的屏幕设置折叠菜单，我们通过css来绘制折菜单，使用JS来显示和隐藏。具体的实现这里就不贴出来了。 ok，到此为止，我们已经写好了一个响应式菜单栏了(虽然…)。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Demo--Canvas with React","slug":"Demo-Canvas-with-React","date":"2017-05-27T12:34:19.000Z","updated":"2018-09-01T02:06:50.372Z","comments":true,"path":"2017/05/27/Demo-Canvas-with-React/","link":"","permalink":"http://yoursite.com/2017/05/27/Demo-Canvas-with-React/","excerpt":"","text":"一个使用Canvas处理图片的Demo，使用React + webpack + Redux 的技术栈，非常适合初学者，希望你喜欢！ 为什么学习canvas已经有一阵子了，忙完了计组课设，考完了数据挖掘，终于有时间来做一点小Demo来巩固自己所学的知识了。就像上面介绍的那样，这是一个使用Canvas进行图片处理的Demo，其可以选择本地图片，改变其R G B 以及透明度，然后可以选择保存到本地。并且为了重温很久没碰的React，前端使用了React，使用Redux进行数据的管理(虽然简单到没必要使用),并且使用了css modules 以便直接在组件中使用css。当然这一切都是在使用webpack进行编译打包的情况下。 这个Demo十分简单，特别适合React初学者食用，相信会对你的React学习有所帮助！ 如何运行 从我的github上clone到本地; 进入Demo根目录, 执行npm init 安装依赖; 安装完毕后，执行 npm run build 进行构建; 在Chrome浏览器(下载功能只能在Chrome中使用，所以…)中打开index.html。 至此，你可以体验这个简单的Demo了。 像什么如果你觉得在你的机器上run很麻烦，或者你只是想看看长得怎么样。 在浏览器器中打开，是这个样子的： 我承认的确很简单，简单到显得简陋了！接下来你可以选左下角的选择文件按钮来选择任何一张图片，比如我选择了一张图片后: 任何被选中的图片都会被居中显示，宽高都会适应600*400的图片操作区域。现在，可以对图片进行操作了： 我们选择对图片的R、G、B、以及透明度进行调整，实时调整的效果将会在左侧的图片区域实时显示出来。 第四步，点击图片区下的按钮，就可以吧处理过的图片下载到本地了，我们打开下载后的图片和处理的图片进行对比，就像这样： 至此，我已经演示完了所有的功能。 不足如果你细心一点的话，你会发现这个Demo还有很多问题： 我们导入任何宽高的图片，其都会被自适应到框中，所以处理后的图片品质会下降。 保存图片只能在Chrome浏览器中进行，已测试在Firfox中无法使用这个功能。 右侧的工具栏在选择新图片后不会被初始化。 功能单一。 界面简陋 … 你需要注意的是如果你想学习React和canvas，那么我希望我的这个Demo会对你有所帮助，这里提几个需要注意的点，这些点也是我在开发过程中遇到的问题： 如何使用input file来选择一张图片并绘制到canvas中。 如何保存图片。 图片在React中绘制的时机。 如何使用redux进行数据管理，特别是如何使用带参数的action。 你所关注的。 未来这虽然是一个很简单的Demo，但是我会在此基础上进行继续跟进，现在能想到的是解决上面提到的不足，比如设置两种模式，处理图片品质下降的问题；兼容主流浏览器；增添新功能；修改工具栏的状态初始化的bug；以及其它我以后能够想到并且我能够实现的。 以及…我目前有想法开发一个可交互的视频编辑器，有兴趣的同学可以关注下咯！ 写到后面还有不到3个小时我就21岁了，想想前面走过的20年，尤其是上大学的三年来，感慨颇多。谢天谢地，就算无论如何，我都完好无损的度过了。接下来的一岁中，我将面临人生中一个个重大的转折点，实习、毕业、工作、走向社会。从小到大，我对我所有的事情做出选择，接下来，也不例外。我做好准备了，并且一直在准备着！ 共勉！ 新！5.28日 解决了再次选择图片工具栏初始化的问题； 工具栏的调节精度下沉到0.01； 修改页面细节。 现在看起来长这样！ 6.3日 同样的功能，不同的界面和实现方式，采用react但是去除redux使用state进行状态管理； 操作更加主流和人性化； 已知BUG，下载某些图片的时候可能会失败，暂不知原因。 新版地址：https://github.com/xiaomoer/picture-editor-with-canvas 看起来是这样的：还有这样： 加油！","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"初识 requestAnimationFrame","slug":"初识-requestAnimationFrame","date":"2017-05-12T10:22:39.000Z","updated":"2017-07-25T00:41:22.000Z","comments":true,"path":"2017/05/12/初识-requestAnimationFrame/","link":"","permalink":"http://yoursite.com/2017/05/12/初识-requestAnimationFrame/","excerpt":"","text":"事情的起因是这样的，前段时间面试的时候面试官问我会canvas不，作为一名未来的前端猿，我只有过一点了解，后来居然收到了offer，当然在闲暇之余是要学习一下canvas，并且在学习过程中首次接触到了本文的主角requestAnimationFrame。 web中实现动画老实说，如果有人问我如何在web开发中实现动画，我第一时间想到的就是使用定时器setTimeout()或者setTimeInterval()来实现。其实实现的方式远远不止这一种，在CSS3的时代，我们实现动画有了更多的选择，比如使用关键帧动画，使用transition，我们也可以在canvas上绘图来实现动画；当然，还有requestAnimationFrame。 使用setTimeout()/setInterval()实现的方式很简单，我前面有一篇文章就简要介绍了JS中的定时器。使用这种方式实现动画其实是有其性能瓶颈的，例如：1234function animation()&#123; // do something setTimeout(animation, 1000/60)&#125; 上面我们以60帧/秒的速度执行动画，但是如果浏览器不是60帧/秒，就会掉帧；并且由于JS单线程的特点，所有不能保证每一次执行回调都是1000/60毫秒；还有，当窗口处于非激活状态的时候，它同样可能会执行。 其实很好理解，作为定时器，setTimeout/setInterval并不是专门做动画的，存在各种各样的问题也是很好接受的，但是当我们认识到这种实现动画的方式的各种缺点时，我们也许会考虑另一种动画的实现方式，而requestAnimationFrame是一种更好的方案。 初识 requestAnimationFrame 当我们执行window.requestAnimationFrame(callback)的时候，浏览器会在下次重绘的时候执行回调函数，它会告诉浏览器马上就要执行动画了，而callback则是用于更新动画。 requestAnimationFrame使用起来很简单，通过递归不断来执行回调来更新画面从而让画面动起来，我们甚至不需为其指定动画执行的时间和帧率。其优点是：1）从名字上就可以看出这是一个专门用于实现动画的API，优化是自然少不了的；2）其如果处于非激活状态，会自动暂停执行，有效节省了CPU资源。 小实例我们在做动画的时候，有时希望背景移动起来，结合目前正在学习的canvas，我们可以很轻易的做到这点. 12345678910111213141516let j = 0;let image = document.querySelectorAll('img')[0];function moveBackground()&#123; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.translate(10, 0); ctx.drawImage(image, 0, 0); j++; if(j &lt; 20)&#123; requestAnimationFrame(moveBackground); &#125;&#125;let moveBtn = document.getElementById('move');moveBtn.onclick = function(e)&#123; e.preventDefault(); requestAnimationFrame(moveBackground);&#125; 上面我们点击button的时候，开始执行动画，通过不断的坐标变换和清除重绘，达到背景图片向右移的效果。 最后，请注意，不是所有浏览器都支持该方法，所以你可能需要一个polyfill，关于如何实现这个polyfill，网络上的资源比较多了，这里就不在赘述。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"实用的JavaScript技巧、经验总结","slug":"实用的JavaScript技巧、经验总结","date":"2017-04-21T06:00:42.000Z","updated":"2017-06-12T12:44:22.000Z","comments":true,"path":"2017/04/21/实用的JavaScript技巧、经验总结/","link":"","permalink":"http://yoursite.com/2017/04/21/实用的JavaScript技巧、经验总结/","excerpt":"","text":"避免给一个未申明变量赋值，因为这会直接创建一个全局变量。 总是使用 ‘===’ 而不是 ‘==’，’===’会直接比较，而’==’必要时会进行类型转换等造成错误。 使用typeof instanceof 应当小心。 1234typeof null // objectfunction A()&#123;&#125;new A() instanceof A // truenew A() instanceof Object // true arguments 对象转换成一个数组 12Array.ptototype.slice.call(arguments);Array.from(arguments) //ES6 验证一个参数是否是数组 1Array.prototype.toString.call(a) === '[object Array]' 取得一个数组中最大值与最小值 12Math.max.apply(Math, arr);Math.min.apply(Math, arr); 使用splice删除数组中某一个/一些元素，而不是使用delete，如果使用delete的话，相当于只是把原值变为undefined 使用for .. of来遍历数组，使用for .. in 要避免遍历到原型上面的可枚举属性，使用hasOwnProperty()来检测 不要扩展Object.prototype，因为这会给所有(?)对象增加属性/方法，从而产生很多意想不到的行为和错误！ 对于一个构造函数，总是使用 new进行构造函数调用，否则默认返回空(对象)。 arguments.callee() 可执行当前函数，不推荐使用。 认识 ‘+’运算符， 对于对象而言，会转换成字符串，对于其他运算符则会尝试转成数字。 在使用if语句是，如果需要在条件中赋值，需要加上括号：`javascriptif((x = y)){// do something}并且结果是否为真取决于y的真假。 判断一个数是否为NAN使用 x !== x,为true则该变量为NAN(NAN不等于自身)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"在Express中使用Cookie","slug":"在express中使用cookie","date":"2017-03-16T08:11:42.000Z","updated":"2017-03-20T13:21:42.000Z","comments":true,"path":"2017/03/16/在express中使用cookie/","link":"","permalink":"http://yoursite.com/2017/03/16/在express中使用cookie/","excerpt":"","text":"文章来自于我在express框架上使用cookie引发的一些问题，但在具体介绍cookie以及如何正确的使用cookie之前，我觉得我有必要说一说cookie到底是什么。 cookieCookie是服务器保存在浏览器中的一段小(一般而言size&lt;4KB)的文本信息，而浏览器每次想服务器发出请求，就会携带上这段信息。Cookie一般包含了key、value、到期时间、所属域名、所属路径等信息。 在浏览器中我们只需要使用document.cookie来得到当前页面所属的cookie。请注意，返回的cookie是以字符串形式存在的，不同的key-value之间通过’;’来分割，所以如果你想对齐进行进一步操作，需要相应的处理。 这里需要注意的是，document.cookie属性是可写的，这就意味着你可以手动添加cookie，使用document.cookie=&quot;name=value&quot;的形式。注意，这里是添加，而不产生覆盖。 好了，关于cookie的属性的具体含义和用法，大家可以自行去了解。 我的问题我在使用服务器端使用cookie的时候出现了问题，出现这样问题的原因很简单，首先我对cookie存在错误的理解，请务必注意，cookie是服务器发送给客户端，而客户端在发起请求的时候携带cookie而已。在正确认识cookie之后，并且成功的将cookie发送到浏览器过后，问题又来了，我在请求的时候，cookie却不能发送到服务端。我使用的是下面一段代码：12345678910fetch('/login?'+stringify_data, &#123; method: 'GET' &#125;).then(function(res) &#123; return res.json(); &#125;).then(function(json)&#123; console.log(json.status); &#125;).catch(function(err) &#123; console.log('oh ! error!') &#125;)&#125; 这里我使用了fetch API，在能够正确的发送请求的情况下，服务器无法读取到相应的cookie信息，同样在chrome开发者工具中查看请求头也发现请求并没有携带cookie信息。我想着一定是fetch API的问题，所以我赶快写了一个使用Ajax的请求，很显然，能够正确的发起携带cookie的请求。好吧，写到现在，我想的确是fetch API的问题了，阅读文档发现fetch API发送的请求默认是不带cookie的，必须手动设置(无论是出于什么样的考虑，但还是觉得坑)！好吧，问题迎刃而解，我们只需要在fetch函数第二个参数设置credentials: &#39;include&#39;就可以发送cookie了/无奈！ 在express中使用cookie在express中使用cookie是一件十分惬意的事情，因为如果你使用cookie-parser中间件的话，那么我们只需要使用res.cookie(name, value[,options])就可以设置cookie了，关于options相关的参数可以自行学习！ 如果想删除cookie，也很简单，使用res.clearCookie(name)就可以啦。 当然如果想获取请求头发过来的cookie，我们只需要使用req.cookies就可以了，这里返回的是一个JS对象，我们直接可以使用name来读取值，从而做进一步的操作。 在使用了cookie-parser中间件过后，在服务端操作cookie已经足够简单，并且cookie-parser不但提供了非签名使用的方式，还提供了签名的使用方式，具体使用是在使用中间件的时候添加一个secret，app.use(cookieParser(&#39;secret&#39;))即可，当然，在获取cookie的时候使用 req.signedCookies属性就好了。 好了，如果你不想使用cookie-parser，我们也能够通过req.headers.cookies(感到罪恶所以不推荐/无奈)访问到cookie，如果想写cookie的话，使用res.setHeader(name, value)(再次感到罪恶)或者res.writeHead(status[,options])就可以了… 尾巴一般情况下，文章末尾，我总会写一点鸡汤/无奈，这次也不例外。距离写上一篇博客已经过了很久了，起初有两篇想写的文章，一篇是在RN中使用Navigator，另外一篇则是介绍我自己正在学习的几种分类算法。可是当创建好文件准备开工时，我因为写一篇文章可能需要2-3个小时(我速度慢)或者是因为真的动笔写的时候反而觉得没什么要说的就放弃了。然后一段时间过后，或许是因为忙，或许是因为懒，或许是因为浮躁，就是没有去实践，没有去巩固，而把一切都抛之脑后，然后把前面学习到的忘得一干二净！ 嗯，这的确的真实的！仅此而已！ END","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Flex弹性布局","slug":"Flex弹性布局","date":"2017-02-22T08:09:48.000Z","updated":"2017-02-22T14:23:50.000Z","comments":true,"path":"2017/02/22/Flex弹性布局/","link":"","permalink":"http://yoursite.com/2017/02/22/Flex弹性布局/","excerpt":"","text":"说起布局，我脑子里一下就想到了DIV+CSS布局，毕竟曾经被那么多写着DIV+CSS网页开发的书籍洗过脑，然后到现在还不怎么会用这种大众的布局方式。当然了，其实页面还有其它的一些布局方式，比如表格布局，框架布局这样已经逐渐被淘汰的布局方式，也有今天的主角–一颗冉冉上升的新星，弹性盒子布局。 Flex是Flexible Box的简称，我们这里把其翻译为弹性布局，至于为什么不叫“灵活的盒子布局”。额，这个问题也许会在读完本篇文章找到答案。好吧，正式开始。 容器flex是display的一个属性，当然对于行内元素还有一个叫做flex-inline的属性，这里我们不多说，但是要注意的是，一旦对一个元素的display属性设为flex，那么它的子元素就不能使用“浮动(float)”这个神奇的属性，而这个元素将会一跃成为容器(container)，而其的子元素将会成为项目。好吧，先从容器说起。 一旦把一个元素的display属性设置成为’flex’，这个元素就成为一个容器，容器有几个比较重要的属性，学习和掌握这几个属性是学习弹性布局的关键。它们分别是： flex-direction: 决定子元素(项目)的排列方向。 justify-content: 指定子元素在主轴上的对齐方式。 flex-wrap: 指定多行显示以及显示形式。 align-items: 决定项目在交叉轴上的对齐方式。 align-content: 定义项目在多轴线上的对齐方式。 好吧，大概就是这几个了，我们注意到在上面解释的时候提到了主轴和交叉轴，这里我先简单解释一下：对于这个概念，我们可以很简单的在一个容器上画一个十字坐标轴，如果我们设置flex-direction为row(行)，那么横坐标就为主轴，纵坐标就是交叉轴，这里要注意坐标轴的指向，因为同样有一个属性为row-reverse，此时主轴的方向指向和设置为row的相反方向。 项目作为容器的子元素，项目同样有几个重要的属性： order: 控制项目的排列，默认为0，值越小则越靠前。 flex-grow: 用于定义Flex项目的放大比例，默认为0，即使存在剩余空间，也不放大。 flex-shrink: 用于定义Flex项目的缩小比例，默认为1，即空间不足，Flex项目将等比缩小。 align-self: 允许单个Flex项目有不同于其他Flex项目的对齐方式。 然后我并不会把每一个属性具体来讲，因为这样的文章在网络上的确太多了。我正在学习RN，所以在这里就写一个界面，其中的布局将会采用弹性布局，中途我会对布局进行简单的分析，以加深理解。当写到这里的时候我就开始布局这个简单的页面，然后到现在才布局好，时间用了那么长，感觉像是过了一年…好了，不多说了，最终的界面如下图所示。其实我也不知道自己写了啥，还是勉为其难的就叫其“登录页面”吧，现在我来分析一下这个页面哪些元素是容器和项目(当然都是项目啦)，又在什么地方使用了什么属性。 页面整体采用了弹性布局，所以从整体来看我们一定使用了flex-direction属性，并且其值是column，所以这里的主轴一定是Y轴并且是方向向上。并且我们能够观察到，页面上所有的元素都是居中的，我们于是想到了在交叉轴上的对齐方式是: align-items: ‘center’，而其主轴上的对齐方式则是默认的justify-content: ‘flex-start’。 接下来来看两个不明显的，页面上有两个输入框，每个输入框其实都是一个View组件包裹，那么在这个组件内部，我们仍然使用了弹性布局(竖轴为主轴)，为了让输入框上下居中，这里必须让justify-content: ‘center’；紧接着最后一行有两个按钮，这两个按钮同样在一个View组件中，并且这个View也是弹性布局，并且一定要设置flex-direction: ‘row’才能让这两个按钮排列在一行。我们同样可以给每个按钮赋予不同的order值，让其进行排序。 总结一下：我们是用弹性布局完成了一个基本页面的布局(虽然这真的很丑陋)，在这个简单的布局中我们使用到的属性并不多，但是的确比使用css+div布局来得更快，尤其是垂直上的居中，css是比较难以实现的。这里我们一共有四个容器，分别是最外层容器，每一个输入框外层容器，按钮组外层容器，当然，这里面所有的元素都能称为项目，这里就不在多说。 尾巴说了这么多，那么我对flex布局的态度到底是什么？一句话总结，学习它，了解它，使用它。弹性布局我在刚开始学习React的时候就有了解过，过了也快半年了吧，当时看着阮一峰老师的文章，感觉怎么都不明白，然后渐渐抛之脑后。直到学期开始，我开始学习RN，再一次接触到Flex布局，才想起来画一些时间去了解，然后试着使用，最后再让自己记忆下来。相比第一次我接触Flex布局，我做出了改变，而这种改变是在时间并不充裕的情况下，弥足珍贵的。希望自己能够加油，也希望和我有同样压力的同学加油！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"生成器","slug":"生成器","date":"2017-02-11T04:10:07.000Z","updated":"2017-02-14T04:15:56.000Z","comments":true,"path":"2017/02/11/生成器/","link":"","permalink":"http://yoursite.com/2017/02/11/生成器/","excerpt":"","text":"大家对于异步这个词想必都不陌生，看到异步我可能最先想到的就是使用回调，再者我会使用Promise，可是使用回调处理异步控制流是有缺陷的：第一，基于回调的异步方式实在不适合大脑对于任务的思考(这点我深有体会)；第二，存在控制反转的问题。而Promise链提供了我们以顺序的方式处理和表达异步流。而这篇文章的主角生成器(generator)也是一种顺序和看似同步的处理异步的方式，并且它比Promise更加优秀。 有关函数不知道大家有没有这样思考过，一个函数一旦执行，其是否能够中断，我也没有仔细想这个问题，并且当看到这个问题，我会经验判断函数在执行过程中不会中断。到底是否中断，我们先写一个例子：12345678910var a = 1;function foo()&#123; a++; bar(); console.log(a);&#125;function bar()&#123; a++;&#125;foo(); // 3 运行上面这个例子，最终的结果是3，这就意味着，当函数执行完a++后，函数foo从表面上来看被中断了，然后执行了bar函数，最后执行权交给foo，函数返回已经被修改的变量a的值。虽然通过上面的小例子，并且因为JS单线程的特性，我们似乎能够肯定JS是抢占式的，但实际情况是JS并不是抢占式的，虽然函数bar的执行打断了函数foo的执行，但这其实是一种“关联”(参考原型继承)。 初识生成器现在让我们来认识生成器表达式，同样是上面的例子：12345678910111213var a = 1;function *foo()&#123; a++; yield; console.log(a);&#125;function bar()&#123; a++; &#125;var iter = foo();iter.next();bar();iter.next(); // 3 分析一下：首先我们创建了一个生成器foo(注意*)，该函数里面多了一个yield，有过python经验的大概知道这是干什么的。然后创建了一个函数bar；再来看执行，这里var iter = foo()并没有执行生成器foo，而是构建了一个迭代器，然后使用next方法启动了迭代器foo，并且在碰到yield停止执行，此时已经执行了x++，然后执行函数bar，执行完后，x经过两轮自增，此时x的值为3；最后我们调用next方法，从上一次中断处继续执行，并且没有碰到yield表达式，一直执行到函数结束，打印变量x的值为3。 现在我们来回答什么是生成器，其是一个特殊的函数，在函数声明的时候函数名前面包含一个”*“，并且能够多次启动和暂停。好了，我认为仅此而已。 一些问题为了把生成器运用到异步流程控制中，我们还需要更深层次的了解生成器。 生成器仍然是一种函数既然说生成器其本质上还是一种函数，所以其仍然具备函数最基本的特性，能够传递参数，也能返回值。我们不妨写一个例子测试一下：123456789function *test(a, b)&#123; a++; yield; return a + b;&#125;var it = test(1,2);it.next();var res = it.next();console.log(res.value); // 4 其实生成器和普通函数的一个很大区别是在运行期间，它不会直接运行，而是创建了一个迭代器，然后每调用迭代器的next方法，便向下执行直到到碰到yield或者执行完成暂停。而我们注意到调用next方法返回的其实是一个对象，其包含一个value属性，如果生成器返回值的话，那么该属性的值就为生成器返回的值。总的来说，生成器的运行到目前为止完全是依托迭代器。 好了，继续。 继续来看例子：12345678910function *foo(a, b)&#123; a++; yield a; return a + b;&#125;var it = foo(1,2);var mid = it.next();console.log(mid.value); // 2var res = it.next();console.log(res.next); // 4 这个例子想表达的就是对于生成器而言，yield表达式总会返回一个值，而我们可以通过迭代器next方法生成的对象来得到。 继续来看一个更复杂的例子：123456789function *foo(a)&#123; var b = a + (yield 'ok return!'); return b;&#125;var it = foo(1);var res = it.next();console.log(res.value); // ok return!res = it.next(2);console.log(res.value); // 3 这个例子向我们展示了生成器是如何双向传递消息的，yield表达式可以发出消息响应next(…)的调用，而next(…)可以向暂停的yield表达式发送值。 多个迭代器一个生成器的多个实例可以并发执行，并且可以彼此交互。12345678910function *gen(a)&#123; var b = a + (yield) return b&#125;var it1 = gen(1);var it2 = gen(2);it1.next();var res = it1.next(3).value;it2.next();console.log(it2.next(res).value); // 6 这个例子想说明的是一个生成器的多个实例可以并发执行，并且是互不干扰的。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Prototype","slug":"Prototype","date":"2017-02-03T13:30:39.000Z","updated":"2017-02-09T09:04:46.000Z","comments":true,"path":"2017/02/03/Prototype/","link":"","permalink":"http://yoursite.com/2017/02/03/Prototype/","excerpt":"","text":"JS为了模拟面向对象“类”的实现，为了模拟类的复制行为，可能会使用一种叫做“混入”的方法，当然，这种方法和我们今天要说的原型并没有多大的关系。使用mixin的方式来模拟“类”的实现不常见，当然为了模拟”类“所付出的代价也会让我们得不偿失，JS中不并存在”类”，而是存在一种叫做原型的东西，请容我细细说来。 Prototype我们直接来讲文章的主角Prototype，其实JavaScript中每个对象都有一个叫做[[prototype]]的属性，这个属性就是对其他对象的一个引用。基本上所有的对象在初始化时[[prototype]]都会被赋予一个值，关于这个值是什么以及如何访问这个[[prototype]]属性，我会在后面提到。 还是先看一个例子：12345var obj = &#123; a: 1&#125;var obj2 = Object.create(obj)console.log(obj2.a); //1 上面的代码我们创建了一个对象obj，其包含一个属性a，我使用Object.create(obj)创建了一个新的对象，并把该对象的[[prototype]]属性赋值为obj，最后我们打印obj2中并没有显式声明的变量a，令人惊奇的是，我们成功的访问到了变量a，并且该变量的值为[[prototype]]属性引用对象obj的属性a的值！ 我想解释下为什么要对这段代码写这么详细的解释，因为对于大多数接触过JS的童鞋而言，原型已经是见怪不怪了，可是当初我学习JS的时候，脑子里完全没有原型的概念，直到有一天我慢慢开始懂得原型，那个时刻，我的心情就像现在写这段解释的时候这么激动! 看完上面这段代码和冗长的解释，即使不了解JS的童鞋也对原型有了一定的认识。在这里我想再说一下，[[prototype]]到底有什么用，其实很简单，当我们试图引用某个对象的时候，在底层其实调用的是一个GET方法，而这个方法首先会查找对象本身存在这个属性与否，如果不存在则通过[[prototype]]访问其原型对象，如果还是不存在的话，则访问原型的原型对象(别忘了原型对象也是普通对象)，知道找到或者达到尽头(Object.prototype)。这个道理很简单，如果你使用for…in循环遍历一个数组的话，也许你得到的结果除了数组成员，还包含一些其它成员(不信你试试看)，这些成员就来自原型对象，并且是可枚举的，而对于in关键字，也会查找原型链上面属性。 类在说类的时候，也许更恰当的是给类打上一个引号，因为JS中根本就不存在”类”，JavaScript中只存在对象，我们不使用“类”创建对象，更多时候我们直接创建对象。可有些时候，我们使用new关键字来初始化一个对象，我们甚至在ES6后开始使用class，extend等属于类的关键字，这貌似和我前面说的矛盾了…接着看一个例子：123456function A()&#123;&#125;console.log(A.prototype);// &#123;&#125;var a = new A();console.log(typeof a); // object 我们创建了一个函数A，并且这个函数有一个属性prototype，如果没记错的话，这是本篇文章第一次访问原型，然后我们使用new初始化了一个对象，有传统面向对象语言基础的同学就知道，这简直像极了“类”！我再次强调，JS中不存在类，而且此new非彼new，这里函数A在new关键字的作用下，新建了一个空白对象，并让其prototype指向的对象赋值给新建对象a的[[prototype]]属性(关联)，当然这里面还会做一些其它的工作，不过大体上就这样了，很简单吧！ 在JavaScript中，并不存在类的复制，我们不能创建一个类的多个实例，只能创建过个对象，只不过通过new这种方式创建的对象，其内部的[[prototype]]属性关联到同一个对象，这里所说的关联是建立一个联系，并不存在复制。 构造函数既然不存在类了，这构造函数听着也很别扭，我们暂且给它打个引号吧。上面我们在说“类”的时候，我们就用到了”构造函数”，函数A就是所谓的“构造函数”，其本质上就是一普通函数，是JS的一等公民，要说真要有什么区别，函数名首字母大写算吗？也许是吧。 再来写一个例子：12345function B() &#123;&#125;console.log(B.prototype);console.log(B.prototype.constructor === B);var b = new B();console.log(b.constructor === B); 我感觉我放了一个大招，突然让自己迷惑起来，这里我要说明的是，B.prototype和对象b有一个叫做constructor的属性，并且默认指向函数B。这个属性的名字会让我们对JS的误解加深，四级没过的都知道，constructor翻译过来可叫做“构造器”啊，那么既然B.prototype.constructor指向了B，我们还有什么理由不说B不是“构造函数”？讲到这里，我很无奈… 其实呢，JS中根本不存在什么“构造函数”，其就是普普通通的函数，只不过一旦加上new关键字，这个函数调用再也不是普通的函数调用，我们把它叫做“构造函数调用”。 这里不想再说下去了，写个复杂点的例子先：123456789function Student(name, city)&#123; this.name = name; this.city = city;&#125;Student.prototype.showInfo = function()&#123; console.log(`name: $&#123;this.name&#125;, from: $&#123;this.city&#125;`);&#125;var stu = new Student('limoer', 'Chongqing');stu.showInfo(); // name: limoer, from: Chongqing 这里有两个值得注意的地方，每个通过”构造函数调用”而生成的对象都存在两个属性name和city；我们给Student.prototype上添加了一个“方法”，这样所有的新建对象都关联了这个对象，可以引用这个“方法”，关于this的使用，这里就不在提了。 在说了这么多过后，我想把“构造函数”称为“关联函数”，因为所谓的“构造函数”其实并不存在，或者说是，我们并不知道一个函数在创建好后是否是“构造函数”，而如果我们把它叫做“关联函数”，因为它本质上做的工作包含了建立对象和其原型对象的关联，当然，这个叫法是不恰当的。 再来看看constructor属性，一般情况下，任何一个普通对象都存在一个constructor属性，其实这个属性并不是其本身就有，而是当引用该属性的时候，其可以在该对象的原型链中找到。现在我急切的想写一个例子来表明一个问题：1234function C()&#123;&#125;C.prototype = &#123;&#125;var c = new C();console.log(c.constructor === C); // false 我不啰嗦了直接看问题，这里对象c的constructor属性竟然指向的不是创建它的那个函数C，这也侧面印证了我上面说的话，通过构造函数调用创建的对象不直接持有属性constructor而是从其原型链中“继承”而来，所以当我们想写一段包含继承的代码时，如果还想用constructor属性，需要做必要的修正。123456function Main()&#123;&#125;function Sub()&#123; Main.call(this)&#125;Sub.prototype = Object.create(Main);Sub.prototype.constructor = Sub; 在结束“构造函数”讨论的时候，提醒一句，尽量不要使用constructor属性，要问原因？我想我已经不那么直观的在前面说出来了。 如何关联我在上面提到把“构造函数”叫做“关联函数”，这虽然是不恰当的，但也不是一无是处，因为使用new关键字的“构造函数调用”，其在创建一个对象过后，也把该对象的[[prototype]]属性关联到该函数的prototype上。当然，如何关联不止这一种方法，这里介绍一种使用更为普遍的方法，Object.create(proto)。 还是例子为先吧：1234567var obj = &#123; info: function()&#123; console.log('info'); &#125;&#125;var obj1 = Object.create(obj)obj1.info(); // info 这里我们使用字面量的直接形式创建了一个对象obj，该对象包含一个方法info，然后使用Object.create()创建了一个新的对象，并且该对象内部的[[prototype]]属性指向obj，概括点来说，该方法创建了一个对象，并把其关联到指定的对象。 Object.create()是ES5才引进的，在这里我实现一个polyfill代码作为本篇的结束：1234567if(!Object.create)&#123; Object.create = function(obj)&#123; function Foo()&#123;&#125; Foo.prototype = obj; return new Foo(); &#125;&#125; 当然，这个版本的polyfill代码无法做到更复杂的功能，而Object.create第二个参数可以指定要添加到新建属性的属性名、值等。 尾巴我们如果要访问一个并不存在的属性，在内部将会使用[[GET]]方法，并且查找该对象[[prototype]]所关联的对象，该关联实际上定义了一条“原型链”，在查找属性的时候会遍历整个“原型链”。 关联两个对象的最常用的两种方法是：（1）使用new关键字进行“构造函数调用”，创建一个新对象并进行关联；(2)使用Object.create()，创建新的对象，并时期和传入对象关联。 最后再次强调，JavaScript并不存在类，所有继承的实现完全是基于原型链，不存在复制。 注：到底前面所说的原型链的尽头到底在哪里呢？答案是Object.prototype，对于一般的原型链而言，其最终都指向了Object.prototype，这个对象包含了许多对象通用的方法，例如obj.toString()&amp;obj.valueOf()等。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"this","slug":"this","date":"2017-02-01T02:35:23.000Z","updated":"2017-02-09T09:09:16.000Z","comments":true,"path":"2017/02/01/this/","link":"","permalink":"http://yoursite.com/2017/02/01/this/","excerpt":"","text":"JavaScript中的this关键字一直都是学习JS的一个难题，我们往往不能准确的理解this在上下文中的含义，往往导致一些问题的发生。对于this关键字，我们需要知道的是：this即不指向函数自身也不指向函数的词法作用域，this在函数调用时被绑定，也就是说，它指向什么完全取决于函数在哪里被调用。 绑定规则在探讨具体的绑定规则时，我们先来看一个函数调用位置的例子： 123456789101112function foo() &#123; console.log('call foo'); bar();&#125;function bar() &#123; console.log('call bar'); baz();&#125;function baz() &#123; console.log('call baz');&#125;foo(); 我们声明了三个函数，相互嵌套。现在来寻找各个函数的调用位置，foo在全局作用域中被调用，bar的调用位置则是12345678910&gt; 下面来看看几种一般性的绑定规则#### 默认绑定看一个例子：```javascriptvar name = &apos;limoer&apos;;function showName()&#123; console.log(this.name);&#125;showName(); //limoer 这里12345678910111213#### 隐式绑定隐式绑定的规则是调用位置是否有上下文对象，即是否被某个对象拥有或者包含。来看一个例子：```javascriptfunction showName()&#123; return this.name&#125;var obj = &#123; name: &apos;limoer&apos;, msg: showName&#125;obj.msg(); // limoer 对于函数showName而言，其在obj对象中被引用，即函数此时引用有上下文的对象，此时使用隐式规则，this将被绑定到这个上下文对象，所以12345678910111213141516两点注意：（1）属性引用链只有或则说是最后以层才会影响调用位置，修改下上面的例子：```javascriptfunction showName()&#123; return this.name&#125;var obj = &#123; name: &apos;limoer&apos;, msg: showName&#125;var obj2 = &#123; name: &apos;lindo&apos;, obj: obj&#125;obj2.obj.msg(); //limoer （2）this的绑定与函数的调用位置息息相关，一个常见的问题就是被隐式绑定的函数会丢失绑定对象，即应用了默认绑定规则。12345678910var name = 'lindo';function showName() &#123; console.log(this.name);&#125;var obj = &#123; name: 'limoer', msg: showName&#125;var show = obj.msg;show(); // lindo 函数show虽然函数showName的一个引用，但是由于其指向的是函数的本身，此时bar是一个不带任何修饰的函数调用，应用了默认绑定规则。 显式绑定和隐式绑定相反，显式绑定是一种“强制性”手段，把this绑定到某个对象上，JavaScript提供了这样的函数,call()&amp;apply()，这两个函数是如何使用的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。1234567var obj = &#123; msg: 'inner'&#125;function showMsg()&#123; console.log(this.msg);&#125;showMsg.call(obj) call 和 apply方法的区别仅仅是参数上的问题，除了第一个参数外，apply可以使用数组来传入剩余参数，而call则是以多参数的形式写出来。除了call和apply以外，还有一个bind方法，它接收一个对象，返回绑定了该对象的这个函数，此种方法是硬绑定，也就意味着，绑定不可更改，这里不再多做介绍。 new 绑定这是最后一种绑定方式，即“构造函数绑定”。会在将new关键字的时候在阐述此种绑定。 小结如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 由new调用?绑定到新创建的对象。 由call或者apply(或者bind)调用?绑定到指定的对象。 由上下文对象调用?绑定到那个上下文对象。 默认:在严格模式下绑定到undefined，否则绑定到全局对象。一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定，你可以使用一个DMZ对象，比如ø = Object.create(null)，以保护全局对象。ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和ES6之前代码中的self = this机制一样。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"提升","slug":"提升","date":"2017-01-30T03:26:01.000Z","updated":"2017-01-30T06:21:04.000Z","comments":true,"path":"2017/01/30/提升/","link":"","permalink":"http://yoursite.com/2017/01/30/提升/","excerpt":"","text":"我们都知道对于任何声明在某个作用域内的变量，都将属于某个作用域。但是对于JS而言，变量的声明与作用域还存在一种微妙的联系，这种联系我们叫做提升。 首先来看一个例子：12345console.log(name); // undefinedvar name = 'limoer';age = 2;var age;console.log(age); // 2 这个例子很好的体现了提升，输出name的时候，由于变量的声明在输出语句之后，想当然的使用RHS查找，查找失败抛出错误。但实际情况却输出了undefined，这是因为对于变量name，其声明被提升了，但是赋值语句却没提前，所以输出undefined。而对于age变量，赋值在输出前，我们理所应当的认为前面的赋值会被覆盖，但是程序却出乎意料的输出了2，这同样是因为变量age的声明提升到了首部，然后再进行赋值，最后输出了结果2。 上面的例子可以改写成这样：123456var name;console.log(name);name = 'limoer';var age;age = 2;console.log(age); 其实，对于提升的讨论就是“先有蛋还是先有鸡”的讨论，通过上面的分析，显然我们可以得出“先有蛋（声明），后有鸡（赋值）”的结论。 继续看一个例子：12345678910foo(); // call foofunction foo()&#123; console.log('call foo'); console.log(a); var a = 1;&#125;bar(); // TypeErrorvar bar = function()&#123; console.log('call bar');&#125; 这个例子说明了三个问题：（1）函数声明存在提升；（2）函数表达式不存在提升；（3）每个作用域都会存在提升。这里我只想解释一下为什么上面运行bar() 抛出类型错误，由于变量声明存在提升，所以实际执行的是下面的代码：123var bar;bar();bar = function ()&#123;...&#125; 由于bar的提升，调用bar()的时候并没有发生赋值操作，此时bar为undefined，所以对undefined进行函数调用会抛出一个TypeError而不是ReferenceError。 那么问题来了，既然变量和函数声明都存在提升，那么当这两个同时出现的时候，谁的优先级更高呢？ 同样，写一个例子如下：12345678foo(); // call foo functionvar foo;function foo()&#123; console.log('call foo function');&#125;foo = function ()&#123; console.log('call foo expressions');&#125; 好了，我们得出的结论是：函数声明提升的优先级更高。 注意：这里尽管foo的声明在函数foo声明之前，但是由于存在这样的规则所以被当做重复声明被忽略了，但是如果是函数声明，照样可以覆盖前面的声明。 小结ES6引入的const和let关键字的一大特点就是使用这两个关键字声明的标识符不存在提升，这就意味着无法引用未声明的标识符，从而可以避免由提升带来的一些列问题。 对于var a = 1;这样常见的变量声明方式，我们应该把它想象成两个步骤：首先是在预编译阶段对变量a进行声明，接下来是执行阶段，对a进行赋值，而提升则是将所有的声明“移动”到作用域顶部的过程。加油！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS作用域浅析","slug":"JS作用域浅析","date":"2017-01-28T12:43:19.000Z","updated":"2017-01-28T13:37:22.000Z","comments":true,"path":"2017/01/28/JS作用域浅析/","link":"","permalink":"http://yoursite.com/2017/01/28/JS作用域浅析/","excerpt":"","text":"我们都知道，JS的作用域其实包含了一系列的气泡，这些气泡包含了标识符(函数和变量)的定义,而这些气泡相互嵌套并且整齐排列。而在JavaScript中，这种气泡指的是函数作用域和块级作用域。 函数作用域函数作用域是JS中最基本也是最常见的一种作用域。所谓函数作用域，指的是在函数声明的过程中产生的一个“气泡”，这个“气泡”可以包含标识符。 来看一个例子：123456789function foo()&#123; var a = 1; function bar()&#123; var b = 2; &#125;&#125;console.log(a); // 失败console.log(b); // 失败bar(); //失败 在上面的这段代码中，函数foo所形成的作用域包含了标识符变量a以及函数bar,而函数bar所形成的作用域包含了变量b。当然，全局作用域中也包含标识符函数foo。 当然，就像上面程序的运行结果一样，直接访问变量a，b，函数bar都将失败。因为在函数作用域中，其声明的变量和函数中能在其内部(包含嵌套的作用域)使用。 由于函数作用域的特性，将会带来很多优点，譬如函数作用域可以隐藏函数内部的实现(非常重要)，也可以避免变量在声明过程中产生的冲突以及覆盖。 块级作用域有Java学习经验的童鞋对块级作用域可谓是了解，然而在JS中，块级作用域可不是那么常见(至少是在ES6出现以前)。 在let和const关键字出现以前，如果想找到块作用域的影子，那么只有with和try…catch语句了。 with关键字是JS块作用域的一个典型，在该作用域的范围内声明的变量都只在with语句块中有效。 而块作用域的另一个应用则是在try…catch中，相信即使对JS不够了解的童鞋都知道异常处理，对于JS中的try…catch语句，在catch块中将会产生一个err对象，而这一个对象只能在catch块中才能使用。看下面一个例子：1234567891011function showName()&#123; console.log(name);&#125;try &#123; showName()&#125; catch (e) &#123; console.log(e);&#125; finally &#123; console.log('end');&#125;console.log(e); 上面的这个例子showName函数内部试图打印一个并不存在的变量name，这里将使用一个RHS查找，并且在失败后抛出一个引用错误，我们可以在catch捕获到这个错误对象，但是我们没法在全局作用域上使用这个错误对象。 好了，除了这两个使用块作用域的典型，在ES6标准中，还新增了let和const关键字来实现块作用域。这里简单介绍一下，对ES6感兴趣的的童鞋们可以点这里来进一步了解ES6。 let和const都是有别于var的另外两种声明方式，let用于声明变量，该变量将会被绑定在{…}中，也就是说使用let声明的变量具有块级作用域。使用let声明的变量不但具有块级作用域，同时变量也不会提升。而const则用于声明常量，同样具有块级作用域，并且也不存在提升。let可以很好的用于循环，防止变量对于环境的污染。 小结函数是JS中最常见的作用域，声明在函数内部的变量和函数将会被很好的隐藏起来，这是一种良好的设计原则。而在ES6中，块级作用域再次被人们所日常使用。块作用域到底是不是函数作用域的替代方案，我认为到目前为止，不是！我们应该自己选择使用何种作用域，如何结合使用这两种作用域，来创造更加可读和健壮的程序。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"词法作用域","slug":"词法作用域","date":"2017-01-27T06:54:05.000Z","updated":"2017-01-27T14:11:24.000Z","comments":true,"path":"2017/01/27/词法作用域/","link":"","permalink":"http://yoursite.com/2017/01/27/词法作用域/","excerpt":"","text":"作用域模式有两种，一种是词法作用域，另一种是动态作用域，JavaScript采用的是词法作用域。 大部分的编译器会在编译阶段把程序进行词法化，也就是会对源代码中的字符进行解析，并且赋予词语语义。简单来讲，词法作用域就是词法阶段的作用域，词法作用域是由你在写代码时讲变量和块写在哪里决定的，当词法分析器在处理代码时会保持作用域不变。 考虑下面的代码：1234567891011var name = 'limoer';function showNameAPI(name)&#123; var city = 'Chongqing'; function showCity()&#123; var cid = 'CN'; console.log(city + cid); &#125; showCity(); console.log(name);&#125;showNameAPI(name) 这个代码一共包含三个逐级嵌套的作用域，全局作用域中声明了变量name，全局函数showNameAPI,函数作用域中showNameAPI所创建的作用域，包含标识符city以及showCity，最后是showCity创建的作用域,包含了标识符cid。 作用域查找会在找到第一个匹配的标识符时停止。这里的查找是由内而外的，并且在多级嵌套的作用域内可以定义同名的标识符，但是会产生覆盖。因为作用域查找的规则就是找到第一个匹配的标识符后停止。 无论函数在哪里被调用，也无论其是怎么被调用的，其词法作用域只与其被声明的位置有关。 欺骗词法上面说到词法作用域是在是完全在书写代码是就已经决定，但是也可以通过下面的两种方式在运行时来改变词法作用域。 当然，不出意外的，这两种方式会是不那么讨人喜欢的eval()和with。 我们首先来回顾一下eval()，这个函数接收一个字符串作为参数，这个字符串好像是运行时写在这里的代码一样。这明显是一种词法欺骗，其假装是在书写期间就在那里，而在运行时修改词法作用域。但是引擎对此并不知情，所以其依旧照常按照词法作用域进行查找。看一个例子：123456var name = 'limoer';function showName(str)&#123; eval(str); console.log(name);&#125;showName(\"var name = 'lindo'\") // lindo eval(‘name=”lindo”‘)会被引擎误认为在书写时就在那里，由于执行了上面的语句，此时name的值已经被修改了，并且产生了覆盖，遮蔽了外部同名的变量name。 在默认的情况下，如果eval中所执行代码中存在一个或者多个申明，其就会对eval()所处的作用域进行修改。无论何情况，eval(..) 都可以在运行期修改书写期的词法作用域。 再来谈with关键字，我们都知道with关键字用于重复引用一个对象的多个属性的快捷方式，而不需要重复引用对象本身。看下面的代码：1234567891011121314var obj = &#123; name: 'limoer', age: 20, city: 'Chongqing'&#125;console.log(obj.name)console.log(obj.age)console.log(obj.city)// 重复with(obj)&#123; console.log(name); console.log(age); console.log(city);&#125; 上面的这段代码突出了with关键字优点，它可以简化我们的代码，但是我们这里谈的是with关键字的词法欺骗，看下面一个例子：12345678910111213141516function info(obj)&#123; with(obj)&#123; name = 'lindo' &#125;&#125;var p1 = &#123; name: 'limoer'&#125;var p2 = &#123; city: 'Jinan'&#125;info(p1)console.log(p1.name) // 'lindo'info(p2)console.log(p2.name) // undefinedconsole.log(name) //lindo! 上面的这个例子很好的展示了with关键字的词法欺骗，这里创建了两个对象p1和p2，并通过info函数执行with(obj){…}，这里进行了简单的LHS查找，并将新值赋给name属性。但是请注意，这里p2对象并不存在name属性，也不会创建name属性，所以p2.name为undefined；这里很好理解，但是为什么神奇的是竟然多出了一个全局变量name呢!？ 这里执行with(obj){…}的时候，执行的LHS查找，所以当查找不成功时自动隐式创建一个全局变量，如果这样考虑，那么出乎意料的name属性就不难理解了。 总结JavaScript拥有的是词法作用域，所谓的词法作用域就是在进行词法分析时的作用域，也就是说，JS的作用域在代码一旦书写完成就能确定(靠书写位置来确定)。词法作用域的理解很简单，但是我们还是需要注意使用eval()和with语句带来的词法欺骗的原因。也许有人会说，在运行时修改词法作用域有利于实现复杂的功能，又利于扩展，何乐而不为呢？可我们在前面提到，在进行编译的时候，JS引擎会对代码进行优化，而这个优化则是根据代码的词法作用域，预先确定变量和函数的位置，才能在执行过程中快速找到标识符。而eval()和with的出现则有可能打破这样的格局，因为引擎在词法分析阶段并不能知道传入的代码到底是什么，会对词法作用域造成怎样的影响。所以，一切优化都是徒劳的，因为在运行时谁都不能确定此时此法作用域到底是怎么样的，所以JS引擎并不会进行优化，导致代码运行缓慢，性能并不好。所以，尽量不要使用它们。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"理解作用域","slug":"理解作用域","date":"2017-01-27T05:49:20.000Z","updated":"2017-01-27T13:56:32.000Z","comments":true,"path":"2017/01/27/理解作用域/","link":"","permalink":"http://yoursite.com/2017/01/27/理解作用域/","excerpt":"","text":"JS作用域的问题是老生常谈的问题了，我们都知道JS是不存在块级作用域的(ES6以前，try…catch是一个例外)，可是仍然实际编程过程中由于对作用域的理解不够深刻，踩坑无数，苦不堪言，恰逢寒假，又到了充(wan)电(shuai)的时间，所以把学习的重点放在认识JS语言本身上面。参考了资料《你不知道的JavaScript》。 实例为先首先，我们以var a = 1;这一个语句为例，看看这个过程JS到底干了什么。 毫无疑问JS是一门编译型的语言，但它的编译不是提前编译的，编译过程一般发生在语句执行前几个微秒。并且其和其它典型的编译语言一样，编译的步骤是相似的。首先编译器会把语句进行分词，分成单个的代码块，这些代码块被称为词法单元；接下来编译器会把词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这棵树被称为”抽象语法树AST”；最后一步，代码生成，该过程会把AST转换成可执行代码(机器指令)。 当然，JS的编译过程不会如此简单，其也会包含性能优化等。但这些所有的工作都在执行前几个微秒的时间内完成，并且立即执行它。 在正式的开始了解作用域之前，我们首先认识一下代码在执行时所需要的工具。 引擎：负责代码编译到执行过程 编译器：负责词法分析和可执行代码的生成等 作用域：负责收集并维护由所有声明的标识符(变量)组成的一列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限 现在开始对var a = 1的执行进行分解： 首先编译器会把这段程序分成词法单元，并且构建AST，当遇到var a的时候，首选编译器会询问作用域，是否已经已经有一个同名的变量存在于这个作用域集合中，如果存在则忽略该语句，否则在该作用域申明一个变量，命名为a；接下来，编译器会为引擎生成可执行代码，用于处理a=1这个赋值操作，引擎会询问当前的作用域是否存在一个名字为a的变量，如果存在，则使用这个变量，否则继续操作。最终，如果找到变量a，则给其赋值为1，否则将抛出错误。 总结：在对变量赋值时会存在两个步骤：首先编译器会在作用域中生成一个变量；然后引擎在运行时查找该变量，如果存在就赋值，否则抛出错误。 作用域1.嵌套作用域：作用域嵌套这个概念是很好理解的，当一个块嵌套在另一个块或函数中的时候，就会发生作用域的嵌套。当在当前作用域无法找到某个变量的时候，引擎就会在外层的嵌套作用域中寻找，知道抵达到最外层作用域或者找到了该变量为止。 考虑以下代码：12345var a = 1;function add(b)&#123; console.log(a + b)&#125;add(2) // 3 对变量a的查找是无法在add函数内部完成的，所以引擎会向上层作用域中查找，并且在外层作用域中找到。 LHS &amp;&amp; RHS引擎查找变量时常用的两种查找方式，这里需要注意的，如果执行右侧查找，无法找到该变量则会抛出引用错误。而进行左侧查找的时候，如果不成功，则会自动的隐式创建一个全局变量(都是在非严格模式下) 小结简单来说，作用域就是一系列的规则，这套规则用于管理引擎如何在当前作用域以及嵌套的子域中根据标识(zhi)符名称进行变量的查找。 下一篇，将深入的学习词法作用域","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"我们的世界","slug":"我们的世界","date":"2017-01-26T13:40:17.000Z","updated":"2017-01-27T05:52:20.000Z","comments":true,"path":"2017/01/26/我们的世界/","link":"","permalink":"http://yoursite.com/2017/01/26/我们的世界/","excerpt":"","text":"最近看了一部叫做《我们的世界》的韩国剧情片，讲的是这样一个故事： 主人公李善被人孤立，没人愿意和她组队玩集体游戏，她总是最后一个被无奈选中，也不出意料的第一个被淘汰，然后孤苦伶仃的站在一旁，不知道是不是要离开。她在学期末结识了转校生韩智雅，不知道这是不是她结交的第一个朋友，但的确度过了一个快乐的假期。智雅父母离异，却在李善家中看到了温诺的家，于是心生情愫，逐渐远离李善，结交了新的朋友。从好朋友到最熟悉的陌生人，李善就这样在新学期开始，再次被孤立。而韩智雅为了不被大家孤立，不但选择装作不认识李善，反而和班上同学一起排挤她，这让李善儿感到很苦恼。父母的不知情以及后面的一系列的事，让她们两个的关系越来越糟糕。韩智雅成为班上的学霸，而李善也成为了以宝拉为首的小团体利用攻击智雅的工具。最终两人走上了互相伤害的道路，智雅说善儿的父亲是酒鬼，而李善儿反击，把自己知道的智雅撒谎的真相公之于众。最后的最后，一直被孤立的李善还是继续被孤立，而韩智雅也成为那个被孤立的人。故事的最后，班上又开始玩丢球游戏，这次大家不想和两个人玩游戏，李善率先被淘汰，站在一边，韩智雅被诬蔑，李善主动站出来为她说话，避免了僵持不下的尴尬和无助。最后两人站在场边，不时偷望对方。我不禁有这般假设，假如没有选择离开，如今又会怎样？可惜小孩子的思想太过复杂，捉摸不透。电影戛然而止，关于她们两个最终和好的画面留给观众去想。 好了，故事讲完了。李善儿和韩智雅最终还是被孤立，成为了校园冷暴力的受害者。回到现实，我也像她们俩一样，成了受害者，并且顺利的长大了。 故事是这样的过了这么多年，对小学和初中那段时光的记忆很微弱了。直到前些日子，小学群里面，有人发了一张毕业照照片，照片中的我站在人群的中央，探出一个脑袋，不注意真还发现不了这个瘦小的孩子。而到了快过年的时间，这个群就特别活跃，我却发现，我根本插不上一句话，好不容易找到一个机会发了一条消息，却被无视了，我开始回想，那段小学的日子里，我也经常这样被忽视，也许到现在，他们根本不记得了我了。 我开始回想上小学的那段时光。低年级的时候，我是班上再平常不过的，个子矮小，学习成绩一般，零花钱少，还特别闷。在我的印象中，那个时候我经常中午要去外婆家吃饭，来回的路上会有很多的孩子，但是没人愿意和我一起走，如果我走过去主动和他们说话他们就跑，或者打我。直到后来，我来回的路上终于有了一个伴，那是外婆村子里读小学的一个半傻子(我也不知道该怎么形容)，我们一起在小河沟捉鱼，玩弹珠，可也因为这样，其他孩子更不愿与我玩。那时候的我，却没有如电影里两个女孩子那样琢磨不透的小心思，只好选择沉默。 好吧，最终我还是有了第二个(第一个是外婆村子里的傻子)好朋友，在我三年级的时候，我和安静的同桌成为了好朋友，我们很多时候会在放学时候一起回家(貌似还不顺路)，开始的时候，我们都不怎么说话，可我发现一个人的字可以写得那么工整，一个人的画可以画得那么漂亮，我开始主动找她说话，后来我们两个人之间似乎有说不完的话，每到下课，我们才不会去和其他同学一样，逛零食店，打乒乓球，玩跳绳。可这段时间没过多久，我的第二个朋友一年后转校离开了。我又开始了被孤立的时光，知道逐渐的适应这样的生活。 这种情况直到小学六年级才得到转机，我的学习成绩也越来越好，我的一个亲戚成了我的班主任，他也很关照我。我虽然依然很闷，但是还是想逃离被孤立。为了融入坏孩子团体，我也开始变‘坏’，我开始在学校小卖店赊账，大部分都是请同学吃了零食；我开始和他们放学不回家跑到网吧去玩，这也是我最开始接触到网络的时候。可即便是这样，我仍然无法摆脱不了被孤立，我能够打很好的乒乓球但是没人愿意加我一个，我也能玩弹珠，但是又有人和我玩？ 后来，大家都升入了初中，整个初中我都是在极力的融入这个环境，总在坏孩子和好学生的角色切换，这样的生活我过了三年。初中毕业后，我只身一人去了一个陌生的学校读书，也就和当初的坏孩子军团失去了联系，也许他们也不记得了，那个曾经总是在帮他们跑腿和揽责(背锅？)的我，这个坏孩子。 我的那段故事讲到这个就要画上一个句号了，因为我在高中结识了最要好的几个朋友，我再也是那个被孤立的对象。虽然在不熟识我的人眼里，我仍然很闷，就像刺猬一样，让人不得接近，可现实中的我，不是这样😂 那么，我到底想说什么我相信在小时候的学生时代，被迫承受孤独的还有很多人。他们是多么渴望有个人成为他们的朋友，玩伴。可奈何无论怎么努力，却还是一再的被孤立。大概是因为差异，微小的差异让我们成为了受伤害的对象。也许是因为我矮小，抑或是我长得丑，家庭条件不好，甚至因为我成绩好…这些都成为了我们被排挤的理由。我们在任何时间段都会受到这样的伤害，成人学会了忍耐，而对于小孩子，他们很多就像李善和韩智雅一样，最终互相伤害。当我们还小时，因该是我们率真的时候，我们的小心思却伤害了我们。当然，这一切的一切，学校和家长并不知情，这样的伤害也许就会持续下去，伴我们成长。 小尾巴我是先看完简介的时候再看电影的，整个过程我心情很失落，我看到了我的小时候，我并没有被无尽的孤立的所吞噬，我也没有反抗去伤害他人，反而我适应了这样的生活，逐渐的我习惯了过一个人的生活。直到现在，当独处的时候，我会回想，如果如曾经厌倦了无尽的孤立选择伤害反抗，抑或是我本身就是孤立别人的’坏孩子’，如今我又怎样。奈何时间没有倒带，人生不会从头再来。","categories":[],"tags":[{"name":"心灵记事","slug":"心灵记事","permalink":"http://yoursite.com/tags/心灵记事/"}]},{"title":"React全家桶网络学习资源汇总","slug":"React全家桶学习资源汇总","date":"2016-12-12T10:44:20.000Z","updated":"2016-12-12T11:59:14.000Z","comments":true,"path":"2016/12/12/React全家桶学习资源汇总/","link":"","permalink":"http://yoursite.com/2016/12/12/React全家桶学习资源汇总/","excerpt":"","text":"前言不知不觉，学习React时间已经超过三个月了。虽然这几个月断断续续，也算把我所了解的React全家桶学习了一遍，虽然我现在还是什么都不会😂好了，接下来，我会把我学习过程中用到的一些网络资源都整理在这篇文章里面，分享给大家。 学习react之前学习react之前，你最好有js(ES6)的基础，下面是JS学习资料搜集汇总。两本来自于阮一峰大神的开源书籍：JavaScript标准参考教程这里ES6入门指南强烈推荐，看过实体书，ES6入门很实用来自廖雪峰的官方网站的JS教程特别适合快速入门和新手回顾 JavaScript Promise迷你书全面了解Promise的书籍深入理解JavaScript系列汤姆大叔翻译，比较全面，值得推荐 react学习需要明确的一点的是，学习react最好的方式是阅读官方文档，这里列出一些资源，可作为学习的参考和补充：react入门实例教程没错，还是来自于阮一峰大神Learn React &amp; Webpack by building the Hacker News front page强烈推荐，手把手教你构建一个前端页面react-组件生命周期详解当我很混淆的时候，就是看这篇博文弄懂的React入门：关于JSX语法虽然JSX很好理解，但是还是推荐一篇吧，比较详细了React入门来自则修网的视频教程，一共有两门教程，这一门非常适合入门react文档中文翻译版本，推荐结合英文文档使用 webpackwebpack作为一个打包工具，如今已经十分出色。一小时包教会 —— webpack 入门指南不敢保证一小时能不能教会，但是写得还是很详细，值得一看webpack中文文档(类似于官方文档，比较详细的介绍了webpack的方方面面)(http://webpackdoc.com/) flux &amp; reduxFlux 架构入门教程阮一峰大神目前专注于react啊，什么都有他Redux 入门教程还是阮一峰的Redux Tutorial 中文翻译适合没有耐性看完官方文档的同学Redux中文文档英文翻译版，适合英语基础较薄弱的同学观看,貌似还可以下载下来redux其他学习资源我fork的 mocha &amp; chai测试框架Mocha 实例教程不用我说来自哪里了吧官方文档最好的学习教程chai强大的断言库，学习途径目前只有中文文档 react单元测试 &amp; enzymeReact 测试入门教程点这里enzyme 是用于react单元测试的一个库，类jquery的风格，比官方那一套写起来顺手多了，推荐. react-router &amp; 其他React Router 是完整的 React 路由解决方案React-Router中文文档看这个就够了 immutable.js是一个数据不可变的一个库，据说结合React可以让性能提升十倍,学习的时候有了解过.Immutable 详解及 React 中实践官方文档 lodash 其实不属于react全家桶成员(虽然我觉得inmutable也不是),但是作为一个高性能和模块化的JS工具库，值得大家去了解和使用中文文档,未翻译完全版本 写在后面上面的资料和文档也许可以很容易就能通过baidu或者其他什么的得到，我算是列举了我学习时候参考的资料吧，不一定适合大家，也许有更适合入门的资料只是我没找到而已。上面列举的也并不是react全家桶的所有技术，包括css-module，覆盖率测试这些我也是刚刚才了解，并没有深入的使用，所以我这里就不列出了。在我看来，react发展到现在，已经不能说其只是一个前端框架的view层了，它是一个技术栈，一种解决方案，并且只有使用其全家桶才能发挥出其威力，作为一个前端初学者而言，这个过程并不会太痛苦，因为我们并没有对传统的web开发思维根深蒂固，所以如果你想学习react，不妨放下心中的顾虑，现在就开始。 学习react不难，但是真的想写好react太难了，angular也是，vue也是，所以不要轻易说你学会了它们。我们仅仅是轮子的使用者而已，可我真想哪天我也能成为造轮子的人，加油！","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"使用webpack+npm进行React开发","slug":"使用webpack-npm进行React开发","date":"2016-11-19T08:17:52.000Z","updated":"2017-11-04T14:24:24.000Z","comments":true,"path":"2016/11/19/使用webpack-npm进行React开发/","link":"","permalink":"http://yoursite.com/2016/11/19/使用webpack-npm进行React开发/","excerpt":"","text":"写在前面这一期的知识我早就想写了，因为在学习React之初，心里面就有很多疑问，当然其中一个就是：我能不能不把所有的Component写在一个文件中，当然后面没有关注这样的问题，直到前些日子学习Flux才重视起来，恰逢周六，在这里写一篇，关于如何使用webpack+npm进行React开发。 webpack–脚手架工具而已在这里我并不打算详细介绍webpack如何使用，webpack只是一个前端脚手架工具而已，在进行React开发的时候，我们只是使用babel转换ES6的代码而已，但是webpack也是一个好用而简单的打包工具，想了解更多关于webpack的知识，点击这里。好吧，正式开始吧！首先我们需要安装node 和 npm, 因为webpack也是依赖node的，安装好node和npm后我们就可以开始安装webpack了，首先安装webpack：1npm install -g webpack 当然这里你也可以不全局安装，使用npm init初始化一个package.json文件，使用npm install --save webpack安装。 这里我将会跳过使用命令进行打包，直接进到使用配置管理文件就好了，如果想更深层次的了解webpack，点击上面的介绍咯(真的很详细)。 首先介绍一下这个配置文件，默认命名为webpack.config.js，其是一个node的文件，就像如下的这个样子。12345678910111213141516171819 module.exports = &#123; entry: './base.jsx', output: &#123; filename: './output.js' &#125;, module: &#123; loaders:[ &#123; test: /\\.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel', query: &#123; presets: ['es2015','react'] &#125; &#125; ] &#125;&#125; 好吧，介绍一下上面的这个文件到底描述了些什么，首先我们输出了一个配置对象，entry定义了要引入的文件，当然如果需要引入多个文件的话可以使用一个数组。output顾名思义定义要输出的文件名，这里可以把它理解为打包好存放的文件。最后，下面的这个module属性用于定义加载器，比如我们需要使用babel来吧jsx转为普通的js代码，test属性表示给所有匹配的jsx执行解析，exclude表示将会不解析node模块和通过bower安装的模块。loader表示使用解析工具，query则表示的扩展参数，这里表示应用es6和react的解析规则。好了，对示例文件的简单介绍就告一段路，当然还有一个属性plugins，用于使用插件，有关插件的使用请移至官方文档。 搭建react的开发环境细心的童鞋可以发现了，上面我演示的配置文件就是一个用于开发react的基本配置文件。好吧，直接开始，首先安装react，12npm install --save reactnpm install --save react-dom 接着安装babel用于解析jsx和es6，1npm install --save babel-loader 最后安装一些解析规则123npm install babel-plugin-transform-es2015-arrow-functions --save-devnpm install babel-preset-es2015 --save-devnpm install babel-preset-react 到这里，我们就安装完了开发react所需要的模块了，好吧，直接进入最后一步，在这里我将写一个和小很小的例子 一个栗子1234567891011121314151617181920212223242526272829303132import React from 'react';import &#123;render&#125; from 'react-dom';class InputComp extends React.Component&#123; constructor(props)&#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123; value: '' &#125; &#125; handleChange(e)&#123; var newvalue = e.target.value.trim(); this.setState(&#123;value: newvalue&#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;input ref=\"name\" type=\"text\" defaultValue=&#123;this.props.tag&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;p&gt;&#123;this.state.value&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;InputComp.propTypes = &#123; tag: React.PropTypes.string.isRequired&#125;InputComp.defaultProps = &#123; tag: '输入点什么东西吧！'&#125;const tag = '请输入';render(&lt;InputComp /&gt;,document.getElementById('app')); 上面的小例子来源于react首页上面的一个例子，这里使用react的写法，对es6不是很了解的童鞋可以点这里,关于适用ES5开发react和使用es6开发有什么区别，可以看我的上一篇博客，这里就不做过多的介绍，接下来，使用webpack进行打包就好了，使用上面举例的config文件，运行命令webpack就可以了，然后将输出文件引入到html文件中就可以看到效果了，当然如果你不想每一次修改都运行一遍命令的话那就使用监听更新模式，运行1webpack --progress --watch 当你修改完文件后，其会监听到文件的改变而做出增量的修改打包（当然第一次还是得手动打包） 尾巴写到这里，这篇文章就算完了，当你一步步完成上面的步骤，你就搭建了一个十分简陋的React开发环境，这里所说的的是简陋，我并没有加载对css文件的打包，这里大家可以根据自己的需求添加不同的loader来完成。作为一个React的初学者，感觉React这一个体系是十分庞大的，庞大到学习React一个多月仍然觉得力不从心，作为一个大三孩纸，每天被上不完的专业课实验课所压着，抽出来学习的时间并不多，再有自身比较懒惰所以…好吧，不多说了，好好努力吧，毕竟路都是自己选的。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"使用ES6语法写React","slug":"使用ES6语法写React","date":"2016-11-15T11:30:52.000Z","updated":"2017-11-04T14:22:32.000Z","comments":true,"path":"2016/11/15/使用ES6语法写React/","link":"","permalink":"http://yoursite.com/2016/11/15/使用ES6语法写React/","excerpt":"","text":"写在前面 最近在学习Redux，不可避免使用npm + webpack的方式来写React Component，由于不是很熟悉ES6踩了很多坑，在这里作为笔记写下来，供以后回顾。 例子惯例，先写一个例子吧123456789101112131415161718192021222324252627282930 import React, &#123; Component &#125; from 'react'; import &#123; PropTypes &#125; from 'prop-types'; class InputComp extends Component&#123; constructor(props)&#123; super(props); this.state = &#123; name: '' &#125; &#125; handleChange = (e) =&gt;&#123; var newvalue = e.target.value.trim(); this.setState(&#123;[e.target.name]: newvalue&#125;) &#125; render() &#123; const &#123; value &#125; = this.state; return ( &lt;div&gt; &lt;input name=\"name\" type=\"text\" value=&#123;value&#125; defaultValue=&#123;this.props.tag&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;InputComp.propTypes = &#123; tag: PropTypes.string.isRequired&#125;InputComp.defaultProps = &#123; tag: '输入点什么东西吧！'&#125; 上面是使用ES6语法写的一个简单的Component，有过ES6基础的同学对class, ‘extends’关键字等不会陌生，简单来说，这算是js的语法糖了吧。组件是一个自定义的js对象，在es5中使用React.createClass();在es6中必须继承React.component。 上面的小例子没什么特别的，我们只需要注意两点就好了：对于props,我们不能使用getDefaultProps()来添加默认的props，在ES6中有一个属性defalutProps,同理属性校验器propTypes,我们也必须写在外面，内容都和以前一样。也可以把这两个属性都写在’类’里面，使用static关键字申明.对于state,我们不能使用getInitialState()来设置state的初始值，转而在构造器中使用state属性设置值即可。对于事件而言，this指向的是当前创建的Component对象，所以需要手动绑定。还有一些其他的差别，比如es6支持解构等好吧，简单的就写在这里了 好忙好忙，语言都没办法组织了!加油！","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"JS定时器知多少","slug":"JS定时器知多少","date":"2016-11-06T11:36:11.000Z","updated":"2016-11-06T12:22:46.000Z","comments":true,"path":"2016/11/06/JS定时器知多少/","link":"","permalink":"http://yoursite.com/2016/11/06/JS定时器知多少/","excerpt":"","text":"在JavaScript中，定时器是一个经常被误用且不被大家所熟识的特性。但在构建应用时其却非常有用。定时器提供了一种让一段代码在一定的时间之后运行的能力。由于JS的单线程特性，其同一时间只能执行一处代码，而定时器跳出了这一性质，以其特有的方式来执行代码。 在浏览器环境当中，window对象下有两组方法，setTimeOut()/clearTimeOut()以及setInterval()/clearInterval()分别用于设置定时器让其在一段时间后执行/让其停止和每隔一段时间就会执行一次/清除该定时器。比如下面的代码：123456setTimeOut(function()&#123; // do somethign&#125;, 1000);setInterval(function()&#123; // do this code every 1s&#125;, 1000); 上面的代码分别创建了一个一次执行定时器和循环执行的定时器，每隔一秒钟，function就会被执行一遍 咋一看，setInterval就像周期性执行setTimeout一样，但是他们有很多不同之处。举个栗子：123456setTimeOut(function repect()&#123; setTimeOut(repect, 100);&#125;, 100);setInterval(function()&#123; // do some thing&#125;, 100) 上面两段代码的功能几乎是一样的，但是实际上却不是。setTimeOut()代码中执行前一个回调结束后100毫秒甚至更多，才会执行下一个回调而setInterval()不一样，每隔100毫秒就会尝试执行，不会受到前面回调的影响。那为什么执行一个setTimeOut()执行回调的时间会更长呢？因为js单线程的特性，当计时时间到，回调函数会被放入执行队列排队，并且执行回调是需要时间的，所以执行时间只会大于设置的时间。setInterval()也一样，但有一点，由于其不关注前一个回调执行的情况，如果一直被延迟，那么setInterval()在可用后会无延迟执行。 好吧，写个栗子证明一下上面的结论：12345console.time('测试setTimeOut执行的时间')setTimeOut(function()&#123; console.timeEnd('测试setTimeOut执行的时间');&#125;,1000); 执行结果为：测试setTimeOut执行的时间: 1004.673ms 关于setInterval()的演示和清除定时器的演示这里就不做了。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"浅谈JS闭包","slug":"浅谈JS闭包","date":"2016-10-21T12:58:29.000Z","updated":"2017-01-27T05:59:20.000Z","comments":true,"path":"2016/10/21/浅谈JS闭包/","link":"","permalink":"http://yoursite.com/2016/10/21/浅谈JS闭包/","excerpt":"","text":"变量的作用域了解JS的人都知道，在ES6之前JavaScript中只有函数作用域和全局作用域，而没有块级作用域(try…catch是一个例外)。该怎么理解这句话呢？我们先来看一个例子: 1234for(var i=0; i&lt;5; i++)&#123; console.log(`i=$&#123;i&#125;`)&#125;console.log(i) // 4 当运行完一个for循环后，i=4。由于JS中不存在块级作用域，所以这里在for循环中申明的变量i是一个全局变量，因此可以在外部访问到。现在我们来看下一个例子：123456789function init()&#123; var name = 'limoer'; function sayHello()&#123; console.log(`hello $&#123;name&#125;`) &#125; sayHello();&#125;init(); // hello limoerconsole.log(name); // undefined 这里我们定义了一个函数，函数中申明了一个局部变量name，并且在函数内部定义了一个内部函数sayHello，这个函数只能在函数init内使用，然而sayHello并没有自己的局部变量，但是其可以访问到函数外部的变量，即其父级函数的name变量 通过上面的两个例子可以清楚的知道，变量的作用域完全是由它在源代码中的位置决定的，并且嵌套的函数也可以访问其外层作用域中的变量。 闭包闭包和变量的作用域息息相关。现在我们来修改上面的这个例子 123456789function init()&#123; var name = 'limoer'; function sayHello()&#123; console.log(`hello $&#123;name&#125;`) &#125; return sayHello&#125;var sayHelloFunc = init();sayHello(); // hello limoer 注意修改的地方，我们这次是直接返回这个内部函数，然后在外部执行这个函数。但是，通常来说，当函数一旦运行完成，其局部变量就不可用了，在这里是当执行了var sayHelloFunc = init();后name应该不可用了。但是实际运行情况是成功访问到了name这个属性。 原因是因为这里sayHelloFunc已经成为了一个闭包。它由两部分组成，返回的函数本身以及创建该函数的环境。而所谓的环境是由闭包在创建时其作用域内的变量组成的。对于上面的这个例子，这里的变量就是指的name 再看一个闭包的例子123456789function addSome(num)&#123; return function(y)&#123; console.log(num + y) &#125;&#125;var add10 = addSome(10);var add1 = addSome(1);add10(1); // 11add1(10); // 11 对于上面的这个例子，addSome()做为一个函数工厂产生了两个闭包，它们共享了函数的定义，但是却又保存了不同的环境。 闭包的应用通过上面的描述，知道闭包其实就是将函数和其作用环境相互关联起来，达到保存变量的目的。 把上面的例子稍微改一下，我们可以把它用到实践中123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"toBlue\"&gt;切换背景为蓝色&lt;/button&gt; &lt;button id=\"toYello\"&gt;切换背景为黄色&lt;/button&gt; &lt;button id=\"toGreen\"&gt;切换背景成绿色&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; function changeBgColorTo(type)&#123; return function()&#123; document.body.style.backgroundColor = type; &#125; &#125;; var toBlue = changeBgColorTo('blue'); var toYellow = changeBgColorTo('yellow'); var toGreen = changeBgColorTo('green'); document.getElementsById('toBlue').addEventListener('click', toBlue); document.getElementsById('toYellow').addEventListener('click', toYello); document.getElementsById('toGreen').addEventListener('click', toGreen); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的例子展示了如何使用闭包来定义公共函数，来减少代码的冗余。 一个常见的错误，使用闭包来解决直接贴代码吧：html: 1234&lt;p id=\"help\"&gt;Helpful notes will appear here&lt;/p&gt;&lt;p&gt;E-mail: &lt;input type=\"text\" id=\"email\" name=\"email\"&gt;&lt;/p&gt;&lt;p&gt;Name: &lt;input type=\"text\" id=\"name\" name=\"name\"&gt;&lt;/p&gt;&lt;p&gt;Age: &lt;input type=\"text\" id=\"age\" name=\"age\"&gt;&lt;/p&gt; js: 12345678910111213141516171819function showHelp(help) &#123; document.getElementById('help').innerHTML = help;&#125;function setupHelp() &#123; var helpText = [ &#123;'id': 'email', 'help': 'Your e-mail address'&#125;, &#123;'id': 'name', 'help': 'Your full name'&#125;, &#123;'id': 'age', 'help': 'Your age (you must be over 16)'&#125; ]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = function() &#123; showHelp(item.help); &#125; &#125;&#125;setupHelp(); 上面的代码是我们实际开发过程中非常常见的错误。我们使用循环来给每一个输入框绑定一个事件，从而实现当聚焦到不同的输入框是产生不同的输出。但是，上面的代码显然不能完成这样的工作，因为当循环完成后，此时item已经指向了helpText的最后一项，而给onfocus绑定的是一个匿名函数，当聚焦到某一个输入框时，执行showHelp(item.help)而item早已是helpText中的最后一项了，所以造成了错误. 知道错误后，我们就知道改怎样修改了。我们需要保存运行时的环境，返回一个闭包。 12345678910111213141516function setupHelp() &#123; var helpText = [ &#123;'id': 'email', 'help': 'Your e-mail address'&#125;, &#123;'id': 'name', 'help': 'Your full name'&#125;, &#123;'id': 'age', 'help': 'Your age (you must be over 16)'&#125; ]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = (function(help) &#123; return function()&#123; showHelp(help) &#125; &#125;)(item.help); &#125;&#125; 好了，简单的对于闭包的介绍就到这里了！想更系统的学习JS点击这里","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"踩过React表单的坑后有感","slug":"踩过React表单的坑后有感","date":"2016-10-13T11:20:49.000Z","updated":"2016-10-13T13:28:02.000Z","comments":true,"path":"2016/10/13/踩过React表单的坑后有感/","link":"","permalink":"http://yoursite.com/2016/10/13/踩过React表单的坑后有感/","excerpt":"","text":"如题所示，最近捣鼓React表单踩坑了，才捣鼓没多少时日，心就变浮躁了，开始看不下去文档，也不谷歌百度直接开码，然后就是各种报错，越报错心越急越得不到解决心情越差，好不容易静下心来搜集资料准备搞定表单，这里先记下来，以备不时只需！ 踩过的坑…直接开写吧： input标签忘记闭合导致报错 123456var SimpleComp = React.createClass(&#123; render()&#123; return &lt;input type=\"text\" placeholder=\"随便输入点什么吧！\"&gt; &#125;&#125;);ReactDOM.render(&lt;SimpleComp /&gt;, document.body) 运行上面的这段代码，发现并页面渲染异常，打开浏览器console一看，下面的出现了错误，并且是下面这样的: 清清楚楚明明白白，标签并没有闭合，并且直指9行行最后渲染出了问题，然后我就一直找一直找，没错误啊，可始终还是报错最后经过各种尝试才知道，input标签要强制闭合的，不然就会转换错误知道真相的我眼泪掉下来，原来是这么回事啊，平时html写得飞起，细节这些什么的，都没注意哎！再有，控制台上打印的异常和错误可千万别轻信，以前已经在这个被坑过了 受控与不受控 有过React基础的童鞋都知道，React内部通过props和state来传递属性和状态，其中属性经由组件外属性传入，作用于组件后无法改变state 产生于组件内部， 通过setState()来改变状态，每一次改变状态，组件将会被重绘对于表单来说，props和state用得都很频繁，所以在这里提及一下 先来看非受控组件吧，顾名思义就是组件的状态不受控制，从代码上体现出来的就是，一个input不含有value属性123456var NotControlComp = React.createClass(&#123; render() &#123; return &lt;input type=\"text\" defaultValue=&#123;this.props.placeholder&#125;/&gt; &#125;&#125;);ReactDOM.render(&lt;NotControlComp placeholder='随便输入点什么吧！' /&gt;, document.body) 上面的一段代码定义了一个非受控的input，接受用户的输入而改变状态注意：这里使用到的defaultValue属性作用类似于placeholder属性 好吧，事实上我们使用非受控组件的情况比较多，我们会监听input的onChange时间，通过state来更新状态下面是一个简单的获取用户输入的例子：12345678910111213141516171819202122var ExampleComp = React.createClass(&#123; getDefaultProps()&#123; return&#123;placeholder: '输入吧'&#125; &#125;, getInitialState()&#123; return&#123; val: '' &#125; &#125;, handleChange(e)&#123; this.setState(&#123;val: e.target.value&#125;) &#125;, render()&#123; return( &lt;div&gt; &lt;input type=\"text\" defaultValue=&#123;this.props.val&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;p&gt;你输入了：&#123;this.state.val&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;);ReactDOM.render(&lt;ExampleComp placeholder='随便输入点什么吧!' /&gt;, document.body) 那么受控组件就很显而易见了，受控的input定义了一个value属性，并且value部位null123456var ControlComp = React.createClass(&#123; render()&#123; return &lt;input type=\"text\" value=\"不要尝试修改这个值啦！\" /&gt; &#125;&#125;);ReactDOM.render(&lt;ControlComp /&gt;, document.getElementById('app')) 好了，最简单的受控组件就写好了，当你尝试去修改表单中的值的时候，发现根本无法修改这点明显和我们平时写html不一样，同样的input标签在html中就可以修改但是到了react中就没办法修改了，想过原因吗？官方文档中给出了答案： 不比HTML，React组件必须在任何时间点呈现视图的状态而不仅仅是在初始化的时候， 好好理解！ 其他 不要通过添加子节点的方式给&lt;textarea&gt;添加内容，应该使用defaultValue或者value属性,避免产生歧义，因为JSX本身就是javascript 你可以通过selected属性来选中一个下拉栏， 但是为了组件的可操作性，请使用value 或者 defaultValue来代替就像这样： 123456789101112var SelectComp = React.createClass(&#123; render()&#123; return( &lt;select value='B'&gt; &lt;option value='A'&gt;A&lt;/option&gt; &lt;option value='B'&gt;A&lt;/option&gt; &lt;option value='C'&gt;A&lt;/option&gt; &lt;/select&gt; ) &#125;&#125;);ReactDOM.render(&lt;SelectComp /&gt;, document.body) 想要非受控组件的话，就使用defaultValue属性好了 当然了，可以通过传入一个数组来达到多选的目的, 前提是给select添加multiple={true}就可以了 看到这里，也许有人心里还有疑问，受控的组件既然不能修改那到底该怎么用？对于这个问题，请看下面：123456789101112131415161718var ControlComp = React.createClass(&#123; getInitialState()&#123; return&#123;value: 0&#125; &#125;, handleClick(e)&#123; this.setState(&#123;value: this.state.value + 1&#125;) &#125;, render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.value&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;);ReactDOM.render(&lt;ControlComp /&gt;, document.body) 好了，我们添加了一个button来控制受控组件的值，当然还有很多方式，比如我们可以给受控组件添加一个onChange事件监听 好了，React表单的基本知识就说到这里，感谢那些曾经让我烦躁无比的坑！","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"在React中使用mixin","slug":"在React中使用mixin","date":"2016-10-12T11:31:58.000Z","updated":"2016-10-12T12:41:32.000Z","comments":true,"path":"2016/10/12/在React中使用mixin/","link":"","permalink":"http://yoursite.com/2016/10/12/在React中使用mixin/","excerpt":"","text":"mixin到底为何方神圣？mixin被理解为‘混入’的意思，我们知道，如果你经常使用某一段相同的代码的时候，你会把它进行抽象，封装成类或者function，‘混入’也一样，它可以解决代码段重复的问题。 jade中的Mixins jade(pug)是一个高性能的模版引擎，它使用javascript实现，并提供给Node使用.我在使用Jade模版引擎接触到了Mixin, 下面给出一个例子理解下 12345678910mixin box(styles) .conponent -each style in styles .squire -var x = styles.indexOf(style) + 1; a(href='/users/' + x + '/list') #&#123;style&#125; .container mixin(['lin', 'limoer']) .links mixin(['parents', 'classmates', 'others']) 你可以无视jade的语法，如果你想学习jade，点这里 首先我使用mixin 关键字申明了一个带参数mixin结构，然后依据传入的参数生成了很多url这个mixin 结构可以在这个模版文件中使用，通过不同的参数来生成url从上面可以看出，mixin的确可以解决代码重复的问题 React中的Mixin 首先来写一个例子 123456789101112131415161718192021var TimerComp = React.createClass(&#123; getInitialState: function() &#123; return &#123;secondsElapsed: 0&#125; &#125;, tick: function() &#123; this.stateState(&#123;secondsElapsed: this.state.secondsElapsed + 1&#125;) &#125;, componentDidMount: function() &#123; this.interval = setInterval(this.tick, 1000) &#125;, componentWillUnmount: function() &#123; clearInterval(this.interval) &#125;, render: function()&#123; return ( &lt;div&gt; &lt;p&gt;Seconds Elapse &#123;this.state.secondsElapsed&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;); 简单的说一下，这里定义了一个定时器组件，会随着时间的增加来自动计时但是一个应用需要多个计时器呢？我们第一时间想到了组件的嵌套，但是组件的嵌套不但会增加组件的复杂程度而且，想要修改计时器也是比较困难的好了，解决代码复用的问题，我们可以使用Mixin， 让其混入进其他组件就好了 码起，还是计时器的例子！ 12345678910111213141516var MixinTimerComp = React.createClass(&#123; mixins: [MixinInterval(1000)], getInitialState: function() &#123; return &#123;secondsElapsed: 0&#125; &#125;, onTick: function()&#123; this.setState(&#123;secondsElapsed: this.state.secondsElapsed + 1&#125;) &#125;, render: function()&#123; return ( &lt;div&gt; &lt;p&gt;Seconds Elapse &#123;this.state.secondsElapsed&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;); 这里我们使用了mixins属性，把自定义的MixinInterval对象混入了Timer组件 来看看MixinInterval的实现： 12345678910var MixinInterval: function(interval) &#123; return &#123; componentDidMount() &#123; this.__interval = setInterval(this.onTick, interval) &#125;, componentWillUnmount() &#123; clearInterval(this.__interval) &#125; &#125;&#125;; 就这样实现了一个最简单的问题，和最前面的例子做对比，我们发现，只是把组件中一些代码独立出来成为一个mixin对象但这样做无疑是解决了代码重用的问题，当我们想定义另一个计时器时候，我们只需混入这个mixin代码而不必关心混入的计时处理对象是怎么实现的 mixin 实现起来非常简单，React也支持多个mixin的混入(在mixins赋值为一个mixin对象数组)但有一个问题需要注意，在mixin中尝试覆盖state中定义的键的话，React会抛出错误 1234567891011React.createClass(&#123; mixins: [&#123; getInitialState()&#123; return &#123;cover: 1&#125; &#125; &#125;], getInitialState()&#123; return &#123;cover: 2&#125; &#125;&#125;)// 错误，尝试覆盖cover属性","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React学习之JSX","slug":"React学习之JSX","date":"2016-10-11T07:39:27.000Z","updated":"2017-02-01T02:37:14.000Z","comments":true,"path":"2016/10/11/React学习之JSX/","link":"","permalink":"http://yoursite.com/2016/10/11/React学习之JSX/","excerpt":"","text":"什么是JSX？ 简单点说，JSX是对javascript的扩展，语法类似于XML，但JSX不是一门新的语言，确切来说只是语法糖，每一个XML都会被响应的转换工具转换成纯的javascript代码。在使用React时，你没有必要使用JSX来构建组件，但是推荐使用JSX，因为这样可以让组件的结构和组件之间的关系看起来更清晰。 好了，开始使用JSX吧！ 首先我们分别使用JSX和纯js来渲染一个组件 123456789101112131415// 使用JSXReactDOM.render( &lt;div&gt; &lt;h2&gt;使用了JSX语法糖&lt;/h2&gt; &lt;/div&gt;, document.body)// 不使用jsxReactDOM.render( React.createElement('div', null, React.createElement('h1', null, '不使用jsx') ), document.body) html标签和React组件 ReactDOM.render()可以渲染html标签，也可以渲染React组件，但是这里有一些命名上的规范 html标签使用首字母小写的方式，但使用首字母大写也能够正常加载 12var renderDiv = &lt;div&gt;这是一个标签&lt;/div&gt;ReactDOM.render(renderDiv, document.body) React组件使用首字母大写的方式 123456var RenderComp = React.createClass(&#123; render: function()&#123; return: &lt;div&gt;这是一个组件&lt;/div&gt; &#125;&#125;);ReactDOM.render(&lt;RenderComp /&gt;, document.body) 经过测试，发现如果使用首字母小写的方式，将不会正常渲染组件，也不会报错, 当然你也可以这样写: 1234567var RenderComp = React.createClass(&#123; render: function()&#123; return: &lt;div&gt;这是一个组件&lt;/div&gt; &#125;&#125;);var renderComp = &lt;RenderComp /&gt;ReactDOM.render(renderComp, document.body) js表达式 当我们想要在React中使用js变量或者是表达式时候,使用{}来进行包裹，不能够出现””,否则会被当作字符串。 1234567891011121314151617var SampleComp = React.createClass(&#123; getInitialState: function()&#123; return &#123; iscls: false; &#125; &#125;, render: function()&#123; return ( // 表达式 &lt;div className=&#123;this.state.iscls ? 'cls' : 'no_cls'&#125;&gt; // 变量 &lt;h2&gt;&#123;this.props.msg&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;);ReactDOM.render(&lt;SampleComp msg='学习搬砖中...' /&gt;, document.body) 这里提示一下，在JSX中，标签的class和for属性分别使用className和htmlFor代替了 其它 在给标签添加style属性的时候，应该这样写: 1style=&#123;&#123;display: 'none'&#125;&#125; 也可以把要应用的样式赋值给一个变量，再使用变量 12345var style = &#123; color: red, display: none&#125;;&lt;div style=&#123;style&#125;&gt;&lt;/div&gt; HTML转义，为了防止XSS攻击，React默认是使用转义的,所以当你想使用一些富文本这里就必须注意为了不让其转义，我们可以这样写： 123456var mesg = '&lt;h2&gt;这里的字体大小是多少?&lt;/h2&gt;'ReactDOM.render( &lt;div dangerouslySetInnerHTML=&#123;&#123;__html: mesg&#125;&#125;&gt; &lt;/div&gt;, document.body) 总结 刚开始学习React的时候对JSX是生畏的，以为会很难理解。当慢慢的接触React，踩过一些小坑，发现使用JSX是那么好掌握, 它仅仅是语法糖而已，并且转换的规则也很简单","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"写在正式学习React之前","slug":"写在正式学习React之前","date":"2016-10-10T10:35:22.000Z","updated":"2016-10-11T09:36:14.000Z","comments":true,"path":"2016/10/10/写在正式学习React之前/","link":"","permalink":"http://yoursite.com/2016/10/10/写在正式学习React之前/","excerpt":"","text":"如果你还不知道大名鼎鼎的ReactJS, 先去这里看看吧 在使用过了诸如BootStrap, Foundation这类的前端框架后，在初识React就被其虚拟DOM和组件化的开发深深的吸引。然后在接下来的几天，我慢慢的对React产生的恐惧，模式转变得太快，让我很不舒服。然后又经过几天玩坏了，我才返现React简直是一股清流，开始爱上它了！ 好了，开始使用React吧！ 安装React请先安装Node和npm 使用React之前，先来安装一下bower吧 1$ npm install -g bower 安装bower后我们来正式的进入React的学习中来 新建一个目录 1$ mkdir proj 使用以下命令来安装React 1$ bower install react 安装完后我们在proj目录下会看见一个bower_components目录,目录里面有一个React目录，ok！ 1$ touch index.html 使用文本编辑器打开index.html, 开始码起！ 第一个React helloworld 引入react.js和react-dom.js（在head,或者body中引入都可以，但是必须在我们开写地方的上面） 就像这样 接着申明一个script标签 1&lt;script type=\"text/babel\"&gt;&lt;/script&gt; 注意这里的type是text/babel 12345678910var HelloWorldComponent = React.createClass(&#123; render: function()&#123; return ( &lt;div id=\"app\"&gt; &lt;h1&gt;开始学习使用工具搬砖啦！&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;);ReactDOM.render(&lt;HelloWorldComponent /&gt;, document.body) 好了，不出意外的话，我们将会在浏览器中看到 好啦，我们的第一个react组件算是开发完成了，这里讲一讲我们到底做了什么首先我们使用了JSX语法，有关JSX的知识会单独的加深了解,但是最基本的规则就是，遇到{}解析成js，遇到‘&lt;’解析成html然后使用了React提供的createClass来创建一个组件类，类名一定要大写，实现了其中一个必须要实现的render方法，返回一个h1标签最后使用ReactDOM.render()渲染到body中去搞定","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]}]}