<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[使用Webpack DllPlugin]]></title>
      <url>http://yoursite.com/2019/01/06/webpack-dllplugin/</url>
      <content type="html"><![CDATA[<h2 id="DllPlugin-简易使用指南"><a href="#DllPlugin-简易使用指南" class="headerlink" title="DllPlugin 简易使用指南"></a>DllPlugin 简易使用指南</h2><ol>
<li>创建<code>webpack.dll.config.js</code> 用于对特定的模块打包成dll</li>
<li><code>webpack --config webpack.dll.config.js</code> 生成dll以及其描述文件</li>
<li>在<code>webpack.common.config.js</code>中使用DllReferencePlugin引入打包好的dll文件。</li>
<li>打包。此时遇到相应的模块时直接引入而不会重新打包。</li>
</ol>
<h3 id="创建webpack-dll-config-js"><a href="#创建webpack-dll-config-js" class="headerlink" title="创建webpack.dll.config.js"></a>创建<code>webpack.dll.config.js</code></h3><blockquote>
<p>这里以分别打包<code>moment</code>和<code>lodash</code>为例</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    lodash: [<span class="string">'lodash'</span>],</span><br><span class="line">    moment: [<span class="string">'moment'</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.dll.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: config.entry,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'/static/dll'</span>),</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    library: <span class="string">'[name]_library'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'/static/dll'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">      name: <span class="string">'[name]_library'</span>,</span><br><span class="line">      context: __dirname,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>推荐把入口配置信息写在单独文件中，易于维护。</li>
<li>DllPlugin类接受一个配置对象，该对象有三个属性：<code>context</code>(绝对路径), manifest文件中请求上下文；<code>name</code>,暴露的dll函数名；<code>path</code>：manifest文件存放的位置(绝对路径)。</li>
</ol>
<h3 id="使用DllReferencePlugin"><a href="#使用DllReferencePlugin" class="headerlink" title="使用DllReferencePlugin"></a>使用DllReferencePlugin</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.config.js</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ... <span class="comment">// 省略其它配置</span></span><br><span class="line">  plugins: [</span><br><span class="line">    ...Object.keys(dllConfig.entry).map(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="keyword">new</span> <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">`./static/dll/<span class="subst">$&#123;name&#125;</span>-manifest.json`</span>),</span><br><span class="line">    &#125;))</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DllReferencePlugin 接受一个对象用于初始化</p>
</blockquote>
<ol>
<li>context: manifest的上下文(绝对路径)，需和DllPlugin中的context一致</li>
<li>manifest: manifest文件，使用require引入或指定绝对路径</li>
</ol>
<p>可选参数：</p>
<ol>
<li>content：模块id的映射，默认为 manifest.content</li>
<li>name: dll文件的名称，默认为 manifest.name</li>
<li>scope: dll 内容前缀</li>
<li>sourceType: dll如何暴露的？amd commonjs2 …</li>
</ol>
<p>scope: ‘abc’， 则该dll中的xyz文件可以通过require(‘abc/xyz’)来引用<br>例如在一个dll中打包了<code>lodash</code>和<code>axios</code>两个库，并且指定了<code>{scope: &#39;lib&#39;}</code>，则在需要使用axios的时候使用<code>require(&#39;lib/axios&#39;)</code>即可。</p>
<h3 id="测试1：把echarts，windui，react及其周边分别抽取成dll文件。"><a href="#测试1：把echarts，windui，react及其周边分别抽取成dll文件。" class="headerlink" title="测试1：把echarts，windui，react及其周边分别抽取成dll文件。"></a>测试1：把<code>echarts</code>，<code>windui</code>，<code>react</code>及其周边分别抽取成dll文件。</h3><p>抽取的dll文件大小分别为：753KB 1603KB，385KB。</p>
<table>
<thead>
<tr>
<th style="text-align:left">构建方式</th>
<th style="text-align:right">平均构建时间</th>
<th style="text-align:right">包大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">普通</td>
<td style="text-align:right">97s</td>
<td style="text-align:right">4.1MB</td>
</tr>
<tr>
<td style="text-align:left">使用Dll</td>
<td style="text-align:right">71s</td>
<td style="text-align:right">2.6MB</td>
</tr>
<tr>
<td style="text-align:left">dll文件</td>
<td style="text-align:right">24s</td>
<td style="text-align:right">2.7MB</td>
</tr>
</tbody>
</table>
<blockquote>
<p>经过对比发现，由于无法使用按需加载，所以整个<code>windui</code>打包的大小差不多为1.6MB，而普通的打包方式<code>windui</code>的大小仅为365KB。</p>
</blockquote>
<blockquote>
<p>在使用<code>windui</code>链接库后生成的打包，发现vendors模块中仍然含有<code>windui</code>，大小为<code>330KB</code>，仅<code>windui</code>中的<code>node_modules</code>文件夹下的<code>rc-trigger</code>和<code>rc-dropdown</code>被重用，因此这里可能重复打包了。</p>
</blockquote>
<blockquote>
<p><code>windui</code>中依赖的<code>rc-*</code>部分模块仍然被打包。</p>
</blockquote>
<h3 id="方式二-仅对react相关模块和echarts进行打包"><a href="#方式二-仅对react相关模块和echarts进行打包" class="headerlink" title="方式二 仅对react相关模块和echarts进行打包"></a>方式二 仅对<code>react</code>相关模块和<code>echarts</code>进行打包</h3><p>抽取的两个dll文件的大小为393KB 769KB</p>
<table>
<thead>
<tr>
<th style="text-align:left">构建方式</th>
<th style="text-align:right">平均构建时间</th>
<th style="text-align:right">包大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">普通</td>
<td style="text-align:right">97s</td>
<td style="text-align:right">4.1MB</td>
</tr>
<tr>
<td style="text-align:left">使用DLL</td>
<td style="text-align:right">77s</td>
<td style="text-align:right">3.08MB</td>
</tr>
<tr>
<td style="text-align:left">dll</td>
<td style="text-align:right">11s</td>
<td style="text-align:right">1.16MB</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>windui</code>的大小基本不变，而<code>windui</code>依赖的<code>rc-*</code>系列组件基本没被打包。</p>
</blockquote>
<blockquote>
<p><code>vendors</code>模块从<em>0.61MB</em>到<em>1.67MB</em></p>
</blockquote>
<h3 id="使用html-webpack-include-assets-plugin-把dll注入到index-html"><a href="#使用html-webpack-include-assets-plugin-把dll注入到index-html" class="headerlink" title="使用html-webpack-include-assets-plugin 把dll注入到index.html"></a>使用<code>html-webpack-include-assets-plugin</code> 把dll注入到<code>index.html</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackIncludeAssetsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-include-assets-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> dllIntoHtml = <span class="keyword">new</span> HtmlWebpackIncludeAssetsPlugin(&#123;</span><br><span class="line">  assets: [<span class="string">'./static/dll/echarts.dll.js'</span>, <span class="string">'./static/dll/react.dll.js'</span>], <span class="comment">// 需要注入的dll文件路径</span></span><br><span class="line">  append: <span class="literal">false</span>, <span class="comment">// 是否尾注入？push ： unshift</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为先构建dll，再进行项目构建，在项目构建过程中会删除整个build目录，所以在构建完后再把<em>dll文件夹</em>拷贝进<em>build/static/</em>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><code>windui</code>进行dll打包后会因为无法按需加载而导致总大小偏高(且可能会产生冗余)；而不进行的话，包的总大小基本不变。</p>
</li>
<li><p>初始时需要加载的chunk从3个变为6个/5个</p>
</li>
</ol>
<h3 id="升级到webpack4-x"><a href="#升级到webpack4-x" class="headerlink" title="升级到webpack4.x"></a>升级到webpack4.x</h3><p>升级到webpak4.x后无论是<code>dll</code>还是最终生成块，都有小幅度的下降。与此同时，构建总时间(dll构建时间+项目build时间)略微减小。</p>
<h3 id="关于使用已存在的模块直接作为dll文件引入的可能性"><a href="#关于使用已存在的模块直接作为dll文件引入的可能性" class="headerlink" title="关于使用已存在的模块直接作为dll文件引入的可能性"></a>关于使用已存在的模块直接作为dll文件引入的可能性</h3><ol>
<li>目前无相关方面的实践。</li>
<li>DllPlugin抽取特定的模块构建dll文件后会生成一个<code>manifest</code>文件。该存储了各个模块的和公共模块的对应关系。<br>该文件会对已经打包成dll的模块中的文件进行描述，会给每个文件指定id，并且该<code>json</code>文件中的<code>name</code>属性对应dll的<code>library</code>。</li>
<li>在进行项目构建的时候，如需要打包某个模块，会在<code>manifest</code>文件中查找，如果该模块已经存在于dll中，依据manifest中的信息进行链接即可，不必重新打包。</li>
</ol>
<p>构建的dll块和使用<code>splitChunk</code>或者直接使用babel打包出来的块不一致。其依赖构建dll时指定的<code>library</code>等，而manifest文件也是和该块一一对应的。所以从理论上，使用其它方式提供dll文件由于构建方式和无法提供<code>manifest</code>文件，在构建过程中并不能被重用。</p>
<p>PS: 本片文章来自于我在团队内部分享的笔记，任何关于<code>webpack-dll-plugin</code>的理解和使用方式请在该插件的<a href="https://webpack.js.org/plugins/dll-plugin/" target="_blank" rel="noopener">Webpack介绍页查看</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的这一年]]></title>
      <url>http://yoursite.com/2018/12/31/this-year/</url>
      <content type="html"><![CDATA[<blockquote>
<p>好一个寒冷的假期！</p>
</blockquote>
<h3 id="最后一日"><a href="#最后一日" class="headerlink" title="最后一日"></a>最后一日</h3><blockquote>
<p>早上七点，闹钟开始吵个不停，我习惯性按下锁屏键，并快速蜷缩到被窝中，十分钟后，我再次重复这两个动作，直到不得不起。可是，虽然是周一，可毕竟是假期呢。这次我直接打开了闹钟，取消了激活状态，这下，可以好好睡一觉了。</p>
</blockquote>
<p>再次醒来的时候，已经快十一点了，湖人的比赛已经开打，也没了吃早饭的必要。我摸出手机，打开“掘金”，果然，技术社区唯一的小说也停更了；今天是周一啊，我似乎忘记了点什么啊。没错！“龙五”更了，看饿了看进度条99.1%，果然，老贼可不会因为今天是18年最后一天，就爆更的。剧情延续上一章，雪救下了阿巴斯，拯救了整个船上的人，而现在船员都知道雪是一个怪物了，要处决她。现在该由阿巴斯救雪了，阿巴斯夹带着言灵“因陀罗”登场，本章完。按照老贼的尿性，在阿巴斯救下雪这个过程中再水个三五章不无可能。哎，什么时候到个头呢！</p>
<p>好不容易起了床，洗漱完毕，打开电脑，开始了一天的“工作”。打开<em>NBA 2K Online2</em>，先晚上两把，发现我已经<code>11</code>连胜了；打开<strong>某鱼</strong>直播平台，看狗贼叔叔打两把“沙包战”；同性交友社区<code>GitHub</code>当然也不可少，看看<strong>前端娱乐圈</strong>，今天是否又有猛料。一切完毕，吃饭的点到了，刚刚好。</p>
<p>要是在上班，直接电梯直下十层，食堂的饭虽然不好吃又凉，但架不住便宜并且还少了奔波，所以单从填饱肚子的角度上来说，还行。而周末或是假期就不一样了，自己做饭是不可能的，那么除了点外卖就只好出去吃了，还是在这寒风刺骨的冬天。</p>
<p>穿好厚重的羽绒服，匆匆下了楼，今天我并不想图近就在附近随便吃点，而是要走过好几个路口去公司旁边的小店吃。虽然说实话，作为一个重庆人，从小色香味俱全的菜吃多了，反而觉得这边的什么都不好吃，并且还贵。可是呢，生活还得继续，所以在吃这方面，我能选的只有分量大/价格便宜，如果能够稍微好吃点，那可就是极好的了。</p>
<p>去公司的有两条街最近一直在施工，这不，路过红绿灯的时候，送外卖的小哥把车开进刚铺好的水泥路上，直接连人带车陷进去了。这么冷的天，弄得双腿都是未干的水泥，车也暂时开不了了，不知又会耽搁几个外卖，损失多少收入呢。前天晚上给母亲打电话，都很晚了父亲还在工地上没下班，并且他们基本上是没有休息日的，连节假日也不例外。在我心中，劳动人民都是伟大的，值得所有人的尊重。</p>
<p>刚开始写这篇文章的时候，我开着窗户，吹着寒风；可是不一会儿，就冻得受不了，只好打开空调，顿时暖风阵阵，僵住的双手得以解冻，恢复了往日的活力，然后电费飙升，令人心疼。</p>
<p>预计我会在写完文章过后玩两把<strong>吃鸡</strong>，到了饭点，我会叫上一顿<em>丰盛</em>的外卖，整个晚上，会找一些还没看过且是科幻/战争题材的电影看看，往后还有让人拍案叫绝的<strong>2K</strong>剁手环节。我的2018最后一天，会这样度过。</p>
<h3 id="毕业设计"><a href="#毕业设计" class="headerlink" title="毕业设计"></a>毕业设计</h3><blockquote>
<p>我已经不记得2018年的第一天，我具体干了什么。按时间来算，应该在准备期末答辩，然后开始享受学生时代的最后一个寒假？</p>
</blockquote>
<p>我记得春节刚过，我就来到了学校，那个时候软件园水池里还结着厚厚的冰，健身房的门还没开。我选的毕业设计是一款Web应用的开发，并且要求的是使用<em>Vue</em>开发，那个时候我对<em>Vue</em>的了解仅限于听过它的名字，仔细看完一遍官方文档，我就和导师的研究生们开始开发这个应用了。其实对于这个合作的项目，我多有吐槽，这本是一个为收集用户行为数据并进行进一步分析的应用，从应用本身的规划来说没什么问题，但问题就出在开发者本身上面，效率真的很低。每次9点到实验室结果研究生哥哥姐姐们还没到；约好时间进行接口对接，结果竟然在玩手游；一周下来，一个页面都没做好。鉴于此，我决定给我的导师摊牌，我可以协助完成整个应用的开发，但是对于我的毕业设计，我想自己开发。后来，我花了差不多一周时间完成了管理员端的开发，协助完成了接口开发，解决他们遇到的几乎所有问题，然后，脱离了这个合作项目。</p>
<p>其实，不应该只有吐槽。负责接口开发的学长才研一，跨专业考的软工，并且我们的后端使用的是<code>Spring Boot</code>,对于一个<code>Java</code>都怎么熟悉的人，能够在短时间之内完成任务，并且每次我们交流的时候他都在工作，就冲这股认真劲，给他点赞。另外一个就是负责开发应用的学姐了，在整个应用中，我和她接触最多。她对前端也不怎么了解，一个月下来也能做得有模有样，并且干起活来特别认真，一个特别热心肠的人。认真努力的人，值得我们尊重，并抱有敬意！</p>
<p>我的毕业设计脱胎于这个合作项目，是一款基于位置感知的任务众包平台。至于位置感知，就是对于绝大多数本地线下任务而言，推送给用于是基于位置的。此外，还构建了基于统一交易凭证的支付平台，内容审核，用户论坛等。从前端到接口，完全由我一个人开发。当然，直到最后毕业答辩，拿到优秀后，我仍然觉得这个应用还只是一个<code>demo</code>，只完成了所有设想的功能，页面也仅符合直男审美。</p>
<p>这是我的一次尝试，我设想着把想法付诸行动，并且在二十多个下午，我完全进入了编程状态，带上耳机，排除一切干扰，尽量把工作做好。而这样的体验，也只有15年在<strong>西电</strong>的一年时光。除此之外，对于在项目中用到的技术/框架，我加深了理解，我开始了解到单页应用服务端渲染，对web前端，以前可能只是开了一户小窗，而现在简直是开了一扇门。</p>
<h3 id="毕业季"><a href="#毕业季" class="headerlink" title="毕业季"></a>毕业季</h3><blockquote>
<p>在毕业前几天，我来到上海，租好房，开始迎接新的生活，在此之前，似乎还重要的事情等待去做。</p>
</blockquote>
<p>其实放在以前这件事是我想都不敢想的，这当然不是向喜欢的女孩子表白，更谈不上惊天动地。说到底，是我一个人的执念罢了。在22岁这个年纪，在开始一段全新生活之前，想要解开的心结。</p>
<p>而来到上海入职的前几天，我买了到福州的火车票，然后在那里呆了一天，见到了熟悉的陌生人和她所见的世界。回上海的那一天晚上，刚下过大雨，我从地铁站回公寓，听见小区里的蛙鸣，在这个寂静的夜里，我把什么都抛到了脑后，一切都在那一刻结束了。</p>
<p>不枉我耿耿于怀那么多年。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><blockquote>
<p>我准备好了工作，可是真到了那一天，我发现这不是我想要的。</p>
</blockquote>
<p>其实工作说得很多了，在很多<strong>周记</strong>里，我都提到这周完成什么样的工作。半年下来我的态度也在慢慢发生改变，我不得不去做自己不那么感兴趣的事，我对重复性劳动也没那么排斥。我能够利用工作中空余的时间片段，学到更多的知识。</p>
<p>其实自己对工作还是多有不满的，这种不满最初来自于对工作预期的落差，后又因为莫名其妙的转岗雪上加霜，现在因为重复性的劳动。除此之外，我接触到的同事，都非常<em>nice</em>；还有我们的小伙伴们，真的幸运能够和你们认识。</p>
<p>说说最近吧，部门新来了一名实习生，说是做后端的，但是由于我们项目缺人，所以就过来搞前端。大概工位离我很近的原因，我成了他指定导师。说是导师，其实也就是他遇到工作中的问题，我负责给他解答而已。小明才来了几天，一天趁晚饭时间，和他聊了不少。从在校，学习到面试基本都问了下。这位小明同学给我的印象就是，他仅仅是一张白纸而已，说是做后端，但一问到也说不出个所以然来；前端？抱歉也许以前做课程设计的时候可能写过<code>JSP</code>。所以说，我打心底里根本没想让他在短时间加入到这个项目中。这种他最主要的任务就是学习，从<code>JavaScript</code>语法开始；可刚学一天，他就给我说，学习没有目的性；刚过一周，他不但把<code>JavasScript</code>看得差不多了，<code>React</code>也加入了技能树。可是当我问的时候，我说React的生命周期有没有理解，<code>props</code>和<code>state</code>是怎么回事，<strong>命令式</strong>和<strong>声明式</strong>区分开了吗，他却说不出个一二。然后我又花很多时间给他讲。我想到我自己，从大二开始接触前端，很久也对<code>JS</code>不怎么理解，<code>React</code>差不多接触了一年多，写了好多<code>Demo</code>才能达到熟练使用用的程度，是我太笨了，还是他们他浮躁呢？所以，小明在下个迭代会加入我们，并且我给他安排了差不多我<code>1/3</code>的任务量，希望他能够快速成长吧。</p>
<p>关于我正在做的这个项目，经历了刀耕火种的时代，在开发过程中大家逐步填坑，并且为了解决开发过程中的痛点，开发了许多轮子；直到现在，我们打开发效率很高了。除了免不了成为配置工程师或者说流水线工人，我想说，我喜欢这个团队。希望项目早日完成/找到接盘侠，脱离苦海。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>生活也在<strong>周记</strong>中提到很多了，每天除了工作，下班了我基本上不会选择继续学习，可能会看看直播玩玩游戏。周末，多睡睡觉，打打篮球，看看电影放松放松。可不是不知为何，一到周一上班特别累。</p>
<p>本来想着来工作了继续健身，所以办了健身卡，每周4次的量，可是奈何健身房跑路这种奇葩的事情都能让我碰见，所以健身就搁置了。每周会花一些时间利用弹力绳保持下身材，所以到现在还没变成肥宅，可是看见日渐隆起的小腹，心中的担忧又来了~</p>
<h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>当初我憧憬魔都才选择来到这里工作，可是半年过去了，我丝毫没有归属感。除了同事和舍友，我基本不认识其它什么人；土著们操着一口你怎么也听不懂的方言；这里的物价水平也高到离谱，房租花费3000+，随便吃点什么也都得花费两倍于家乡甚至更高。最奇葩的是，隔壁的老太遇到过我两次，每次都问很久，结果他担心的是外来租客可能导致不安全的问题。虽然老太并没有恶意，但是我却心底拔凉拔凉的，我们是怀着梦想来到魔都，给魔都带来活力，我们买不起房，上下班骑<em>摩拜</em>，我们蜗居在10平米的小屋里却交着巨额房租，而现在他们不欢迎我们，担心我们打破他们的生活宁静，可那又有什么办法呢，就算是这样，生活还得继续不是吗？</p>
<p>所以我每次都认真回答老太的问题，并且打消老太这方面的顾虑。我喜欢魔都的生活节奏，但我看到每个月到手的工资和交完房租和生活必须花费后存下的钱，我想，我的未来不会在这里。至于下一站在哪里，何时到站，还没有计划，但可以预见的是，不会太久。</p>
<p>无论是到哪里，都要不虚此行，所以珍惜每个平常的一天，让自己能更进一步，变得更加优秀。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>还有不到7个小时就2019年了，在2018年我结束了学生时代，并且在22岁的年龄开始独挡一面。我以前说过，我从小到大几乎所有的决定都是我自己做的，而家人们总是尊重我的决定并且无条件的支持我。我想，什么时候他们能给我一个决定呢？好吧，就让它在2019年吧，说到做到！</p>
<p>愿好，明年见！</p>
]]></content>
      
        
        <tags>
            
            <tag> 心灵记事 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记？]]></title>
      <url>http://yoursite.com/2018/12/02/month-record-1202/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近总想着升级，比如玩2K阵容想升级，为了追剧想升级成为XX视频会员，为了得到更好的电竞体验，想升级我这台还不怎么过时的PC。当然，其实写周记也要升级了，升为月记可好？</p>
</blockquote>
<p>废话少说，不然电竞时间不够用啦。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><blockquote>
<p>项目在迭代后期照例改改bug划划水，所以空出来大把大把的时间，去掉刷微博看NBA，貌似还剩点时间片，所以还是装模做样，假装学习。</p>
</blockquote>
<ol>
<li>DOM Element 位置相关的属性</li>
</ol>
<p>这可是学了又忘，用到查资料的东西，总是会把这么些属性搞混。</p>
<p><code>client-*</code>: 不用说，这个还是记得住的。</p>
<p><code>scroll-*</code>：如果是描述形状的话(width&amp;height)，那就是元素(及padding)和溢出区的宽/高度，如果是位置，则表示向下/右滚动的距离。</p>
<p><code>offset-*</code>: 基于元素的<code>offsetParent</code>来进行形状和位置的计算。而<code>offsetParent</code>则表示距离元素最靠近的上层元素，且其<code>position</code>不为<code>static。如果是表示形状，则表示其水平/竖直方向上的高度(包含padding和border)；
如果表示位置，则表示距</code>offsetParent`的距离。</p>
<p>再认识一下<code>getBoundingClientRect()</code>用于获取盒模型的各种属性。<br>其中<code>x</code>,<code>y</code>表示其相对视口的距离，<code>width</code>，<code>height</code>等于(content+padding+border)。其余四个表示位置的属性分别表示据左上角/右下角的距离。</p>
<ol start="2">
<li>Node.js 核心模块回顾</li>
</ol>
<h4 id="net-用于创建TCP-Server和Client"><a href="#net-用于创建TCP-Server和Client" class="headerlink" title="net 用于创建TCP Server和Client."></a>net 用于创建TCP Server和Client.</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">   socket.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'data from client: '</span>, chunk.toString())</span><br><span class="line">   &#125;)</span><br><span class="line">   socket.write(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> client = net.createConnection(options)</span><br><span class="line">client.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'data from server: '</span>, chunk.toString())</span><br><span class="line">&#125;)</span><br><span class="line">client.send(<span class="string">'hello server'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="path-工具模块"><a href="#path-工具模块" class="headerlink" title="path 工具模块"></a>path 工具模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path.basename() 文件名</span><br><span class="line">path.dirname() 目录名</span><br><span class="line">path.extname 扩展名</span><br><span class="line">path.format(ooption) 将一个对象格式化为一个路径</span><br><span class="line">path.parse(path) <span class="comment">// 将一个路径解析成为一个路径对象</span></span><br><span class="line">path.join() <span class="comment">// 路径拼接</span></span><br><span class="line">path.resolve() <span class="comment">// 将路径片段拼处理成绝对路径</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>React 新特性学习</li>
</ol>
<blockquote>
<p>现在React存在的问题：包装地狱 庞大的组件 class组件</p>
</blockquote>
<p>hook：在function组件中使用到class组件中的很多特性</p>
<p><code>useState</code>为组件添加状态<br><code>useContent</code> 组件上下文<br><code>useEffect</code> 用于处理副作用</p>
<p>自定义hook</p>
<ol start="4">
<li>Webpack 4.x 之 code split</li>
</ol>
<p><code>webpack</code>默认的分割规则：</p>
<ul>
<li>新的代码块被共享，或是这些模块来自于<code>node_modules</code>文件夹</li>
<li>新的块压缩前大于30KB</li>
<li>按需加载的块，并行请求数小于等于5</li>
<li><p>初始加载的块，并行请求数小于等于3</p>
<p>默认情况下只会影响到按需加载模块，否则所有模块都会被打包到一起。</p>
<p>使用ES提案中的动态加载方案，<code>import()</code>，则会进行按需加载并单独打包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">   splitChunk: &#123;</span><br><span class="line">       chunks: <span class="string">'all|initial|async'</span></span><br><span class="line">       minSize: number,</span><br><span class="line">       minChunks: number,</span><br><span class="line">       maxAsyncRequests: number,</span><br><span class="line">       maxInitialRequests: number,</span><br><span class="line">       name: string,</span><br><span class="line">       cacheGroup: &#123;</span><br><span class="line">           test: regexp,</span><br><span class="line">           priority: number,</span><br><span class="line">           reUseExitintChunk: boolean,</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>指定chunks为<code>all|initial</code>会把<code>node_modules</code>中的模块分配到<code>vendors</code>缓存组，而重复至少两次的代码将会被打包到<code>default</code>缓存组。</p>
<p><code>initial</code>和<code>all</code>的区别是：当按需加载时，<code>initial</code>会分开打包，而<code>all</code>会统一打包。</p>
<p>提取特性的第三方库，可以直接新建一个缓存。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>最近在看的番《史莱姆》和《猪头少年》。</p>
<p>最近在看的剧《人不彪悍枉少年》。</p>
<p>值得一看的美剧《地球百子》系列。</p>
<p>特别推荐科幻美剧《无垠的太空》系列。</p>
<p>绝对不推荐的游戏《绝地求生》，打到自闭。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>一个多月没打篮球了。还记得刚来上海的时候，几乎每周都要去一次甚至闲的时候还会去两次，那个时候打球，特别容易迷失。如果被分到了很强的队伍，很容易隐身，超没存在感；如果分到了较弱的队，需要我进攻的时候，总是犹豫不绝；再加上时准不准的投射水平，突破终结能力实在一般，几乎每次打球都不会体验很好。</p>
<p>后来，既然做不好进攻，那就好好防守。毕竟身体还算强壮，下盘还很稳，又不惧对抗，最近几次打篮球在防守端还是不错的，对位同等身高的人，一点都不虚。防守好了，也带动了进攻，更加坚决的出手，往往可以收到意想不到的效果。</p>
<p>我差不多从上初中就开始打球，天赋平平，基本功又不够扎实，所以这么多年来基本上没什么长进。以前我十分乐意分享球，想成为一名组织者，可慢慢打着变成了神经刀。最近小伙伴叫我<em>罗伯森</em>，因为我的表现的确像。而我也乐意接受这样的角色，专注于自己擅长的事，成为一名好队友，一名好的<em>角色球员</em>。</p>
<p>我曾经打篮球打到自闭，一度放弃篮球。可是，我还是喜欢玩篮球游戏，也无时不刻关注NBA，我也有我喜欢的球星（偶像）。说到底，我还是喜欢篮球啊。我的生活可少不了篮球。</p>
<p>生活也是这样，作为一个平庸的人，也要努力找到自己的擅长的点。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记（十一月）]]></title>
      <url>http://yoursite.com/2018/11/03/week-record-1103/</url>
      <content type="html"><![CDATA[<h3 id="先说重点"><a href="#先说重点" class="headerlink" title="先说重点"></a>先说重点</h3><blockquote>
<p>差不多一个小时以前， <em>IG</em> <code>3-0</code>零封 <em>FNC</em>拿到了 <em>LPL</em>赛区的第一个世界冠军。我目睹了这一切，也曾今是一个<code>英雄联盟</code>玩家。还记得第一次弟弟带着我玩这款游戏，我抽到了一个<code>8</code>折优惠，花了<code>36</code>买了我的第一个英雄–<em>金克斯</em>，后来，买了第一款新年限定皮肤–<code>羊年限定金克斯</code>；也买过<code>源计划--艾希</code>。记得大学的第一个暑假高中同学小聚，网吧开黑玩一整夜也不会觉得累。记得最孤独无助的<code>2015</code>年，一个人在宿舍打出排位<code>36</code>连胜。记得几个月以前，快要离开大学之前，和同学们开黑的那段时光。老实说，当我忘记了出门要买装备，总是忘记交闪现，也经常线上漏刀的时候，<code>英雄联盟</code>早已不属于我了。可我总是会在忙得不可开交的一天后，打开直播看上两局；也全程关注了<code>S8</code>世界总决赛；也会打开网易云音乐，单曲循环<em>RISE</em>。到现在，我明白了，我还是喜欢<em>英雄联盟</em>这款游戏，即便我不怎么会亲自去玩了。</p>
</blockquote>
<p>我一直喜欢玩游戏，从最开始的<em>穿越火线</em>，再到陪伴了整个高三的<em>NBA 2KOL</em>，到<em>英雄联盟</em>，在到如今的<em>绝地求生</em>。因为只有在玩游戏的时候，才是那个没有任何防备的自我。</p>
<h3 id="工作-amp-学习"><a href="#工作-amp-学习" class="headerlink" title="工作&amp;学习"></a>工作&amp;学习</h3><p>为什么要把工作和学习放到一起来说呢？因为这一周真的很闲，临近项目结项，我最主要的工作，除了处理<code>BUG</code>，大把大把的时间就拿来学习了。</p>
<p>当然还是先将工作。我们的项目遇到了一个<code>BUG</code>，我们有一个嵌套层级很深的菜单，需要实现几个需求：</p>
<ol>
<li>当用户切换主菜单的时候自动滚动到顶部。</li>
<li>当弹出板块树或者是进行滚动的时候，始终保持用户选择的菜单项在可视区域内。</li>
<li>当用户刷新整个页面的时候，能够准确还原到上一次用户选择的菜单项中。</li>
</ol>
<p>我们最初并没有将<code>Menu</code>写成一个单独的组件，而是把它放在了<code>DataReport</code>中，并且只是用了<code>scrollIntoViewIfNeeded</code>来让选中的菜单项滚动到可视区域，因为在切换菜单是默认会选中顶部第一项的，所以不需要加任何代码就可以实现滚动到顶部这个功能。</p>
<p>理论上是这样的，并且我们也是这样做的。可我们发现了，如果我们切换菜单的时候，如果默认选中的不是报表，那么就没办法滚动到顶部。而且一旦刷新页面，用户当前的状态也就丢失了。</p>
<p>我第一想法是把<code>Menu</code>作为一个组件独立出来，这个我们可以更好的在组件内部实现逻辑。当切换菜单的时候，我使用了<code>scrollTop=0</code>这种方式来滚动到顶部。并且为了能够在刷新后记住用户状态，我需要反向遍历菜单树，并与当前路由进行对比，确认用户当前打开的菜单项位于的层级，从而控制其祖先菜单的打开和关闭。至此，问题解决了。</p>
<p>可是，在和<code>boss</code>沟通的时候，他第一时间判断我这样做是不正确的，并且现场撸了一个版本出来，且不讨论是否能用，但是太多的<code>if else</code>条件判断，反而让<code>DataReport</code>变得无比臃肿，再加上到下班时间并且我们在他身后看他写代码很久了，我一时口嗨就说了句<em>写得乱七八糟的</em>，这惹怒了我的<code>boss</code>，我也当场为我的不理智做出了道歉。<br>通过这件事可以看出来我的情商还要加强。</p>
<p>虽然最后还是采用了我的方案。</p>
<p>再讲讲学习。</p>
<p>在掘金上看了很多文章，都是零散的，比如说<em>事件循环</em>， <em>Shadow-Dom&amp;Custom-Element</em>，还是<em>CSS mask&amp;clip</em>或是<code>markdown2html</code>，通过这些零散的知识点学习，我觉得我对前端的理解又有了更多的理解。在大方向上的学习上，主要是<code>TypeScript</code>，<code>Echarts自定义系列</code>，以及读源码。</p>
<p>特别是读源码，真的让我收获颇多。最近在看<code>Wind Design</code>的很多组件的源码，大体上是老版本的<code>Ant Design</code>的源码。很早就接触并使用到了<code>Antd</code>组件库，比如经常使用的<code>Form</code>组件却不知道是如何实现的。</p>
<p>我之前也按照自己的想法，封装了一个组件。可当读完源码后发现，真的是自己水平太低，很多问题都没有考虑到。并且作为源码，自己的代码也不够规范。</p>
<p>当然，从下周开始，我不会像现在一样闲了，但源码我还是会一直读下去。如果有时间的话，我会考虑记录记录写成博客什么的？</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><blockquote>
<p>上周末我把和上司闹不愉快的事情告诉了家人，而一到周一下班，妈妈就打来电话，问我的情况，生怕我和上司的关系存在问题什么的。说实话，我很感动，我给她说啊，都是技术上的事，不会带入平时工作的，并且我在意识到自己的错误的时候，也立马进行了道歉，况且我的上司也是一个很nice的人，这样他们终于不用担心了。其实就是这样，最关心我们的，非家人莫属。所以啊，都那么大的人了，做事情一定要考虑更多，让他们和关心你的人，少为你操心。</p>
</blockquote>
<p><em>IG</em>都夺冠了，那我也要戒掉自己的某个陋/懒习了，所以在最后立一个只有一个人知道的<code>FLAG</code>。</p>
]]></content>
      
        
        <tags>
            
            <tag> 周记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记(节后综合征)]]></title>
      <url>http://yoursite.com/2018/10/15/week-record-1014/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我似乎是患上节后综合征了，具体表现为：晚上睡不着，早上起不来。</p>
</blockquote>
<h3 id="周一"><a href="#周一" class="headerlink" title="周一"></a>周一</h3><p>上周整个周末都因为电竞事业繁忙甚至抽不出来一个小时写<em>周记</em>，毕竟有那么多比赛/直播要看，看完还要打，真的嫌时间不够😂。所以上周的周记只好在周一补上了。</p>
<p>项目进行到最后一周，开发和测试工作已经结束了，所以这周的任务就是<em>摸鱼</em>，比如说今天，上班八小时，<em>摸鱼</em>七小时，好不容易熬到了下班😂。</p>
<p>回来的时候，开始下起雨来，昏暗的路灯下，行人匆匆。我想起了大学最后的一年，那个冬天，同样的傍晚，刚从健身房出来，身体还温热，猛地吸入一口冷空气，冻得直哆嗦。而一年不到，当初健身的小伙伴许久不联系，自己也开始发福？(离开公司前刚上称 139斤)。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>上周的工作有点划水前奏的意思，开发快要完成，改完了测试提的<code>bug</code>，剩下的就是琐碎的事了。可是就是这么点事，却出了最多的问题，需要花最多的时间去尝试解决。</p>
<ol>
<li><p>在开发一个图形分析的功能，一个类似图浏览器的功能，包括缩略图和图主体两部分，由于<code>boss</code>强调封装，所以并没有开发一个新的组件，而是融合到<code>reportChart</code>中，这使得原本就有好几百行的<code>echarts</code>配置文件又多出了一大截，代码可读性当然不用说了，一个字形容就是：<em>差</em>(虽然不是我开发的)。好了，开发完毕，给到开发们，一开始还好，随着需求越来越多，代码出问题了，并且影响到了先前开发的代码，并且难以追踪。排查了好久，最后是因为一个配置项默认值的问题。当然，<code>bug</code>还很多，比如说<code>yAxis</code>无法正常显示刻度/负数和特殊数据无法绘制等。除了<code>bug</code>以外，性能也是很低下的，基本上达到了不可用级别。因为在初始化时，需要请求数据用于绘制缩略图，这会导致太多的网络请求和组件的更新，最后折中了一下，使用<code>icon</code>代替了缩略图。结果这周刚来，接到通知，图形分析被砍了，也就是说，上周有一半的活就白干了😂。</p>
</li>
<li><p>项目本身遗留一个很大的问题，就是当存在主子表的时候，如果有筛选条件，那么当更改筛选条件并且主表没有数据的时候，子表会拿到上一个参数并且成功请求到数据，这显然是不对的。这个<code>bug</code>很早就被发现了，但又因为各种各样的原因，还没得到解决，并且在测试把<code>bug</code>算到我头上和<code>boss</code>出差的情况下，我只好硬着头皮上了。首先分析点击<em>提取数据</em>按钮后发生了什么事，结果当然是<code>dispatch</code>了一个<code>action</code>；但这个<code>action</code>并没有去请求数据，而是更新了一个标记，这个标记通过<code>props</code>的方式传入到顶层组件中，该组件在<code>componentWillRecieveProps</code>中对对该标记进行了捕获，并且还做了其它的操作；最后是<code>ReportTable</code>组件更新，重新请求数据，并且把请求到的数据渲染出来。这里使用了高阶组件，用户请求数据的参数和事件捕获函数都在父组件中，并且通过<code>props</code>来传递。分析到这里，已经很明了了，我们需要在父组件更新的时候清空<code>selectedRow</code>(也就是被选中行)，那么一旦主表无数据，<code>selectedRow</code>将无数据，字表不会发起请求，也就不会错误渲染了，至此，问题得到解决。</p>
</li>
<li><p>在我开发的一个名叫<code>QAPanel</code>问答面板的组件中，有一个问题，就是一旦滚动到某个地方后再请求数据，页面并不会滚动到顶端，而仍然停留再上一次滚动的地方。这个问题很好解决，一旦组件渲染，我们需要拿到组件的<code>ref</code>(引用)，并且再请求新数据之前，把页面滚动到顶端。这原本不是问题，一顿操作过后，竟然报错，<code>createRef undefined?</code>，一脸懵逼。谁叫我们还用的是<code>React 15</code>呢，又是一顿操作，改成原来的模样，差点记不住😂，因为我刚接触<code>React</code>的时候，就已经是<code>React 15</code>，那年我才20岁😂。</p>
</li>
<li><p>当然，我们的<code>webpack</code>肯定是<code>3.X</code>的，由于使用了<code>create-react-app</code>脚手架，具体构建细节都被隐藏了，所以<code>eject</code>一下就好了嘛。对的，配置是暴露了，也修改了，可就是无法正常构建了，我承认这是我的问题，但是久经排查，并没有发现<code>bug</code>，所以还是老老实实的用覆盖的形式吧，不需要过多的修改，构建的时候需要分包，把第三方库都打包到一起，运行时代码再分开打包。结果差不多压缩后加起来有<code>3MB</code>，并且构建的时间差不多<code>90秒</code>，慢得让人流泪。果断<code>happyPack</code>走一波，总算<code>happy</code>了。</p>
</li>
</ol>
<p>还有很多很有意思的事情这里就不细说了。总的来说就是，填别人的坑，让别人无坑可填。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><ol>
<li><p>如果说电竞是生活的话，那么吃肯定也少不了。上周末两天，累计叫外卖<code>3</code>次，共计消费<code>90+</code>，贵也就算了，关键是特别难吃。这让我想到了我的家乡，随便一个路边面馆，一碗十块<em>豌豆炸酱面</em>，简直不要太好吃。所以啊，想要逃离，这可能是我需要好好思考的了。</p>
</li>
<li><p>打篮球也要玩心跳？对的，我指的是这款名叫<code>NBA 2K OL2</code>的篮球游戏，因为它的球员交易市场就像炒股一样，你家有矿你随意。从公测开始，陆陆续续完了一个多月，人民币也花了一百多，总算把自己的阵容弄到<code>500w</code>了，谁知道12号一波更新，出了一个合同费礼包，导致合同费贬值严重，我的阵容在一天时间里涨了了<code>300w</code>，也就我在仅仅的一天里，赚到了<code>60%</code>,除去<code>25%</code>的交易费用，也要净赚<code>35%</code>，这可比A股刺激啊。<br><img src="http://olro3ke8a.bkt.clouddn.com/2K.PNG" alt="阵容截图"></p>
</li>
<li><p>当然还是打球。NBA有一种很吃香的球员那就是<code>3D</code>球员，例如<em>佛主</em>就是典型的<code>3D</code>球员。随着身体变得更强壮，再加上良好的防守习惯和态度，让我在野球场上成了一个优秀的防守者，可是越来越不自信的投篮，别说三分，就是中距离也都靠蒙，以前还能算个<code>2D</code>球员，这下好了，只剩一个<code>D</code>了。所以啊，整个NBA，<em>萝卜丝</em>(罗伯森)最像我了😂。可是，<em>萝卜</em>有瑞秋，而我的瑞秋呢？😂😂</p>
</li>
</ol>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>生活还要继续，我爱编程，编程使我快乐。好了，电竞事业繁忙，告辞。</p>
]]></content>
      
        
        <tags>
            
            <tag> 周记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记(长假前夕)]]></title>
      <url>http://yoursite.com/2018/10/02/week-record-1002/</url>
      <content type="html"><![CDATA[<blockquote>
<p>您的一周六天班体验卡已到期，请尽快续费，否则将会被放假一周。</p>
</blockquote>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>当开发阶段的工作暂告一段落，那么接下来的工作总会是比较轻松的，我也不例外。这个上六天班的一周，可以被划分为三个阶段，轻松-&gt;懵逼-&gt;抓狂。</p>
<h4 id="轻松"><a href="#轻松" class="headerlink" title="轻松"></a>轻松</h4><p>每天除了等测试反馈bug然后再修改以外，在code review 中提到的代码风格的问题也需要修改，虽然有定制的团队代码规范约束，但是例如变量/属性命名，存在性检测，数据格式验证等都需要修改，按照每个人维持的代码量不一样，我这一改就是三天，并且还发现了一些低级错误，比如中文漏打/错打，生成表格列宽严重不足等。</p>
<h4 id="懵逼"><a href="#懵逼" class="headerlink" title="懵逼"></a>懵逼</h4><p>接到新的需求，需要对某些业务做定制化的开发。刚刚拿到任务的时候简直是懵逼，第一眼看上去就不简单。深入Delphi代码了解，发现除了很难画出来的图，连表格都很难去完成。表格表头是动态生成的，需要通过接口去拿到数据生成百表头，再通过其它接口拿到数据，再渲染。限于在既有框架下开发存在许多限制，要实现这样的需求是比较困难的。原本可能只会花2小时的任务，半天才搞完。这里还得吐槽一句，接口返回的数据又是<code>columnX</code>的方式，对应几十个字段的数据没有对照表真的很难完成。</p>
<h4 id="抓狂"><a href="#抓狂" class="headerlink" title="抓狂"></a>抓狂</h4><p>上班的最后一天，内心也变得浮躁起来，经过前一天的研究，今天的任务就是开发出图形，原本的框架当然不能使用了，已经想好了两种解决方案，使用<code>echarts</code>自定义系列或者使用<code>canvas</code>来自行绘制。</p>
<p>首先尝试<code>echarts</code>，摸索了好久配合上demo终于完成了单元格的绘制，然后是多<code>xAxis</code>绘制，怎么尝试都无法达到想要的效果。因为在绘制等高等宽单元格的时候，<code>xAxis</code>的单位标度成了单元格宽度，其是<code>value</code>类型，而原本<code>xAxis</code>期望是使用时间作为<code>xAxis</code>，其类型是<code>category</code>，因此基于时间标度的折线图无法绘制成功。这几乎是一个无法跨越的问题，正当我准备舍弃这种方案的时候。突然想到，既然这条<code>xAxis</code>是无意义的，那么我们再配置一条<code>xAxis</code>，并且不渲染这条无意义的<code>xAxis</code>不就可以了。</p>
<p>经过尝试，的确可以！接下来就是接入数据，绘制图的数据需要做整理，首先需要做二维数组的转置，去除无用数据。然后是进行标记，因为业务要求需要标记每天每个行业的涨跌幅和涨跌幅排名，来进行图的颜色渲染和富文本渲染。做到这里，差不多demo就完成了，效果与设想的差距不大，剩下的就是细节的完善了。真是令人抓狂的一天！</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol>
<li><p>转正答辩。虽然过来人都说走走过场，但真当落到自己头上的时候，还真是这样。可又不是这样，气氛非常融洽的一次答辩，到场的大佬都很nice，答辩完还在会议室里闲聊。后来发现架构部的老大去年就是面我的那位，瞬间无比亲切。又聊到目前的一些新技术在公司的运用，工程技术中心一直走在前。经过这次答辩，我突然又有点看到了未来。这是以前从来没有过的。</p>
</li>
<li><p>遇到一个问题。我在开发一个公共组件的时候，需要加一个<code>loading</code>的效果，使用了<code>Spin</code>这个组件作为容器，但是开发完成后发现并不能滚动。因为<code>Spin</code>容器的高度取决于其内容的高度，而内部内容容器的高度又是继承至外部容器，所以这里相互冲突了。要解决这个问题也很简单，我们仍然需要<code>Spin</code>组件成为一个容器，当时其不应该在组件最外层，而是只包括内容，这样一来，内容容器继承的高度就是外部容器的高度而不是<code>Spin</code>的高度，当内容高度超过内容容器高度的时候，就可以进行滚动。</p>
</li>
<li><p>学习TypeScript。一直在花时间学习<code>TS</code>，因为工作需要需要去理解源码和做定制化，除此之外，我想扩充自己的技能树。</p>
</li>
</ol>
<h3 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h3><p>我从高中开始关注智能手机，对参数配置了如指掌，也因此选择了成为一名程序员；后来上了学，我关注电脑，无论是是笔记本还是PC，对电脑的配置也颇有见解。这些年来，找我推荐手机电脑的朋友真的不要太多。</p>
<p>大四的时候，因为一档二手车节目关注汽车，目前对车型/配置/售价也是颇为了解，也会花时间去专研发动机/变速箱原理等。我在想，如果除了做程序员，我可能也会去修车？</p>
<p>上班了，也开始关注楼市。虽然比起智能手机电脑，对于楼市的理解真是知之甚少，目前还在加深理解。</p>
<p>人在不同阶段所关注的点也不一样，关注手机电脑我往往是有这个需求，而当没有这个需求的时候，这样的关注就会发生转移。从高中到步入社会，我的关注一直在变，所以在如今的这个阶段，需求不是那么不好满足的时候，能做的只有努力。</p>
<p>废话说完后，匿。</p>
]]></content>
      
        
        <tags>
            
            <tag> 周记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记(中秋)]]></title>
      <url>http://yoursite.com/2018/09/22/week-record-0922/</url>
      <content type="html"><![CDATA[<blockquote>
<p>放假第一天(上周六)，打篮球，用力过猛戳到手指，又肿又痛的，键盘都没法敲，两天过去了，现在是这个样子的。<img src="http://olro3ke8a.bkt.clouddn.com/IMG_0525.JPG" alt="受伤了...">肿是消了，但是只要按压就痛的不行，所以每周一记推迟了。</p>
</blockquote>
<p>如果真要写的话，可能手指受伤的这几天，受最大影响的莫过于我的“电竞事业”了😂。</p>
<p>再补上。</p>
]]></content>
      
        
        <tags>
            
            <tag> 周记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记(发工资日)]]></title>
      <url>http://yoursite.com/2018/09/15/week-record-0915/</url>
      <content type="html"><![CDATA[<blockquote>
<p>上周说前段时间进行的的<code>前端资格考试</code>挂了，等待补考，其实不然，我莫名其妙的就过了。</p>
</blockquote>
<h3 id="工作之外"><a href="#工作之外" class="headerlink" title="工作之外"></a>工作之外</h3><p>昨天晚上和大学舍友聊天，聊到近况，发现大家都有落差但也随遇而安，无论是传说中的<code>996</code>还是节假日加班，抑或是我这种相对较为轻松的工作。现在大家都明白了，当初被听信企业画大饼，总觉得自己壮志未酬能够好好干一番，结果总结起来，就是我们太年轻。</p>
<p>我的作息时间一般为晚上12点睡觉，早上7点起，8点到公司，这样的话我就可以早点下班并且保持一个较高的所谓<em>战斗力</em>了。可是这个平衡还是被打破了，每天到了12点睡不着，早上还是7点起，睡眠时间不到7个小时，再配合上高强度的工作，担心身体真的吃不消。而这种担忧在昨天显现了，下午1点例常开发报表，开始头痛，我不得不停下来休息，喝喝水洗把脸什么的；到了三点半开完会，头痛反而加剧了，趴了好一阵，又去江边溜达了一圈，透透气，这才缓解，差不多到五点。前段时间看一个视频，程序员因为劳累倒在工作岗位上，我庆幸自己没事，但是为了健康着想，以后得早点睡了。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>最近一段时间得任务都是开发报表，手头上报表大概有40张，按照每天开发3个得进度，得三周，并且每一张报表都不一样，遇到的问题也不一样，所以进度有可能被搁置。</p>
<p>例如本周在开发过程中就遇到很多有意思的问题，具体的业务是我需要使用一个下拉选择框，每次选择后会请求不同的数据，问题就出在我根本不知道每个选择项具体的值是什么，因为我们能够获取信息的方式只有<code>Delphi</code>代码，而恰巧这份代码中所有涉及到的中文的地方都被编码过了，并且这种编码方式是公司独有的，且我暂时不能通过沟通的方式来解码，所以一切都得靠自己咯。编码方式看起来像<code>#23398#39#19876</code>这样，是不是很熟悉？如果稍微变化<code>&amp;#23398;&amp;#39;</code>现在知道了吧，所以这就是一种去掉了<code>&amp;</code>和<code>;</code>的<code>unicode</code>啊。那么这就很好解决了，写脚本转就可以了，至此，问题搞定。</p>
<p>还有很有趣的事情，比如接口返回的数据有一个字段本该是<code>_mainColumn</code>却写成了<code>_mainColmn</code>,或者干脆在一个有四十多个字段的接口中使用了<code>columnX</code>的命名方式，这种毫无意义的字段名称，给到对我来说完全黑盒的接口，简直是灾难😂。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>这周仍然只有恨碎片化的时间来学习，并且随着内心变得浮躁，碎片化的时间也被消耗殆尽了。</p>
<ol>
<li>SPA性能优化。<code>tree shaking</code>打包时将无用的代码删除掉；代码分割，分离三方库等；动态导入（按需加载，预加载等）；利用缓存，打包成<code>runtimeChunk</code>等。</li>
<li>TypeScript 学习。在TS官网上看了好几章文档，主要包括数据类型，类型断言，接口等。</li>
<li>块级格式化上下文（BFC），老生常谈的问题了，看文章温习温习。</li>
</ol>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol>
<li>安利一款游戏：《NBA2K OL2》,可以看作《2K17》的阉割版，目前能玩的模式只有王朝和街头，对于我这种不花钱也不是很想变得很强的玩家，偶尔玩玩还是不错的。</li>
<li>一款叫做<em>PDFelement6 Pro</em>的软件，也许是我用过能够看PDF和编辑PDF最好的一款了，这不是免费的，当然在天朝想免费还是能够办到。</li>
<li>都2018了<code>JetBrains</code>全家桶仍然可以通过修改系统时间的方式无限期使用，所以我想学<code>Fluter</code>，求打醒，小程序还没眉目呢！</li>
</ol>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>上午说发工资了，怎么也得请吃顿好的吧。好，肯德基怎么样？好啊，请。帮我叫外卖吧，外面太热了，不想出去。怎么可能，已经点好了，出去取吧。晕。穿好鞋，飞奔。走到一半，电话响起。您好，你的外卖到了，门口拿一下。飞奔回去，衣服湿透了。</p>
<p>吃着三十多一顿的午餐，真香。</p>
]]></content>
      
        
        <tags>
            
            <tag> 周记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记（9月来了）]]></title>
      <url>http://yoursite.com/2018/09/08/week-record-0908/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我真是一个坐不住的人。</p>
</blockquote>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><blockquote>
<p>我以前总以为在别人搭好的架子下写代码是体力活，而现在这个观念的的确确需要改变了。</p>
</blockquote>
<p>我的这周的前三天我都在开发新的报表，周四被安排了一天“轮休”仔仔细细检查了已经开发的报表，周五由于没有安排活所以还是开发报表。我一直以为开发报表是一件实打实的体力活，我们不需要知道报表/图表组件具体实现的方式，我们甚至不需要关心页面布局，因为用于布局容器组件都写好了，我只需要读懂把<code>Delphi</code>代码，然后把对应的数据传入到<code>props</code>中就可以了。这当然有难点，理解<code>Delphi</code>需要花上一些时间，细节也要想方设法去实现。可是当大多数报表实现十分类似，熟练过后基本没什么难度，那么这项任务也就对我来说就成了不折不扣的<em>体力活</em>了。</p>
<p>真的是这样吗？</p>
<p>刚开始开发的时候，其实犯了很多错，这些错误都来自对项目的不理解和粗心大意。甚至我在很长一段时间内并没有发掘，直到阴差阳错这些隐含着错误的报表被纳入到发布版本，测试检测出错误的那一刻。</p>
<p>这中间还有一个小插曲，前面说到阴差阳错的报表就上线了，其实是因为配置文件被更改了。因为这个事情在晨会上我还和<code>leader</code>争了几句，当然到最后谁都没有再追究。把这件事讲给小伙伴，所有人都说我情商低，可我总是这样，我会忍气吞声，当然如果三番两次，总会忍不了，我是来写代码，可不是来背锅的。</p>
<p>回到正题，修复了很早以前开发留下的<code>bug</code>外，在“轮休”那天，我好好检查了那些后来开发的报表，虽然没有了功能上的<code>bug</code>，但还是由于粗心大意，比如字段描述中的文字写错，数字格式化不正确等。好在这些报表都没上线，不然这个就真得我背锅了。</p>
<p>周五开发了一个十分复杂的报表，它让我意识到，这不仅仅是一份体力活。我差不多花了5个小时来完成这张表，除了非常难懂<code>Delphi</code>代码外，限制条件也十分多，因为需要实现具体的功能，发现已经封装好的组件并不能满足需求的时候，又需要去沟通增加需求，并且在开发的过程中，因为实在架子下工作，反而为了实现某些功能，需要额外的想办法。</p>
<p>好吧，说了这么多，我承认我现在做的工作不仅仅是体力活，当然就算是体力活，我也要把任务做到极致。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><blockquote>
<p>这周大块大块空余的时间并不多，在闲散的时间里，我主要通过在<em>掘金</em>和<em>github</em>看文章来学习。</p>
</blockquote>
<h4 id="文件获取和上传"><a href="#文件获取和上传" class="headerlink" title="文件获取和上传"></a>文件获取和上传</h4><ol>
<li>使用<code>input[type=&#39;file&#39;]</code>模拟点击上传</li>
<li>使用拖动/放置事件来上传<code>drag/drop</code></li>
<li>剪切板的粘贴事件</li>
</ol>
<h4 id="高阶函数-HOC"><a href="#高阶函数-HOC" class="headerlink" title="高阶函数(HOC)"></a>高阶函数(HOC)</h4><p>函数作为参数传入/作为返回值返回。</p>
<ol>
<li><code>AOP</code>面向切面编程。把与业务无关的模块抽离出来，然后动态织入到业务中去。</li>
<li>柯里化(部分求值)。函数并不会立即求值，而是返回一个另一个函数，已经传入的参数活因为形成的闭包而得以保留。</li>
<li>函数节流与分时函数。</li>
<li>惰性加载函数。</li>
</ol>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ol>
<li>有关于<code>getBoundingClientRect</code>的学习。</li>
<li>哈希碰撞与生日攻击。</li>
</ol>
<h4 id="框架-库-工具"><a href="#框架-库-工具" class="headerlink" title="框架/库/工具"></a>框架/库/工具</h4><ol>
<li><code>store.js</code> 多浏览器实现的本地存储库。</li>
<li><code>pica</code> 一个很好用的图片压缩工具</li>
<li><code>tween</code></li>
<li><code>Vue.js</code> 基础知识重温</li>
</ol>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>周五的<em>前端资格考试</em>已挂，期待下周补考。</p>
<p>最近绝地暖暖开挂的人太多了，把把都有大哥，快要弃游了。</p>
<p>最后：无糖全麦麦片真好吃🤮</p>
]]></content>
      
        
        <tags>
            
            <tag> 周记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记（8月的尾巴）]]></title>
      <url>http://yoursite.com/2018/09/01/week-record-0901/</url>
      <content type="html"><![CDATA[<blockquote>
<p>从万般<em>抵触</em>到欣然<em>接受</em>，没想到会这么快。</p>
</blockquote>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>我被转岗了，并且是在没有通知的情况下。</p>
<ul>
<li>上周五，老大让我去看<code>某度统计</code>的源代码，花了好长的时间，想了好多办法才拿到这份经过<code>babel</code>转译过的源码，可读性又差，我硬着头皮看了个大概。这大概若不是工作需要我可能永远不会去读的代码。</li>
<li>周一，前去汇报，听说要做一个类似的项目，私底下用什么技术，如何去实现我都想好了，只等开工。</li>
<li>周二，打开邮箱，转岗的邮件发过来了，在毫不知情的情况下，我因为业务需要被调岗了，甚至这次调岗老大都不知道。刚看到这份邮件的时候，我最开始的心情竟然是有点开心，因为在我们部门简直不要太闲，并且首页代码真的让人提不起兴趣。再者，我要去的部门是公司的核心部门，用公司前段时间说的，我这是从第一曲线往第二曲线上跨越。</li>
<li>周三，在搬过去之前，我把首页的代码又仔细检查了一遍，确保所有生涩难懂的代码段都有注释，又解决了几个潜在的<code>bug</code>，最后提交一把，并交给小伙伴。晚上，下班，我一个人默默的搬了好几趟，心里说不出的难受。和小伙伴一起回家，路上我在吐槽，好不容易熟悉了一个环境，又要去一个陌生的环境，对于不善人情世故的我，真的是煎熬哎。</li>
<li>周四，新部门的第一次晨会，我完全打消了心中的顾虑，我想我能够很好的融入这个集体。等拿到项目代码，又回到了<code>React</code>了，复杂的实现逻辑，理解起来真的让人头疼，但也让我欣喜，我喜欢挑战，虽然看起来这更多会是体力活。</li>
<li>周五，在新的环境里，一切又回归平静。带上耳机，新的一天又开始了，这让我想起上学的时候，带上耳机听着音乐，脑子无比清醒，总能够很快的完成任务。</li>
</ul>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><ol>
<li>React </li>
</ol>
<p>既然又入坑了，对于好几个月都没怎么用的技术了，当然需要花一些时间来温习下了。</p>
<ol start="2">
<li>微信小程序</li>
</ol>
<p>源于在<em>掘金</em>上看到的一个沸点，我决定把开发小程序加入自己的技能树了，这可能需要花上很长的一段时间才能达到写demo的阶段，平时忙得不可开交，周末玩玩游戏健健身，学习的时间又少了，哎…电子书已下载好，写完周记就启动！</p>
<ol start="3">
<li>SSR</li>
</ol>
<p>上周花了很多时间去学习<code>React</code>服务端渲染，Demo也是写了毫无异常，昨天下班后尝试把以前做过的<code>idea</code>转到服务端渲染上，却怎么都不成功，也不报错，所以这才是周末的优先级，当然除了游戏时间外。</p>
<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>虽然吐槽公司不怎么好，但是继收回所有开发的管理员权限后，公司又在网络上为<code>大家着想了</code>，原本每天只有200MB的流量可挥霍，下个稍大的软件都要开工单，现在工作机器要断网了，想上网查资料，滚去虚拟机去查！所以啊，机器本身配置一般般，以后虚拟机又要常驻内存了，开发体验在差的基础上，变成了<code>如果不是为了生活</code>…</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>虽然刚上大学不久就接触到了Web开发，接触Web前端开发也有好几年，毕业来公司作为前端也两个月了，React项目国际化，首页数万行祖传代码重构(重写)到几千行，但是我在下周还要参加公司的前端资格考试，只有考核成功，你才能正式成为前端搬砖师。</p>
<p>我想的是，需不需要准备啊什么的，要是到时候考试没通过，要被转去后端写<code>C#</code>，我肯定是不愿意，那就只有另谋高就了。</p>
<p>刚来公司上培训课的那段时间，公司前端新人十几个，竟然只有两个人是有经验的，其中有一个只是停留在使用过<code>jQuery</code>的阶段，那么问题来了。我排第几？</p>
<p>我觉得，虽然那些没有接触过前端开发的小伙伴能够在最近好好学习，但是作为一个几年了还在浑水摸鱼的前端，我我觉硬要排名的话，前五还是稳的。</p>
<p>考试前的准备，学生时代尚且没做好，不在乎早已根深蒂固。</p>
<p>结果如何，下周便知。</p>
<p>这次把尾巴也写成了吐槽😂 </p>
]]></content>
      
        
        <tags>
            
            <tag> 周记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记（8月末）]]></title>
      <url>http://yoursite.com/2018/08/26/week-record-0826/</url>
      <content type="html"><![CDATA[<blockquote>
<p>找不到能形容这一周生活的词，除了<code>愚蠢</code>。</p>
</blockquote>
<h3 id="照例谈工作"><a href="#照例谈工作" class="headerlink" title="照例谈工作"></a>照例谈工作</h3><p>我觉得我现阶段的工作和大学里上自习没什么区别，没有人约束，仅凭自己的意愿，随心所欲。除了偶尔还需要补救盲目的重构带来的<code>bug</code>，偶尔需要切下图制作个广告页，剩下的时间就自己安排。</p>
<ol>
<li>看书</li>
</ol>
<p>自从知道在<code>github</code>上<code>clone</code>电子书可能会被关小黑屋后，在公司电脑上的电子书就只有当初年少无知下载下来的<code>《你不知道的JavaScript》</code>系列了，这也是我最喜欢的<code>JavaScript</code>开源电子书了。还是在学生时代，就完完整整的将整个系列看过一遍，如今一两个月的时间，差不多又看完一遍了，真的是有一种温故知新的感觉。在阅读整个电子书的过程中，有唯二不那么愉快的地方，第一，作者使用<code>Markdown</code>格式编写的，并且每一章单独成一个文件，有时候一章内容太多，断断续续需要一天才能读完，尤其是午后，读太久了犯困。第二，公司屏幕尺寸和素质不能让人满意，尤其是没有管理员权限去安装<code>Markdown</code>阅读器，只好在<code>VS Code</code>中打开并且使用分屏的预览，结果可读区域面积太小，读久了眼睛又受不了。</p>
<ol start="2">
<li>React SSR</li>
</ol>
<p>关于<code>SSR</code>（服务端渲染），我一直想纳入技能包，好在这周有充分的时间去学习。在<code>掘金</code>上看了两篇相关的入门文章，然后把大名鼎鼎的<code>Next.js</code>文档看过一遍。现在回顾一下，差不多只能记住<code>rendertoString</code>和<code>getInitialProps</code>? 大概还在也许会写Demo的阶段吧。所以说呢，学习尚未成功，还要继续努力。</p>
<ol start="3">
<li>源码</li>
</ol>
<p>看源码对于现阶段的我来说是奢侈的，如果加上通过各种途径去获得不容易获得的源码，再加上可读性为0，那就让人头疼了。</p>
<p>潜在的业务需要，我需要读一段<em>某某公司</em>开发的页面统计的代码，首先这些代码不是开源的，也不仅仅就通过引入这段JS路径就可以得到源码，并且其是不可读的，有多少不可读呢，举个例子吧，代码2000行左右，使用<code>IIFE</code>分成好几段，对于变量的命名，是没有规律可循的，都使用了<code>A-Z a-z</code>随机组合的方式，并且嵌套极深。例如<code>af.c.cb.hcp</code>。</p>
<p>如何获取到源码这里不过多叙述，反正花的时间多余读源码的时间。</p>
<p>源码如果不可读，那就只读能够理解的地方，所以这么多代码，大概花了2个小时梳理了一下，大概知道了了其工作方式，需要记录的各种数据，至于实现，那是不可能梳理得清楚的。</p>
<p>看完一遍，发现该份源码写得十分规范，给大厂点个赞！</p>
<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>周四，例行的下班后健身。结果坐电梯的时候发现五楼摁不了了，坐到三楼服务员告诉我，健身房倒闭了。WTF，两天前来还好好的，现在就倒闭啦？器材都被搬空，怕不是跑路了吧。我才买的的补剂呢！我才办的卡呢！</p>
<p>周五晚打完篮球，骑车回来，又路过那条街，发现有人在发办健身卡的传单，虽然不是开在一个地方。一想，真快哎，又为下一次跑路做准备了？</p>
<p>经过这次被跑路的经历，我是不可能再办健身卡了，民工挣点钱不容易，怕不是要被城市的套路消耗殆尽？但是呢，健身还得继续。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>换了电脑，把博客迁到PC上，试了各种网络上的办法，遇到各种各样的问题。结果我用最简单粗暴的方法，直接把目录拷贝过来，再安装依赖，就OK了。</p>
<p>刚买了新电脑，有点兴奋，每天下班后总会在快睡觉之前玩两把，玩完又睡不着觉，结果到了公司，第二天是真的困。要不得，要不得。</p>
<p>前端三连是：太复杂 看不懂 不会做。下次面试还有自以为是的面试官，直接就怼过去了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 周记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[每周一记（18年8月中）]]></title>
      <url>http://yoursite.com/2018/08/18/%E5%91%A8%E8%AE%B02018mid/</url>
      <content type="html"><![CDATA[<blockquote>
<p>8月16号刚凌晨，伴随着手机提示音，工资卡中终于有了第一个月的工资。然后，那个晚上，竟然失眠了，整晚上我都在想，除去房租和必要的生活资金，我该如何花掉剩下的钱呢。周四，忙碌的一天，晚上下着大雨，从健身房中回来，有了最初的想法，既然健身是为数不多的爱好，那么补剂还是要买的，无聊的时候想玩玩游戏去网吧简直不要太贵，主机嘛，当然是要攒的。再加上每月固定的花呗，好了，花光了，期待下月…</p>
</blockquote>
<h3 id="谈工作"><a href="#谈工作" class="headerlink" title="谈工作"></a>谈工作</h3><blockquote>
<p>本周的工作总体来说是很轻松的，但是出现了很多问题，我应该反思。</p>
</blockquote>
<p>在<code>掘金</code>上看到一个<em>沸点</em>，说的是新人总喜欢抱着满腔热血去重构祖传代码，然后碰壁。这点恰是说中了我。来到公司的这一个月，我也是在按照我的想法，重构一块很重要的代码。一段名副其实的<em>祖传代码</em>。无论从项目目录结构，还是代码本身，我只想说一句，烂透了或者是我从没见过这么烂的代码。但是，抛开性能和开发体验上的问题，这段代码却很好用。借用罗老师的一句话“<em>又不是不能用</em>”来形容是最好不过的了。</p>
<p>当然吐槽归吐槽，重构还是要继续。准确来说，是重写。在检测过ES6支持程度后，我使用ES6重写了业务逻辑，并且抛弃了<em>依然好用的表格布局</em>，引入和AMD规范，并且在易用性和可扩展性上下了很大的功夫。</p>
<p>请注意，这一切都是我想到的，没有经过评审，我花了两周的时间，就重构完了。</p>
<p>然后，上线了，BUG铺天盖地。真的，除了失落和灰心，我想不到其它的词来形容我的心情。</p>
<p>极为不规范的成千上万行<em>祖传代码</em>怎么可能在很短时间内弄懂；不熟悉业务逻辑，很多隐藏的业务功能都没有实现；引入模块化是好，业务逻辑解耦也好，但是过多的模板，导致现有的项目太过臃肿，要是只有一个版本还好，多版本多语言简直就是灾难。</p>
<p>除了修BUG，我也在思考，然后并且了模块化，一下子少了四十多个入口文件，通过工具把配置文件整合在一个文件中，并且在实际部署的时候压缩配置文件，配置文件从24个到如今的一个，体积从300KB到现在的70KB。当然，改变还有很多，使用localStorage缓存文件，合并压缩样式文件，减少页面请求等。重构未完成，还得努力。</p>
<p>还能说什么呢，学到了，真是学到了。</p>
<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>本周的某一天，我回到家，打开iTerm准备大干一场，突然，一道灵光闪过，我CTMD，iTerm换图标了，上面那个白条是什么鬼，真是逼死强逼症的节奏哎。直到现在，好几天过去了，还是不习惯！</p>
<p>某天晚上十一点，看了<em>将军</em>的直播，我一口气花完了攒了好久的3700尘，合了一套<em>法术猎</em>，结果被治疗术吊打，被各种德吊打，被电影萨打到哭，甚至打不赢沙包战你信？在这里，说一句：<strong>炉石传说</strong>真**好玩！</p>
<p>今天快到中午的时候，和小伙伴健完身去那边买网线，问了好多家杂货店和五金店，基本上都没有，然后一老大爷给我找了个三米长的竟然要收我十五块，忍住了没买。后来买了十米十二块，价格稍微能够接收。关键是拿回家一试，房间里根本没接网，去起居室接又不可能。白瞎了我的十二块哎，无线网卡走一波，了事。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如果说还要有其它就要算追了很久的美剧《地球百子第五季》完结啦，想看第六季明年再说咯。第五季追下来整体无感，感觉和前几季比起来剧情是真的无聊。今天看了第十三集，贝拉米他们重新上了飞船，休眠了125年，蒙迪留下的视频，感动！超级期待第六季地球百子与外星人的故事啦。</p>
<p>其它的其它，大概还有学习。每天给自己留下足够的时间，去好好的回顾和学习新的知识，趁自己还学得动。</p>
]]></content>
      
        
        <tags>
            
            <tag> 周记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开端]]></title>
      <url>http://yoursite.com/2018/07/31/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88/</url>
      <content type="html"><![CDATA[<blockquote>
<p>时间过得真快，搬砖快一个月了。</p>
</blockquote>
<h3 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h3><p>现在对搬砖的要求真高，培训后才能上岗。按照惯例，进了工地就要开始培训了，谁知有工友要下周才到，所以我们这些先一批就得等着了，第一周工头又不安排工作，只有无所事事了。那五天的上班时间啊，幸好带了本《论如何在搬砖过程中学习挖掘技术》，一边学习搬砖技巧，一边偷偷干私活。总的来说，工作环境还是不错的，就是给我们的工具有点不顺手，哎，就这样呢，还要什么自行车呢！</p>
<p>这里要说一下食堂，虽然菜品是少了点，但味道还是不错的，比我在蓝翔好吃多了，就是这个价格…放在我住那边的工棚小店，这个价两荤一素再来瓶冰啤，岂不是美滋滋。哎，说多了都泪啊。</p>
<h3 id="第二、三周"><a href="#第二、三周" class="headerlink" title="第二、三周"></a>第二、三周</h3><p>终于开始进行培训了。我们这些粗人，就仗着体力好，干得久，才能勉强得到这份工作。谁知第二周培训的内容竟然与我们的工作不是那么相关，金融知识，股票、债券、基金、期货搞得头都大了，最后做了个测试，发现自己是板砖型。妈哟，这辈子和砖怕是接下来缘分了啊。</p>
<p>培训的时候上面要求我们分成小组拍电影。是的，你没听错，是拍电影！妈哟，我们除了搬砖特长，哪还会啥子文艺哦，长得还丑，演技又捉急，真想找个地缝钻下去。</p>
<p>没办法啊，上面发话了，不但要拍，还要搞评比，那也得硬着头皮拍了啊。平时又没时间，搬砖时间又长，好不容易的周六，洗白了。</p>
<p>再说说我理了个大圆头，好像招谁惹谁了。那个搞培训的人说最不爱打理的就是我。WTF，我剪了个大圆头就认定我不爱打理了吗，那要是我留一头长发，再烫个卷卷头，岂不是你要说我是最帅的那个😂。</p>
<p>就因为我的这个大光头和不经意间透露出来自己会玩吃鸡，我TM也成了个头。那自然是要写剧本，当导演了啊。幸好以本人当前的造型，恐怕只能演打手。所以自然是不能亲自参演，幸好组里有演技派，要是有最正经奖，我们就获奖了。</p>
<p>第三周，没什么好说的，技能培训嘛。对于我们这种搬砖熟练手来说，食之无味，弃之不可惜，奈何上头说了算，还要考核，那是必须要去听了。工头布置了我些简单的任务，练练手还是不错的，所以这一周也就那样，还行。</p>
<h3 id="如今"><a href="#如今" class="headerlink" title="如今"></a>如今</h3><p>上岗了上岗了，满心欢喜啊。有个工友调走了，他的任务我就接手了呗。工头说了，先熟悉熟悉，随便干，追随自己的灵感。我呸，O98K，干就干啊。</p>
<p>是时候切换一下风格了。</p>
<p>磨炼新人最好的办法是把前人的代码给他看，让他绝望。我拿到那份有年代感的代码，还好把持住了，不然可能需要尿不湿。</p>
<p>我一眼望穿，这份代码深藏功与名啊。关于表格布局、<em>eval</em>、<em>html</em>外写<code>JS</code>、注释、命名什么的不想再多说。借用罗老师的一句话：又不是不能用。</p>
<p>改啊，那就好好改咯。</p>
<p>想起了，最开始想到的是：</p>
<ol>
<li>重写<code>DOM</code>结构，代替表格布局。</li>
<li>重写<code>JS</code>，除了那些没有头绪的黑箱。</li>
<li>基于配置的形式，一定程度解耦合。</li>
<li>基于<code>86.375%</code>的<code>ES6</code>支持率，引入安全的<code>ES6</code>写法。</li>
</ol>
<p>后来随着重构的深入，又有了新的想法：</p>
<ol>
<li>引入<em>AMD规范</em>，前端模块化。</li>
<li>运行时构建<em>DOM</em>以及性能测试对比。</li>
<li>单元测试。</li>
</ol>
<p>做完这些，第一步的改造计划就差不多了，用了一周的时间完成了这些工作。最大的收获大概是，DOM操作更加熟练了，<em>VS Code</em>的快捷键终于可以<em>Mac</em>和<em>Windows</em>无缝切换了。</p>
<p>接下来的项目是基于<em>React</em>的，还是老项目，做国际化的改造，以前没有做过类似的功能，还蛮期待的。</p>
<p>如果硬要打分的话：</p>
<p>加班程度：⭐️<br>新鲜度：⭐️⭐️⭐️<br>难度：⭐️⭐️<br>收获：⭐️⭐️⭐️⭐️</p>
<p>这里特别指出，最近利用上班的时间，看了很多书，真的收获很大的。每天翻书，手都翻痛了。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>又到了尾巴时间，一般灌点鸡汤什么的在这里再合适不过了。鉴于我们可是搬砖工程师，那就讲讲和搬砖相关的故事吧。</p>
<p>我的父亲，多年前从事过搬砖行业。现在虽然没搬砖了，可是也是相关行业。其实搬砖这个行业，真的很累，五十岁不到的人，明显看起来比一般人看起来更老。我父亲没什么文化，但多的是力气，所以他就靠这个把我和姐姐都供到大学毕业，然后啊，他还不稍微停下一点，又得考虑下一步了。</p>
<p>我想像父亲一样，能够独挡一面。</p>
<p>所以啊，有些时候负能量爆棚，总有些乱七八糟的想法，想想自己的家人，最后，既来之，则安之，也挺好的。</p>
<p>我们这种除了会点技术，还真是不会什么了。这是事实，但除此之外，做到更多只有靠你自己。</p>
<p>鸡汤灌输完毕，溜了溜了。</p>
]]></content>
      
        
        <tags>
            
            <tag> About </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[尾巴]]></title>
      <url>http://yoursite.com/2018/06/30/%E5%B0%BE%E5%B7%B4/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是故事的结局，我把它叫做尾巴。</p>
</blockquote>
<h3 id="是尾巴但也有开头"><a href="#是尾巴但也有开头" class="headerlink" title="是尾巴但也有开头"></a>是尾巴但也有开头</h3><p>尾巴起源于我一个不敢想但是蓄谋已久的想法。22岁，我大学毕业，来到了梦想中的城市，找了一份自认为还不错的工作，然后开始奋斗。这几乎是每个大学毕业生的剧本，我也不例外。22岁总会带来点什么，或是我们应该下意识改变些什么。而22岁的我，决定付诸行动，虽然已经蓄谋很久了。</p>
<p>见老朋友啊。</p>
<p>这就是尾巴，但尾巴也有开头。</p>
<h3 id="旅程"><a href="#旅程" class="headerlink" title="旅程"></a>旅程</h3><p>毫不夸张的讲，这是一趟漫长的旅程。即使我生活的地点一直向南在变化，就算我们可以选择的交通工具既方便又快捷，虽说没有千里之隔，但就像是回趟家一样。漫长，但充满期待。</p>
<p>路途开始那天就下起了雨，虽说都快七月了，但是上海就像梅雨天一样，几乎每天都会下会儿小雨，或者是太阳雨。傍晚时分，刚坐上火车，雨又开始沥沥淅淅下起来了，我把脸贴在玻璃上，甚至可以感受到火车车轮与钢轨摩擦发出的吱吱声，随着火车越开越快，这种感觉就越发强烈，直到到了忍耐的极限。在火车上的六个小时不长，但却够拿来回忆很多年的故事呢！好在六个小时不长，不然陷入回忆这种事就要发生在我身上了。可又为何会这样，也许是因为除了回忆，什么都不剩下了。</p>
<p>晚上10点，顺利到达目的地，一走出火车站，潮湿的热空气像我袭来，就像在冬季里吸入冷空气一样，吸入这样的空气也会让人顿时提起神来，它仿佛在告诉，你活着。是啊，活着真好！</p>
<p>第二天，很早就起，赶上清晨的前几班公交，离目的地还有很远，换乘，再步行，差不多两小时才到。穿过菜市场，湿漉漉的街道和发出的鱼腥味让我想起了和妈妈为数不多买菜的情景。眼前是一个有点年头的小区，旁边有高架桥，不远处还在绿化施工，这虽然是一片住宅，的的确确和D描述的一样，吵死了！</p>
<p>我环顾四周，茫然写在脸上。我开始打电话，又等了几分钟，一个阿姨向我走来，我认出来了，她是来接我的，旁边还跟着一个小女孩。我赶忙上去打招呼，阿姨看见我也很开心，好久没见到这样的笑容挂在一个中年妇女脸上了，上一个还是半年前的寒假，那个人是我妈。</p>
<p>就这样，我上了楼，一口气爬了六层，到了她家。房子从外面看真不怎么样，但走进真觉得精致啊，客厅厨房都挺宽敞的，这点和我合租的房子真是天壤之别。阿姨问我吃早餐了没，我碍于情面不好说自己饥肠辘辘，上一顿还是在昨天下午吃的，就说自己吃了，阿姨也没多问。</p>
<p>我坐在客厅的沙发上，环顾四周，却没有发现记忆里的东西，心里不禁失落，四年的时间里，也许什么都在发生改变。我和阿姨坐下来聊天，她以为我是D的高中同学，我说不是呢，我是D最好的朋友也是D小学同学，在远在千里的家乡，小学三年级的时候，我们还做过半年多同桌呢！阿姨的震惊完全写在脸上，又有谁能想到，眼前的这个人，竟然是D的小学同学！说道这里，毕竟是同乡人，我们用家乡的方言开始交流。我给阿姨讲我和D的故事，记忆深刻的。这样的桥段在我的脑海里不知过了几遍，语言斟酌了多少次，却没想到，直到真的要说出去的时候，是如此的困难。</p>
<p>好在时间冲淡了这一切，我们都没有太动情。阿姨带我去看了D的房间，这间房子我还是很熟悉的，虽然房间的主人不在了，陈设也变了，但是透过那窗台，望过去就是外面齐平的高架桥。D曾告诉过我，当她无聊的时候，还可以数过往车辆，数到自己不无聊为止。</p>
<p>我问阿姨有没有老照片。</p>
<p>她拿出了一本相册，整整满满的一个相册都贴满了，有多年的老照片，有全家福，还有很多有关D的照片。阿姨在和我一起翻看这些照片，去给我讲有关D的故事。</p>
<p>至始至终我脸上都没有表现出悲伤，直到离开。我谢绝了留下来吃中午饭的好意，阿姨也陪着我下楼，在最后的时间里，我给阿姨说，如果D没离开，可能我们早就见面了。</p>
<p>阿姨叫我以后多来家做客，可是就像是四年前那样，我又有什么理由再来这座城市呢！经过那条菜市场街，我拐了好几道弯，终于走出了小区。一路上，我在想，真的走出来了吧，不然小萝莉都快3岁了！我很欣慰，前所未有的释然。</p>
<h3 id="是尾巴但终究还是结局了"><a href="#是尾巴但终究还是结局了" class="headerlink" title="是尾巴但终究还是结局了"></a>是尾巴但终究还是结局了</h3><p>回到新的大本营，迫不及待的开始写这个结局。今天下了好久的雨，肯定积了好多水坑，我打开窗呼吸着还算清爽的空气，听到蛙鸣，一切都是那么安静。我想，是时候让故事告一段落了。</p>
<p>我的这22年来，对我影响最大的三个女性是妈妈，老姐和D。妈妈在我童年的那段时间教会了我太多，善恶美丑，做人准则；有一个姐姐真的很棒，总会收到各种各样的礼物，在最无法沟通的时候，同龄人的姐姐却可以懂我；D，我们在小学就已经相识，到了高中，如果不是有D，恐怕我已经荒废那段最宝贵的时光，然后浑浑噩噩过着日子。</p>
<p>我走不出D离开给我带来的阴影，看似只有在电视剧上才会发生的剧情，发生在了我头上，并且没有一个好的结局。</p>
<p>五年可以忘掉什么？那些看似很有用的高中知识点，我忘了；不常用的邮箱密码，也搞忘了；可是，D的离开，快五年了，我以为我忘记了，可是一旦记起，唯独耿耿于怀。</p>
<p>这一次，我依然没法忘记这一切，毕竟真实存在过，亲生经历过；正是因为忘不掉，才证明我们真正的活着啊，并且要好好活着。我没法忘掉这一切，但我看开了，这就是结局。</p>
]]></content>
      
        
        <tags>
            
            <tag> 心灵记事 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Goodbye & Hello]]></title>
      <url>http://yoursite.com/2018/05/01/Hello-Goodbye-Hello/</url>
      <content type="html"><![CDATA[<blockquote>
<p>5月1日，阴天，雾霾挺严重的。下午，戴着耳机，出门；傍晚，下起了雨，躲进快餐店；点了宫保鸡丁和土豆豆角，开始狼吞虎咽，然后，等着雨伞送到；离学校最后的一公里路程，需要十分钟。直到现在，12时，雨还在下，伴随着风。</p>
</blockquote>
<p>小长假的最后一天，也是五月的第一天。对啊，五月已经来了。</p>
<p>打开网易云音乐，点开日推，第一首歌就是<code>《Hello Goodbye &amp; Hello》</code>，很早以前看过的番剧<code>《追逐繁星的孩子》</code>ED。此刻我正苦于构思一个标题，所以就用了这个歌名“你好，再见，再也不见”。</p>
<p>在为数众多的看过的动画中，<code>《追逐繁星的孩子》</code>故事讲得不算好，但那句<em>原来是我太孤独</em>直戳内心深处。我想，我何尝不是这样呢，虽然性格不内向，容易和人打成一片，但我还是习惯一个人呆，去健身，躲在网吧打游戏。可我也挺怕一个人的，会因为一个人吃饭吃得特别快，走路也走得特别快，久而久之，给别人留下了不可接近的印象。</p>
<p>五月带给我的印象里就是忙吧，无论是高中还是上了大学，所有的事情都会在五月变得忙碌起来。而这个五月，也就是现在，我却过得非常的悠闲，甚至有点百无聊赖。早早的做完毕业设计，我有很多时间去做很多做感兴趣的事。这样的日子，还会持续两个月。不知道是好是坏。</p>
<p>我的生日一般都在六月，这个时候我呆都在学校，所以这么多年来，我都没怎么过过生日。高中的时候，有时候学习特别忙，都忘记了哪天是五月初三，每次都是妈妈打电话提醒我，让我吃顿好的；上了大学，我更不想让同学们知道我过生日，所以那天我很早就出门，找个自习室好好的学习一天。如果说要有什么不同，那一定是17岁那年，端午节。</p>
<p>至于为什么不同，因为我收到了特别的礼物。为数不多的收到过的贺卡，学生时代追了个遍的小说，画得还算不错的画。</p>
<p>去年寒假回去叔叔家把遗留在那里的高中记忆都翻了个遍，很可惜的是，贺卡不见了；而那本单行本也码在书堆中早已泛黄，我拿走了那本书，把它带在身边，就像那幅画一样。</p>
<p>对于只会画条条框框的我，无法描述那幅画的内容，但站在一个观赏者的角度，还算可以把，仅此而已了。</p>
<p>说起那幅画，我曾经给很多人看过，他们问我画的什么有什么含义，我总是说，我怎么知道啊，就是别人送的礼物而已。其实背后的故事我是知道的，那是我最珍贵的宝物，那是我的记忆啊。</p>
<p>其实记忆才是是每个人最珍贵的宝物。</p>
]]></content>
      
        
        <tags>
            
            <tag> 心灵记事 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端路由拦截和http响应拦截]]></title>
      <url>http://yoursite.com/2018/04/05/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA%E5%92%8Chttp%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA/</url>
      <content type="html"><![CDATA[<h3 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h3><p>最近在制作毕业设计的时候，遇到一个问题，那就是用户的访问控制。简单点来说，就是未登录用户只能访问某些特定的页面、API。最初我的想法是用户登录后返回一个凭证，用户以后的每次http请求都带上该凭证，进行验证，只有验证成功才能继续请求。然后在每个<code>页面</code>进行判断，如果用户是未登录或者凭证失效，则进行相应的提示和路由跳转。刚开始的时候，这个方法是完全可行的，但是在开发过程中，随着业务逻辑变得复杂、页面增多，重复代码太多，这样的方式也许并不合适。</p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>首先是后端，我使用了<code>jsonwebtoken</code>，用户登录成功都会生成一个具有一定时效的    <code>token</code>，这个token会发回到客户端，并且接下来每次发起http请求，都在http头的<code>authorization</code>字段带上这个<code>token</code>。我这里使用了<a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios</a>这个http请求库，只需要在拿到<code>token</code>后：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.common.authorization = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br></pre></td></tr></table></figure></p>
<p>就可以了。</p>
<p>由于在开发过程中涉及到跨域，这里我使用CORS来解决：通过设置一系列<code>Access-Control-Allow-*</code>响应头进行访问控制，上面提到了在请求头的<code>authorization</code>字段中设置token，因此发出的请求都不是简单请求，所以注意在每次发起http请求时，就会自动发起一个<code>OPTIONS</code>请求。</p>
<p>我服务器端用的是<code>Express</code>框架，我们需要写一个中间件来处理每一个请求。处理逻辑为：针对每个<code>OPTIONS</code>请求，直接放行；对于某些请求，如果在白名单中(例如登录、注册等不需要验证的路由)，放行；对于其他请求，我们拿到其携带的token，并且进行验证，如果验证通过，放行，否则结束请求，返回未授权。具体的代码如下，这里我使用<code>jsonwebtoken</code>这个package，用于生成<code>token</code>和进行<code>token</code>验证。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'methods'</span> ,req.method);</span><br><span class="line">  <span class="keyword">if</span>( req.method === <span class="string">'OPTIONS'</span> ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'option请求直接通过'</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 除去某些特定的API，其余的都做token的验证</span></span><br><span class="line">    <span class="keyword">let</span> &#123; path &#125; = req;</span><br><span class="line">    <span class="keyword">if</span>(path === <span class="string">'/api/users/auth'</span> </span><br><span class="line">      || path === <span class="string">'/api/users/auth_vc'</span> </span><br><span class="line">      || path === <span class="string">'/api/users/check_id_validation'</span> </span><br><span class="line">      || path === <span class="string">'/api/users/regist'</span></span><br><span class="line">      || path === <span class="string">'/api/users/send_reset_email'</span></span><br><span class="line">      || path === <span class="string">'/api/users/reset_password'</span></span><br><span class="line">    ) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'本次请求不需要验证权限'</span>);</span><br><span class="line">      next();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> token = req.headers.authorization ? req.headers.authorization.split(<span class="string">' '</span>)[<span class="number">1</span>] : <span class="string">''</span>;</span><br><span class="line">      req.token = token;</span><br><span class="line">      jwt.verify(token, KEY, (err, decoded) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">          res.status(<span class="number">401</span>).json(&#123; <span class="attr">status</span>: <span class="number">3</span>, <span class="attr">error</span>: <span class="string">'用户认证失败'</span>, <span class="attr">data</span>: <span class="string">''</span> &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'验证权限通过'</span>);</span><br><span class="line">          req.decoded = decoded;</span><br><span class="line">          next();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后是前端，我想如果能像后端拦截每个请求一样，写一个逻辑拦截所有的相应，并进行处理，信号，<code>axios</code>自带拦截器，我们只需要写我们的逻辑就可以了。我的想法是，拦截每一个相应，如果其状态码是<code>401</code>，那么久提示<code>token</code>失效，并且进行路由跳转。<br>以<code>vue-cli</code>构建的应用为例，在<code>main.js</code>中，下面是实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">data</span> =&gt;</span> data, (error) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(error.response) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(error.response.status) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">401</span>: &#123;</span><br><span class="line">        localStorage.removeItem(<span class="string">'token'</span>);</span><br><span class="line">        router.replace(&#123;</span><br><span class="line">          path: <span class="string">'/auth'</span>,</span><br><span class="line">          query: &#123;<span class="attr">redirect</span>: router.currentRoute.fullPath&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>值得说明的是，如果我们在某个访问的过程中，<code>token</code>失效，我们需要跳转到登录页面，但是想登录过后再跳转回来，所以这里在进行路由跳转的时候，我设置了一个参数, <code>redirect</code>，表示传入当前的路径，当我们登录成功后，在跳转回来即可。</p>
<p>最后是路由拦截，这里我使用了<code>vue-router</code>，其实<code>vue-router</code>的路由对象提供一个钩子函数<code>beforeEach</code>，其会在每一次路由跳转之前，执行这个函数，我们就在这里进行路由拦截。原理很简单，使用一个标志位标明每个路由是否需要用户权限，如果需要的话，我们检查保存在本地的凭证，一般存在<code>localStorage</code>中，如果不含凭证就直接跳转到登录页面。</p>
<p>好了，找到根路由文件，添加：</p>
<pre><code class="javascript">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span> , next</span>) =&gt;</span> {
  <span class="keyword">if</span>(to.matched.some(<span class="function"><span class="params">res</span> =&gt;</span> res.meta.requireAuth)) {
    <span class="keyword">if</span>(localStorage.getItem(<span class="string">'token'</span>)) {
      next();
    }<span class="keyword">else</span> {
      next({
        path: <span class="string">'/auth'</span>,
        query: { <span class="attr">redirect</span>: to.fullPath }
      })
    }
  }<span class="keyword">else</span> {
    next();
  }
})

</code></pre>
<p>这里要注意的是，<code>res.meta.requireAuth</code>是你自己在声明路由的时候自定义的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>差不多，这算是一个比较好的解决方案了。但是有这样一个情况：如果用户凭证有效期是1小时，那么如果我浏览网页超过一个小时了，凭证还是保存在本地的，当我们进行路由跳转的时候，并没有验证凭证是否失效，所以还是会进行路由跳转。这里不用担心，因为进入进入了一个路由后，一旦发起http请求，<code>token</code>失效，http相应拦截就会生效，进而跳转到登录页面。</p>
<p>加油！</p>
]]></content>
      
        
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最近这段时间]]></title>
      <url>http://yoursite.com/2018/02/24/%E6%9C%80%E8%BF%91%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<blockquote>
<p>不知不觉，大学里最长也是最后的一个寒假就快要过完了，而学生生涯也要画上一个句号了，真的好快啊！</p>
</blockquote>
<blockquote>
<p>还记得寒假带回来几本书，现在才开始翻看；本着要掌握的目标去学习Vue，然后现在才刚刚入门；信誓旦旦说要在家好好健身，虽说不规律，可总算是去做了，收效甚微；寒假总共“吃鸡”40小时，可总算成功吃鸡了。总之，最近(这个寒假)做了很多事，也下定了决心将要去做一些事。</p>
</blockquote>
<h2 id="那些做过的事"><a href="#那些做过的事" class="headerlink" title="那些做过的事"></a>那些做过的事</h2><ul>
<li>学习Vue及其技术栈，为毕业设计做准备</li>
<li>继续完善自己的Project</li>
<li>钓鱼！钓鱼！！钓鱼！！！说三遍~</li>
<li>有些事情，向前迈出一步</li>
<li>不懈努力，成功“吃鸡”</li>
</ul>
<h3 id="“吃鸡”与“吃到鸡”"><a href="#“吃鸡”与“吃到鸡”" class="headerlink" title="“吃鸡”与“吃到鸡”"></a>“吃鸡”与“吃到鸡”</h3><p>作为一名“吃鸡”萌新，标配夕阳红枪法，又是老年人视力，那肯定是行走的盒子精无疑啦。可是萌新也有大梦想，那就是吃一把鸡，为了这个目标，一直苦练枪法，终于吃鸡。既然如此，下一步目标是，打上2000分！就看时间允许不允许了😂</p>
<h3 id="学习Vue"><a href="#学习Vue" class="headerlink" title="学习Vue"></a>学习Vue</h3><p>毕竟一年多React经验的自信，所以毕设直接选了使用Vue来实现的一个App，那么理所当然的就要在寒假“补课”啦，官方教程半小时过一遍，再花1小时细细过一遍，OK不OK?ojbk！看完教程连个脚手架都搭建不出来！既然如此，还是视频大法好啊，看了差不过2个小时时间的基础教程，再配合上github上的开源项目，差不多get了吧。现在才感叹，当初学React的时候，真是费了好大的劲啊，光是Redux都够你喝一壶的了，最后悟出一个道理：珍爱生命，远离React😂</p>
<h3 id="钓鱼，第一等大事"><a href="#钓鱼，第一等大事" class="headerlink" title="钓鱼，第一等大事"></a>钓鱼，第一等大事</h3><p>我为什么那么喜欢钓鱼到现在还是一个未解之谜。我几岁的时候就开始钓鱼了，各种水域，各种鱼类都钓过，毫不夸张的说，我钓过的与鱼少说也是成千上万了吧。寒假一回来没有回老家就在农家乐钓过几次，太好钓了反而无聊。回老家的一个星期也钓了几次，总算过瘾了。以后夏天基本上没机会回家乡想想都可怕，只寄希望于春节少德可怜的假期能够撑起一个钓鱼爱好者的心啦~</p>
<h4 id="我的项目"><a href="#我的项目" class="headerlink" title="我的项目"></a>我的项目</h4><p>其实一直有在写一些简单的项目，脑子里想到的就要去试着实现，在学校一直在断断续续做一个关于想法的App，寒假无聊的时候也会一个点一个点去完善。但是倒霉的是，某个电脑管家竟然在清理垃圾的时候把这个proj删了，我还没提交到远程仓库呢，真是气死一个人，果断卸载！所以呢，找个时间得重新起航，也许到时候又会有新的点子呢~</p>
<h3 id="有些事情，得迈出一步"><a href="#有些事情，得迈出一步" class="headerlink" title="有些事情，得迈出一步"></a>有些事情，得迈出一步</h3><p>其实这个故事是这样的：你一直暗恋一个女孩很久，在后来的某个时候，你向她表白，她接受了，可是后来由于各种原因虽不说天各一方但也没能走到一起。很多年过去了，你总会在某些特定的时候想起她，你还是忘不掉她。你决心不留遗憾，在某次很愉快的聊天的时候，话题突然一转，你问她：你有男朋友吗？她说：你猜~ 你回答：也许有，也许没有，一半一半吧。她沉默了好一会儿，才憋出几个字：有的哦，都出来上班那么久啦。外面的花花世界，不比得你学校。听到这个意料之中的答案，男孩心中说不出的感觉，对她说了最后一句：打扰了。其实男孩心中从最开始就知道，如果可以把人分类的话，他们从来都不是一类人，从最开始他们就走向了不同的十字路口。至于为什么时常回想起，他也不知道。他迈出了一步，解开了自己的心结。</p>
<h2 id="那些将要做的事"><a href="#那些将要做的事" class="headerlink" title="那些将要做的事"></a>那些将要做的事</h2><h3 id="被逼无奈，我要学车"><a href="#被逼无奈，我要学车" class="headerlink" title="被逼无奈，我要学车"></a>被逼无奈，我要学车</h3><p><br>今年回家过年，七大姑八大姨除了问你：找到工作了吗、有女朋友吗、成绩怎么样呢这样的问题以外，学没学车竟然也加入了进来，在他们看来，不会开车的人好像就不能生存以外，所以为了不被念叨，我决心要学车啦，就在接下来的三个月时间里搞定！</p>
<h3 id="对，我要增重"><a href="#对，我要增重" class="headerlink" title="对，我要增重"></a>对，我要增重</h3><p>在外人眼里，我172的身高配上快140的体重是再好不过了的，不过我还是要增重，直到长到145，当然，这不是简单的增重而是增肌。所以，是时候努力了。</p>
<h3 id="补课，然后大补考"><a href="#补课，然后大补考" class="headerlink" title="补课，然后大补考"></a>补课，然后大补考</h3><p>补一门大二未上的实验课，然后大补考挂掉的《形势政策》，然后毕业！</p>
<h3 id="技术上，继续"><a href="#技术上，继续" class="headerlink" title="技术上，继续"></a>技术上，继续</h3><p>除了继续在web开发领域继续摸索深耕以外，还有扩展自己的技术栈，接下来要把大数据、数据挖掘纳入我的技术栈。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>比如一定要吃早饭、好好睡觉这种是肯定要做的，无论什么时候。</p>
<blockquote>
<p>本来挺喜欢玩《炉石传说》的，可是这个版本快攻横行，打不过术士又没尘加入他们，所以暂时要放弃啦。最近在看两部番剧《紫罗兰永恒花园》和《比宇宙更远的地方》。最近在读一本书叫做《24个 比利》。就这样。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQL参数化查询]]></title>
      <url>http://yoursite.com/2017/10/23/SQL%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>SQL注入想必是每个人都听过，其原理和XSS攻击很相似，都是把用户的输入当做程序去执行。防御办法也很类似，就是对用户的输入进行转义，但是同样转义十分麻烦，因为SQL注入攻击的方式和变种实在太多，转义需要考虑到的情况也复杂多变；而另外一种方式就是使用参数化查询–Prepared Statements。</p>
</blockquote>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>在先介绍参数化查询的时候我们先复习一下SQL注入，上面提到其原理是把用户的输入当做了SQL语句<code>程序</code>的一部分去执行，因为我们经常使用字符串拼接来构建SQL语句。</p>
<p>在这里开始演示一下(使用MySQL):</p>
<p>在我的数据库中我数据库中我建立了一个名为urls的表，其结构和数据如下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc urls;</span><br><span class="line">+-------------+------------------+------+-----+-------------------+----------------+</span><br><span class="line">|<span class="string"> Field       </span>|<span class="string"> Type             </span>|<span class="string"> Null </span>|<span class="string"> Key </span>|<span class="string"> Default           </span>|<span class="string"> Extra          </span>|</span><br><span class="line">+-------------+------------------+------+-----+-------------------+----------------+</span><br><span class="line">|<span class="string"> id          </span>|<span class="string"> int(11) unsigned </span>|<span class="string"> NO   </span>|<span class="string"> PRI </span>|<span class="string"> NULL              </span>|<span class="string"> auto_increment </span>|</span><br><span class="line">|<span class="string"> url         </span>|<span class="string"> varchar(255)     </span>|<span class="string"> NO   </span>|<span class="string">     </span>|<span class="string">                   </span>|<span class="string">                </span>|</span><br><span class="line">|<span class="string"> insert_time </span>|<span class="string"> timestamp        </span>|<span class="string"> NO   </span>|<span class="string">     </span>|<span class="string"> CURRENT_TIMESTAMP </span>|<span class="string">                </span>|</span><br><span class="line">|<span class="string"> tid         </span>|<span class="string"> bigint(20)       </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL              </span>|<span class="string">                </span>|</span><br><span class="line">+-------------+------------------+------+-----+-------------------+----------------+</span><br><span class="line">mysql&gt; select <span class="symbol">*</span> from urls;</span><br><span class="line">+----+-----------------------+---------------------+------+</span><br><span class="line">|<span class="string"> id </span>|<span class="string"> url                   </span>|<span class="string"> insert_time         </span>|<span class="string"> tid  </span>|</span><br><span class="line">+----+-----------------------+---------------------+------+</span><br><span class="line">|<span class="string">  1 </span>|<span class="string"> http://www.limoer.cc  </span>|<span class="string"> 0000-00-00 00:00:00 </span>|<span class="string"> NULL </span>|</span><br><span class="line">|<span class="string">  2 </span>|<span class="string"> http://baidu.com/news </span>|<span class="string"> 0000-00-00 00:00:00 </span>|<span class="string"> NULL </span>|</span><br><span class="line">|<span class="string">  3 </span>|<span class="string"> http://do.io          </span>|<span class="string"> 0000-00-00 00:00:00 </span>|<span class="string"> NULL </span>|</span><br><span class="line">|<span class="string">  5 </span>|<span class="string"> http://github.iod     </span>|<span class="string"> 0000-00-00 00:00:00 </span>|<span class="string"> NULL </span>|</span><br><span class="line">+----+-----------------------+---------------------+------+</span><br></pre></td></tr></table></figure>
<p>该表有4字段并且有4条记录，现在我们如果想要查询id=1的那条记录，应该这样写:<code>select * from urls where id=1</code>。执行该条语句，正确返回结果，现在我们修改一下这条语句，改成：<code>select * from urls where id=1 and 1=1</code>,执行这条语句，同样没问题，返回结果正常；我们接下来再把<code>and</code> 改成 <code>or</code>再执行，结果出乎我们的意料，我们把所有的记录都查询了出来，<code>id=1</code>的限定条件失效了。至于如何导致其失效，是因为<code>or</code>后面的条件1=1是恒等的，所以前面的限定条件已经不重要了，<code>and</code>也是如此，我们想要获取正确的结果，那么<code>and</code>后面的限定条件必须要正确才可以。</p>
<p>说到这里，其实我们就已经进行了一次SQL注入的攻击，并且窃取了数据库的所有记录(更严重的删库、窃取管理员密码也很easy)！</p>
<p>其实不光是上面演示到的使用<code>and or</code>来进行SQL注入，还有很多神奇的SQL语法让SQL注入有了可乘之机，例如我们常用的<code>union</code>等等。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>如果我们把上面情景放在实际开发过程中，我们可能现在有一个输入框，用户可以输入任意一个数据来查看某条记录，<br>服务端的SQL语句也许是这样的：<code>select * from urls where id=${userInput}</code>。如果某个淘气的用户不遵守约定输入了非数字，例如<code>10 or 1=1</code>，SQL语句拼接过后就成了这样:<code>select * from urls where id=10 or 1=1</code>，表中的信息一次被完全暴露！</p>
<p>针对上面的情况，我最想想到的不是转义输入也不是使用参数化查询，而是针对本问题，我们直接对其进行输入验证即可，既然其必须限定用户输入数字，那么在进行SQL拼接之前，对用户输入进行验证即可！</p>
<p>例如，在Node.js环境下，我们可以使用<code>parseInt(userInput)</code>就可以完成对用户输入进行强制性的验证。</p>
<p>第二种也就是最常用的解决办法就是转义，和防御XSS攻击一样，我们需要构建用于转义的函数，对用户的输入进行转义，还是上面的那个例子：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> urls <span class="keyword">where</span> <span class="symbol">`id`</span>= $&#123;id&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果用户输入<code>1 or 1=1</code>，那么毫无疑问将会导致一次非常严重的SQL注入攻击，现在假设我们已经写好了我们的转义函数escape，我们只需要在进行字符串拼接之前，做一次转义即可。 例如对于用户的输入<code>1 or 1=1</code>经过转义后变成了<code>&#39;1 or 1=1&#39;</code>，经过SQL拼接过后则变成了:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> urls <span class="keyword">where</span> <span class="symbol">`id`</span>=<span class="string">'1 or 1=1'</span>;</span><br></pre></td></tr></table></figure></p>
<p>不出意外，我们得到了正确的结果。</p>
<p>关于转义函数escape如何实现，这里就不不再多说，很多数据库的驱动工具都带有相应的工具函数，我们在实际开发过程中一定要注意对用户的输入进行转义，来避免SQL注入攻击；当然，如果你使用参数化查询的话，就完全没有必要了。</p>
<h3 id="参数化查询"><a href="#参数化查询" class="headerlink" title="参数化查询"></a>参数化查询</h3><p>最开始提到参数化查询的时候，我提到了<code>Prepared Statements</code>也就是预处理语句，其实我们可以把参数化查询理解为预处理，我们把完整的一次SQL查询分成两部分，第一步是预先查询，第二步使用参数得到结果。具体该怎么理解呢，还是接着上面的那个例子，现在我们使用参数化查询执行<code>select * from urls where id=1</code>。其分为两步，第一步执行<code>select * from urls where id=?</code>，注意这里的<code>?</code>，其实代表了未来将要传入的参数；第二步，传入用户的输入作为具体的id值，并且输出结果。这里要注意，因为执行完第一步的时候期待第二步传入的是一个用户的id(这里必须是数字)，这时候用户传入的非法输入就不会生效，这也就从根本上杜绝了了SQL注入攻击。</p>
<p>好了，参数化查询(预处理)可以完全避免SQL注入，其还有其他的优点例如更加可读(相比于字符串拼接)，多次查询性能会有提升(因为会对预处理语句进行缓存再利用)等。</p>
<p>说了这么多，那么如何使用参数化查询呢？很简单，使用一个支持该特性的数据库连接工具就可以了，比如我们下面要演示的Node环境下MySQL的参数化查询。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>我们在Node环境下进行演示，首先通过<code>npm install mysql2</code>命令安装数据库连接工具，这里是<code>mysql2</code>,能够支持参数化查询。</p>
<p>如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql2 = <span class="built_in">require</span>(<span class="string">'mysql2'</span>);</span><br><span class="line"><span class="keyword">const</span> conn = mysql2.createConnection(&#123;</span><br><span class="line">	host: <span class="string">'localhost'</span>,</span><br><span class="line">	user: <span class="string">'admin'</span>,</span><br><span class="line">	password: <span class="string">'123'</span>,</span><br><span class="line">	database: <span class="string">'news'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 不使用任何防护手段(将导致SQL注入攻击)</span></span><br><span class="line"><span class="keyword">const</span> userInput = <span class="string">'1 or 1=1'</span>;</span><br><span class="line">conn.query(</span><br><span class="line">	<span class="string">`select * from urls where id=<span class="subst">$&#123;userInput&#125;</span>`</span>,</span><br><span class="line">	(err, result) =&gt; &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(result);</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 使用转义(这里默认进行了转义)</span></span><br><span class="line">conn.query(</span><br><span class="line">	<span class="string">'select * from urls where `id`=?'</span>,</span><br><span class="line">	[<span class="string">'1 or 1=1'</span>], </span><br><span class="line">	(err, result) =&gt; &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(result);</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 使用参数化查询</span></span><br><span class="line">conn.execute(</span><br><span class="line">	<span class="string">'select * from urls where `id`=?'</span>, </span><br><span class="line">	[<span class="string">'1 or 1=1'</span>], </span><br><span class="line">	(err, result, fields) =&gt; &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(result);</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>关于SQL注入和参数化查询就介绍到这里，如果你觉得参数化查询两步走我说得并不明确，你可以使用抓包工具来加深理解；还有最后的Demo，其实query和execute的区别就是一个支持了参数化查询而另外一个不支持；如果你运行Demo，仔细看，区别就藏在里面(Tips：B &amp; T)；最后，请总是使用参数化查询！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[我的应聘经历(不断更新中...)]]></title>
      <url>http://yoursite.com/2017/09/20/%E6%88%91%E7%9A%84%E5%BA%94%E8%81%98%E7%BB%8F%E5%8E%86-%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
      <content type="html"><![CDATA[<blockquote>
<p>只有在写简历的时候才会明白，真后悔自己平凡的大学四年，没有拔尖的学习成绩、没有丰富的实践经历、也没有牛X的技术，对于大牛而言，自己就是简历收割机，而对于我而言…好吧，如果谁能看得上我，管吃管住就行！可是，时间没有倒带，不会从头再来/感慨。</p>
</blockquote>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><blockquote>
<p>从8月开始到如今一个多月过去了，简历虽不是海投但还是投了有数十家，除去没有参加笔试的，剩下通过笔试拿到面试的就更少了，接下来我好好回顾一下，算是一个小小的总结吧，虽然到目前还没有找到工作…</p>
</blockquote>
<h4 id="某测-通信测试行业"><a href="#某测-通信测试行业" class="headerlink" title="某测(通信测试行业)"></a>某测(通信测试行业)</h4><p>经历：</p>
<p>这是校招来学校宣讲的第一家企业，很小型的宣讲会，参会人数不多；在简单的介绍企业过后，就直接现场笔试。吐槽下笔试题，融合了C++/前端/智力测试的一张综合试卷，难度不大，我花15分钟做完了试卷上前端相关的试题就离开了，一个小时后就收到通知当天下午面试得通知。</p>
<p>面试(时间50分钟)：</p>
<p>面试也安排的特别简单，二面一，连自我介绍都没有(害得我准备好久…)。问题主要有以下几个：</p>
<ol>
<li>你了解通信测试行业吗？</li>
<li>你觉得本公司适合你吗？ 这里的时候我直接问了他几个问题然后做出判断，我们都觉得不适合</li>
<li>你期待的工作方式？ 构思以下结合公司实际谈了谈数据可视化</li>
<li>数据挖掘相关知识。 基本的分类、聚类算法，分词等。</li>
<li>给我的建议。 推荐我要有自己的想法，最好选择互联网公司，并且赞了我字写得比较好(谢谢！)。</li>
</ol>
<h4 id="某某网络-初创互联网公司"><a href="#某某网络-初创互联网公司" class="headerlink" title="某某网络(初创互联网公司)"></a>某某网络(初创互联网公司)</h4><p>经历：</p>
<p>来自于知乎大牛的推荐，一家自认为小而美的公司！投递简历差不多一个月才进行电话面试。面试时间也真是会挑，早上8点过就打来电话(幸好每天都早起！)，大概谈了超过一个小时，到目前为止仍然在等结果。</p>
<p>面试：</p>
<p>面试官大概是在上班路上给我打的电话，电话那头有点吵。面试流程也比较常规，自我介绍，介绍项目，目前在做的事，有关于React及其技术栈。当然还包括面试官对公司的介绍，要求我谈对公司发展的看法；后面又聊了前端开发的潮流；有关于SSR、SPA等。最后告诉了我他们公司前端开发团队的现状(规模很小！)，问我如何看待，特别是如何快速的融入和承担起相应的责任。</p>
<p>总结：</p>
<p>当了解了他们正在做的事情的时候，我觉得这就是我想要加入的公司。我喜欢小而美的公司！面试过程十分愉快，虽说是等通知但是都快一周了还是没有音讯，大概是挂了吧~</p>
<h4 id="某家网-卖房的？"><a href="#某家网-卖房的？" class="headerlink" title="某家网(卖房的？)"></a>某家网(卖房的？)</h4><p>经历：</p>
<p>就在中午临时决定去试一试，幸好赶上校车去了宣讲现场。宣讲过程中真的能够感受到这是一家非常了不起和大牛聚集的地方。宣讲完直接笔试，笔试后就等面试通知咯。晚上接到面试通知，第二天在某某咖啡馆参加了面试，最终是倒在终面前。</p>
<p>笔试：</p>
<p>难度四星，10题全算法，对于数据结构和算法没掌握好的同学就是煎熬，我花了一个半小时做完了自己会做的题目，然后还是错过了一家不错企业面试的机会/哭。</p>
<p>面试：</p>
<p>一面一上来就是自我介绍，随便问问。然后十题算法挨个回顾，并且面试官对每道题进行打分(自己得了好多零！)，然后一面结束，等通知。</p>
<p>二面已经是下午了，前端方向就我一个人，所以聊了比较久，一个半小时。面试过程中主要聊了：</p>
<ol>
<li>Java和JavaScript的特性(被我引入了我喜欢JS而不喜欢Java的怪圈…)</li>
<li>做过最酷的项目(介绍了一下正在开发的视频编辑器)</li>
<li>从架构角度谈某个数据平台(简历上提到)的建立和开发过程</li>
<li>如何做情感分析(数据挖掘方面)</li>
<li>提问环节</li>
</ol>
<p>吐槽：</p>
<p>在面完二面后又是等通知，十分钟后我去问通过了吗，然后HR小姐姐告诉了过了，等待三面，我当时的那颗心啊，真的高兴，以为自己就要进入这家感觉十分良好的企业了！结果过了几分钟，HR姐姐给我说我没过，然后这就尴尬了😓。总的来说，本次面试的体验还是不错的(主要是中午管饭了！)。</p>
<h4 id="某有-b2b"><a href="#某有-b2b" class="headerlink" title="某有(b2b)"></a>某有(b2b)</h4><p>经历：</p>
<p>很早很早就投了简历，并且做完测评等着来软件园宣讲。真的到了那一天去现场一看，人真的多！短暂的企业介绍后，就开始了笔试(分前端、Java、基础三套试卷)。结果由于弄错试卷做了前端、基础两套。试卷难度不大，但都是十分容易出错的地方。晚上收到通知，第二天面试。面试过程非常愉快，上午面完下午HR就打来电话说通过了，然后我说考虑一下，最终开始放弃了到手的offer(说好的就去第一家能看上你的公司呢！)，到现在好几天了，我有点后悔自己做的决定。</p>
<p>面试：</p>
<p>面试官应该是管理层，年龄40+，基本不问技术方面，谈谈项目，谈谈个人经历，再结合职业测评问问就完了。二面HR问了问家庭状况，是否考研，以及如何看待将要在工作中遇到的一些问题，后面又问道期待薪资(最大的败笔)，然后就结束了。</p>
<p>总结：后悔 X N!!!</p>
<h4 id="还有很多…但是…"><a href="#还有很多…但是…" class="headerlink" title="还有很多…但是…"></a>还有很多…但是…</h4><p>不知不觉半个月又过去了，期间不间断的参加过很多公司的招聘，但始终没能更进一步。有些时候晚上睡不着觉，就在想，到底是哪里出了问题，没抓住机遇？实力不够？表现不好？… 我不知道。</p>
<p>可是，就在今天，我暂时不用去为自己的将来而担忧，能够有时间去做自己想要去做的事，能够静下心来提升自己。所以，我愉快的做了决定，好比平时做决定那样–洒脱？。</p>
<p>我打电话通知了家人，以往不想让我离家太远的母亲也很高兴，至少无论他们口头上怎么反对我去外地工作，可真当找到工作后，无论在哪里，只有一如既往的支持。</p>
<p>我认为我就是一个平庸(凡？)的人，我每天会花时间在打游戏娱乐上，我也会时不时睡睡懒觉，天气冷了我可能更多的会宅在宿舍。</p>
<p>尾巴里面提到我不会错过第二家看上我的公司，但是我也食言了，可是我真的不会再错过这一个机会了。我准备好来年在人生的下一站，开启我的程序猿人生了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用react-transition-group实现路由切换动画]]></title>
      <url>http://yoursite.com/2017/09/01/%E4%BD%BF%E7%94%A8react-transition-group%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我们在使用React开发SPA的时候，使用<code>react-router</code>可以完成路由切换，但是这样路由切换是非常生硬的。有什么解决办法呢？我们可以使用<code>react-transition-group</code>来实现自定义的路由切换效果。</p>
</blockquote>
<p>需要注意的是<code>react-transition-group</code>目前有两个版本，v1和v2版本的差距十分巨大，本教程使用的是最新的V2版本，你可以使用<code>npm install --save react-transition-group</code>来安装，如果想安装v1版本，则只需使用<code>npm install --save react-transition-group@1.x</code>命令即可。</p>
<p>react-transition-group主要提供三个组件<code>Transition</code>、<code>TransitionGroup</code>、<code>CSSTransition</code>。从名字当中我们知道<code>TransitionGroup</code>作为一个容器组件，而其它两个组件才是实现动画的关键。这里我只介绍<code>CSSTransition</code>如何使用以及其注意的点。如需了解更多<code>react-transition-group</code>,请<a href="https://reactcommunity.org/react-transition-group/" target="_blank" rel="noopener">查看官方文档</a>。</p>
<h3 id="CSSTransition"><a href="#CSSTransition" class="headerlink" title="CSSTransition"></a>CSSTransition</h3><p>这个组件主要是使用css来控制组件的转场。它使用了在缓动中<code>appear</code>、<code>enter</code>、<code>exit</code>的三个状态，并且提供钩子类让我们自定义效果。</p>
<p>我们常用到的类有：</p>
<pre><code>.className-enter
.className-enter.className-enter-active
.className-exit
.className-exit.className-exit-active
</code></pre><p>这里<code>className</code>是你自定义动画的名称，和V1版本大体相同的钩子类，只不过把<code>leave</code>改成了更加语义化的<code>exit</code>，这里需要注意。</p>
<p>CSSTransition有多个十分重要的属性：</p>
<ol>
<li><code>classNames</code>属性接收一个字符串类名，注意这里是<code>classNames</code>而不是<code>className</code>。</li>
<li><code>timeout</code>用于规定动画执行的时间，如果<code>enter</code>和<code>exit</code>的持续时间相同的话可以使用<code>timeout={number}</code>即可，如果持续时间不一样，则<code>timeout</code>接收一个字典,两个键分别是enter和exit。</li>
<li>其他参数例如<code>onEnter</code>、<code>onExit</code>你可以自定义逻辑在动画进行到某个阶段后触发。</li>
<li>动画进行的阶段：<code>enter-&gt;entering-&gt;entered-&gt;exit-&gt;exiting-&gt;exited</code>。</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Route render=&#123;(&#123;location&#125;) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">                &lt;Route exact path="/" render=&#123;() =&gt; (</span><br><span class="line">                    &lt;Redirect to="/home"/&gt;</span><br><span class="line">                )&#125;/&gt;</span><br><span class="line">                &lt;TransitionGroup&gt;</span><br><span class="line">                    &lt;CSSTransition</span><br><span class="line">                        key=&#123;location.pathname.split('/')[1]&#125;</span><br><span class="line">                        classNames="transitionWrapper" // 这里一定要注意的是：classNames 而不是className</span><br><span class="line">                        timeout=&#123;400&#125;</span><br><span class="line">                        mountOnEnter=&#123;true&#125;</span><br><span class="line">                        unmountOnExit=&#123;true&#125;</span><br><span class="line">                    &gt;</span><br><span class="line">                        &lt;div className="wrapper"&gt;</span><br><span class="line">                            &lt;Switch location=&#123;location&#125;&gt;</span><br><span class="line">                                &lt;Route exact path="/home" component=&#123;Home&#125;/&gt;</span><br><span class="line">                                &lt;Route path="/inspiration" render=&#123;() =&gt;&lt;NavLink style=&#123;&#123;marginRight: '20px', marginLeft: '20px'&#125;&#125; to="/home"&gt;HOME&lt;/NavLink&gt;</span><br><span class="line">                                &#125;/&gt;</span><br><span class="line">                                &lt;Route path="/mood" render=&#123;() =&gt; &lt;h1&gt;this is page3 mood!&lt;/h1&gt;&#125;/&gt;</span><br><span class="line">                            &lt;/Switch&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/CSSTransition&gt;</span><br><span class="line">                &lt;/TransitionGroup&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &#125;&#125;/&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用antd和css-modules冲突的解决办法]]></title>
      <url>http://yoursite.com/2017/08/28/%E4%BD%BF%E7%94%A8antd%E5%92%8Ccss-modules%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在暑假做项目实训的时候前端就使用到React构建并且使用了<code>Ant Design</code>作为组件库，当时就使用了<code>extract-text-webpack-plugin</code>把css单独抽离出来成为一个单独的css文件并引入，当时就遇到一个问题，当我使用<code>css-loader</code>来处理css时，并不能处理自定义的css，但是我把CSS直接写进组件中是可行的，由于当时项目比较小并且时间比较赶，就直接使用了这种方式，在开发过程中也有苦说不清，但总算是完成了。</p>
</blockquote>
<blockquote>
<p>最近想写一点东西，又用到<code>antd</code>了，当然是相同的问题，只不过时过境迁，我有足够多的时间来处理这个遗留下来的问题。可是即使有那么多的时间，可是还是踩坑无数，最终还是完成了。相信遇到这个问题的并不止我一个人，这里就先记录下来，希望能对你有所帮助。</p>
</blockquote>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>经过查询和思考，解决这样的问题最好是单独处理<code>antd</code>CSS和自定义的CSS。好了问题解决办法已经很明显了，我们需要些两个不同的规则来出来css，就像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">	test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">	use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">		use: <span class="string">'css-loader'</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">	test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">	exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">	use: <span class="string">'css-loader'</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">	<span class="keyword">new</span> ExtractTextPlugin(<span class="string">'style.css'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>上面的代码我建立了两规则分别处理自定义css和antd 预定义css，我们可以正常的使用<code>import &#39;./style.css&#39;</code>的形式引入css，但是我们查看页面，并没有加载我们自定义的css。</p>
<p>好吧，既然这样再试试<code>css-modules</code>的方式算了，我们把第二个规则改成下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">	test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">	exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">	use: [</span><br><span class="line">		loader:<span class="string">'css-loader'</span>,</span><br><span class="line">		options: &#123;</span><br><span class="line">			modules: <span class="literal">true</span>,</span><br><span class="line">			localIndentName: <span class="string">'[local]--[hash:base64:5]'</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以通过<code>import style from &#39;./style.css&#39;</code>的形式引入自定义css，并且通过<code>style.className</code>的形式给元素设置类。这次倒好，直接build不成功了，我一气之下索性不搞了；为了继续捣鼓下去，我直接又把CSS写在组件中了，直到我要使用<code>react-transition-group</code>来做路由切换动画，不得不倒回来解决。这次比以往更加冷静，我仔细阅读了<code>extract-text-webpack-plugin</code>的readme过后，恍然大悟，原来我们可以在一个项目中使用多个<code>ExtractTextPlugin</code>实例来生成多个css文件！好了，这次还是通过两个规则处理css，并且构建两个css文件，一个是自定义的css，一个是antd css，问题迎刃而解，又可以开心的捣鼓了！</p>
<p>好了，show you the code!:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> extractANTDCSS = <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name]-antd.css'</span>);</span><br><span class="line"><span class="keyword">const</span> extractNormalCSS = <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name]-normal.css'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">module</span>:&#123;</span><br><span class="line">		rules: [</span><br><span class="line">			&#123;</span><br><span class="line">				test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">				include: <span class="regexp">/node_modules/</span>,</span><br><span class="line">				loader: extractANTDCSS.extract(&#123;</span><br><span class="line">					fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">					use: [&#123;</span><br><span class="line">						loader: <span class="string">'css-loader'</span>,</span><br><span class="line">						options: &#123;<span class="attr">modules</span>: <span class="literal">false</span>&#125;</span><br><span class="line">					&#125;]</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">				exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">				use: extractNormalCSS.extract(&#123;</span><br><span class="line">					fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">					use: [&#123;</span><br><span class="line">						loader: <span class="string">'css-loader'</span>,</span><br><span class="line">						options: &#123;</span><br><span class="line">							modules: <span class="literal">true</span>,</span><br><span class="line">							localIndentName: <span class="string">'[local]--[hash:base64:5]'</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;]</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		extractANTDCSS,</span><br><span class="line">		extractNormalCSS,</span><br><span class="line">		...</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上的两个loader会生成两个css文件，分别是<code>vendor-antd.css</code>和<code>main-normal.css</code>，我们只需要在正确的位置引入这两个css文件就好了！</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>我在前面提到我把CSS直接写在元素/组件的style标签中，其实这种方式实不可取的，它会让你在编码和代码review中苦不堪言，因为一旦项目变得很大，当你想修改某个样式的时候，花在定位CSS的时间是非常多的；并且，可读性和可复用性也会大打折扣；而且我们经常在写样式的过程中使用的各种选择器、伪类、伪元素都无法发挥其灵活的作用。所以，无论你是以何种方式写前端，请尽量不以这种方式写CSS。</p>
<p>当然，我们也要从性能上去考虑。因为css是在页面解析正式前就加载好了的(写在header)里面，在我们再解析页面的时候，加载速度就会变得更快；再有，如果我们使用把CSS写在组件中后，无可避免的会产生更多的重绘和回流，这会严重影响渲染性能。比如我们使用JS修改我们在style属性中标明的样式，那么必然会触发一次repaint。</p>
<p>好了，到此打住！如果你想学习reflow和repaint，点击<a href="http://blog.csdn.net/ClaireKe/article/details/51375622" target="_blank" rel="noopener">这里</a>，也许会帮助你！</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Three.js]]></title>
      <url>http://yoursite.com/2017/08/24/three-js/</url>
      <content type="html"><![CDATA[<p>最近貌似Node又有了新的fork ayo.js(怎么读！哎呦？)，加之前端一不留神就出框架的节奏，在2016年就开始用Next(wtf！你能看出来其是一个前端框架？)来命名，以后恐怕就得future.js、plus.js的节奏…贵圈真乱啊！</p>
<p>当然当然，这和我们今天的主角three.js并没有太大的关系，比起这些看了名字不知所云的xxx.js，Three.js这个就和明显了，其是一个3d JavaScript库，更准确的说是用JavaScript编写的WebGL三方库，那么什么是WebGL呢？这个我不解释，有兴趣的小伙伴可以去探索。</p>
<p>作为我最想学却一直学不会的技术之一，WebGL的确对于大部分的前端猿们来说有些复杂和繁琐了，早些时候我花了大量的时间去啃API，学习如何使用，可到目前脑子还是一团乱麻。既然这样的话，我们得另辟蹊径，不能因为有困难就放弃学习不是！所以我了解到了Three.js，其化繁为简，做同样的事，其只需要少于<code>1/5</code>的代码量就可以完成，并且API也十分通俗易懂，学习难度降低了不少，可以让我们关注使用WebGL创造而不是痛苦的学习和编码。</p>
<p>如果你还不理解WebGL是什么，这是官方文档上的原话：</p>
<blockquote>
<p>WebGL (Web Graphics Library) is a JavaScript API for rendering interactive 3D and 2D graphics within any compatible web browser without the use of plug-ins. WebGL does so by introducing an API that closely conforms to OpenGL ES 2.0 that can be used in HTML5 canvas elements.</p>
</blockquote>
<p>如果你对Three.js比较有兴趣的话可以直接进去<a href="https://threejs.org/" target="_blank" rel="noopener">官网</a>，其中首页展示了很多<code>featured projects</code>，个人比较喜欢这个<a href="https://paperplanes.world/" target="_blank" rel="noopener">Paper Planes</a>。</p>
<p>你也可以去<a href="https://github.com/mrdoob/three.js/" target="_blank" rel="noopener">gayhub</a>把Three.js代码download下来，里面有很多很多(大约几百个例子)可供学习，当然如果你想学习Three.js，来<a href="https://pan.baidu.com/s/1nvQJsUX" target="_blank" rel="noopener">百度云</a>下载，这是目前少有的全方面介绍Three.js的书籍。</p>
<p>好了，差不多介绍完该跑了。但是我好想发现了我竟然连副标题都没取，好吧，还是再多讲一会儿，为了彰显Three.js的简单易用的特性，我讲决定再写一个全面但是简单的例子，并且配上必要的讲解。</p>
<h4 id="例子？不存在的！"><a href="#例子？不存在的！" class="headerlink" title="例子？不存在的！"></a>例子？不存在的！</h4><p>这是一个很小的例子，它将会展示Three.js使用流程，并且是经过测试没有错误(也许有！)，请放心食用。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>使用Three.js<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./three.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"three-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">			<span class="comment">// three.js中有几个非常重要的知识点，为了构成一个3D程序，我们至少需要以下几部分。</span></span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 1. Scene 场景，用于承载一些必要元素</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 2. Camera 相机(此相机非你想的那个相机哦！)</span></span></span><br><span class="line"><span class="actionscript">			<span class="comment">// Three.js中提供了两种相机，透视相机和正交相机，这里使用的是透视相机(类似于人眼看到的)</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">60</span>, <span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerWidth, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="undefined">			camera.position.set(-20, 40, 20);</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 3. renderer 渲染器， 也可以在canvas中渲染，但是复杂场景可能有性能问题</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="undefined">			renderer.setClearColor(0x708090);</span></span><br><span class="line"><span class="javascript">			renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span></span><br><span class="line"><span class="actionscript">			renderer.shadowMapEnabled = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 4. 物体</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> cubegeo = <span class="keyword">new</span> THREE.CubeGeometry(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 5. 材质 用于物体表面，不同材质包含不同特性，可设置颜色等。</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line"><span class="undefined">				color: 0xffffff</span></span><br><span class="line"><span class="undefined">			&#125;);</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 组合物体与材质成为一个网格</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> cube = <span class="keyword">new</span> THREE.Mesh(cubegeo, material);</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 设置物体能够产生光源阴影</span></span></span><br><span class="line"><span class="actionscript">			cube.castShadow = <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">			scene.add(cube);</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 6. 光源 Three.js中存在多种光源</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> light = <span class="keyword">new</span> THREE.SpotLight(<span class="number">0xfffff</span>);</span></span><br><span class="line"><span class="undefined">			light.position.set(-30, 40, -20);</span></span><br><span class="line"><span class="actionscript">			light.castShadow = <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">			scene.add(light);</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 设置相机看向场景远点(空间坐标系原点)</span></span></span><br><span class="line"><span class="undefined">			camera.lookAt(scene.position);</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 添加到HTML中</span></span></span><br><span class="line"><span class="javascript">			<span class="built_in">document</span>.getElementById(<span class="string">'three-container'</span>).appendChild(renderer.domElement);</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 为了更加直观，这里设置一下空间坐标系</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> axes = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">30</span>);</span></span><br><span class="line"><span class="undefined">			scene.add(axes);</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 动起来吧！添加动画</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">animation</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">				<span class="comment">// 比如移动转动方块， 这里设置在x、y轴转动平面</span></span></span><br><span class="line"><span class="undefined">				cube.rotation.x += 0.1;</span></span><br><span class="line"><span class="undefined">				cube.rotation.y += 0.1;</span></span><br><span class="line"><span class="undefined">				requestAnimationFrame(animation);</span></span><br><span class="line"><span class="undefined">				renderer.render(scene, camera);</span></span><br><span class="line"><span class="undefined">			&#125;</span></span><br><span class="line"><span class="undefined">			requestAnimationFrame(animation);</span></span><br><span class="line"><span class="undefined">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h4><p>即使是这样一个简单的例子，我如今也没有办法在不参考官方文档的情况下一口气写下来，原因无非在于，虽然其简化了开发，但是概念还是偏多并且需要记住每个API也是在有难度。</p>
<p>但是，如果我们能够十分清楚的理解制作3D应用的流程，至少是使用Three.js的流程，按照流程十分有条理的写下去，代码总归是十分清晰的。</p>
<p><code>time waiting for no one</code>，这是我最近在看《穿越时空的少女》看到的。对啊，时间不等人，珍惜好为说不多的’自由’而’枯燥’的时间吧！</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从Decorator到Mobx]]></title>
      <url>http://yoursite.com/2017/08/02/%E4%BB%8Edecorator%E5%88%B0Mobx/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近在开发一款视频编辑器，其中就用到了Mobx作为状态管理工具。Mobx中很重要的概念例如可观察(observable)的状态，可计算(computed)的值都用到了decorator(当然在使用Mobx时可以不用)。Decorator作为ES7引入的新特性，用于给类/属性添加新行为。对于不少初学者而言，可能对其并不是很了解，所以在这里从装饰器开始，聊聊我对Decorator和Mobx的理解。如果你正在学习Mobx，希望能对你快速上手Mobx能有所帮助。</p>
</blockquote>
<h3 id="先说装饰器-Decorator"><a href="#先说装饰器-Decorator" class="headerlink" title="先说装饰器(Decorator)"></a>先说装饰器(Decorator)</h3><p>装饰器是ES7中引入的，其目的在于修改类/方法的行为。例如我们可以在不修改“类”的情况下为其增加新的功能。</p>
<p>例如：我们定义了一个学生“类”，其中有<code>name</code>，<code>age</code>两个属性，以及<code>showInfo</code>一个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	showInfo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, age: <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果此时我们想为这个类添加一个属性<code>school</code>用于标明学校，，在不修改“类”的情况下，我们可以使用装饰器这么做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSchool</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">	target.prototype.school = <span class="string">'SDU'</span>;</span><br><span class="line">&#125;</span><br><span class="line">@addId</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">//	...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	@decorator</span></span><br><span class="line"><span class="comment">	class A&#123;&#125;</span></span><br><span class="line"><span class="comment">	等价于</span></span><br><span class="line"><span class="comment">	A = decorator(A);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> limoer = <span class="keyword">new</span> Student(<span class="string">'limoer'</span>, <span class="number">21</span>);</span><br><span class="line"><span class="built_in">console</span>.log(limoer.school); <span class="comment">// &gt; SDU</span></span><br></pre></td></tr></table></figure>
<p>addSchool()给Student“类”的原型对象上添加了一个属性，现在所有实例都可以取到<code>school</code>这个属性。</p>
<p>更深入一步，上面看到用于装饰的函数只接收一个目标“类”作为参数，如果我们有多个参数的话，可以写成高阶函数的形式(即返回一个函数)。同样是上面的例子，现在学校由参数指定，我们可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSchool</span>(<span class="params">school_name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">		target.prototype.school = school_name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">@addSchool(<span class="string">'CQMU'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">//	...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lin = <span class="keyword">new</span> Student(<span class="string">'lin'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lin.school); <span class="comment">// &gt; CQMU</span></span><br></pre></td></tr></table></figure>
<p>装饰器不但可以装饰“类”，也可以对方法(…属性)进行修饰，使用的方式类似于对“类”的修饰，不过用于修饰的函数接收三个参数,<code>target</code>将要被修饰的对象, <code>name</code>被修饰的属性名, <code>descriptor</code>被修饰的属性的描述对象(ES5中详细介绍过)。 写一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCount</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> prev = descriptor.value;</span><br><span class="line">	descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'count:'</span> + StudentList.list.length);</span><br><span class="line">		prev.call(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> list = [<span class="string">'limoer'</span>, <span class="string">'lin'</span>];</span><br><span class="line"></span><br><span class="line">	@showCount</span><br><span class="line">	showNames () &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(StudentList.list.join(<span class="string">' '</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> StudentList();</span><br><span class="line">list.showNames(); <span class="comment">// count:2 \n limoer lin</span></span><br></pre></td></tr></table></figure>
<p>上面的代码给<code>StudentList</code>类的<code>showNames</code>方法添加了打印数量的功能，并且是在不改变原有“类”结构的情况下。</p>
<blockquote>
<p>说明，在现有的浏览器环境和Node都不能运行上面的代码(暂不支持装饰器)，如果想运行的话，可以借用babel 并且使用相关插件(babel-plugin-transform-decorators-legacy)的前提下进行compile，之后就可以进行了。推荐开发过程中webpack和babel结合使用，效果更佳！</p>
</blockquote>
<p>好了，关于Decorator简单介绍到此到一段落，更多的相关知识请自行发掘和学习。接下来，是时候了解并使用Mobx了！</p>
<h3 id="Mobx？想说爱你不容易！"><a href="#Mobx？想说爱你不容易！" class="headerlink" title="Mobx？想说爱你不容易！"></a>Mobx？想说爱你不容易！</h3><p>在文章最开头谈到我在最近的学习开发中使用了Mobx作为状态管理工具，最主要的原因是其相比Redux，学习和快速上手成本的确消了很多，并且它足够简单。但是在后来的开发过程中，虽然其可以没有redux中action，也不存在reducer，更是告别了单一而庞大的store，我们可以定义多个state用于保存状态，让每个状态或者是每个类属性添加注解，让其编程可观察的状态，而为了能够自动的更新值，我们可以通过使用computed这个装饰器或者autorun函数来完成。可是，在使用过程中，定义多少个状态，每个状态的结构又是如何，等等等等，都困扰着我，远没有使用redux来得清晰和直观。这也许是因为我对mobx目前刚好达到基本使用的程度，并没有深入的了解。基于此，接下来，我只谈谈Mobx入门，至于该如何优雅的使用，请自行摸索。</p>
<h4 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h4><ol>
<li>可观察的状态</li>
</ol>
<p>这也许是Mobx最基础也是最重要的概念了。我们可以使用Mobx提供的<code>observable</code>装饰器，让基本的数据结构(数组、对象、原始值等)变成可观察的。使用的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> TimeState = observable(&#123;</span><br><span class="line">	currentTime: <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;)</span><br><span class="line">TimeState.set(<span class="string">"currentTime"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().toString());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppState</span> </span>&#123;</span><br><span class="line">	@observable list = [<span class="string">'limoer'</span>, <span class="string">'lin'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> state = <span class="keyword">new</span> AppState();</span><br><span class="line"><span class="built_in">console</span>.log(state.list.length); <span class="comment">// &gt; 2</span></span><br></pre></td></tr></table></figure>
<p>好了，最简单的例子就是这样，我们使用ES5和ES6 decorator的方式分别创建了两个state，第一个state我们适应装饰器让一个对象(Map)变得可观察，而第二个我们则是对一个“类”属性(为一个数组)进行了修饰，让其变成可观察的。</p>
<p>这里值得注意的是，如果一个数据结构变得可观察，那么其类型也会发生改变，例如我们让一个数据变得可观察，此时其已经变成了一个 <code>Observable Array</code>， 这是一种Mobx定义的数据结构，拥有其独特的API，此时使用<code>Array.isArray(state.list)</code>讲返回false，因为<code>Observable Array</code> 并不是一种数组类型。</p>
<p>好了，当看到这里，你是否有这样一个疑问：让一个数据结构变得可观察，其作用到底在哪里呢？其实很简单，我们都知道Mobx是React的小伙伴，其目的是在于替换React本身的<code>state</code>，我们都知道对于React而言，如果一旦state发生改变，就将导致页面更新并且重新渲染，基于此，让数据结构变得可观察，其目的是在于当被观察的数据发生改变，React也能做出相应的更新和重绘操作等，并且，这样的重绘是经过Mobx优化的，只进行必要的重绘来增加性能！</p>
<ol start="2">
<li>可计算值</li>
</ol>
<p>可计算值是通过现有状态和其它可计算值派生出来的值。这很好理解，我们在使用React的时候，往往要通过state衍生出很多的值，例如如果state的一部分是一个数组，那么我们通过衍生得到的数组长度就是一个计算值，并且在Mobx中，一旦可观察的state或者其他computed value 发生改变，可计算值就会重新计算。其实，在实际的React项目中，我们在很多地方都使用到了计算值。</p>
<p>还是上面<code>AppState</code>的例子，现在我们给其增加一个计算值，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppState</span> </span>&#123;</span><br><span class="line">	@observable list = [<span class="string">'limoer'</span>, <span class="string">'lin'</span>];</span><br><span class="line">	@computed get count() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.list.length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> state = <span class="keyword">new</span> AppState();</span><br><span class="line"><span class="built_in">console</span>.log(state.count); <span class="comment">// &gt; 2</span></span><br><span class="line">state.list.push(<span class="string">'lindo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(state.count); <span class="comment">// &gt; 3</span></span><br></pre></td></tr></table></figure>
<p><code>count</code>是一个计算值，一旦list发生变化，其就会自动重新计算，可以保证，<code>count</code>的值每次都是最新的，并且都是等于list数组的长度。</p>
<ol start="3">
<li>autorun</li>
</ol>
<p>其作用和函数名一样好理解，其会自动执行；<code>autorun</code>其本身是一个响应式函数，其使用到的依赖关系state/computed value等一旦发生改变，其就会自动执行一次，效果和计算值类似，但是计算值和<code>autorun</code>的应用场景是不一样的，<code>computed value</code>通常会产生一个新值而<code>autorun</code>达到某种目的而不产生新值，例如生成日志，处理网络请求等。<br>还是上面的例子，我们继续扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppState</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...省略前面的代码</span></span><br><span class="line">	<span class="keyword">let</span> logcount = autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'count: '</span> + <span class="keyword">this</span>.count)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在<code>autorun</code>中使用了<code>computed value</code>， 一旦发生<code>count</code>改变，就会自动打印出新的<code>count</code>值；当然，初始化state实例对象的时候，就会先执行一次。</p>
<ol start="4">
<li>action</li>
</ol>
<p>动作是用来修改状态的。并且只应该对修改状态的函数使用<code>action</code>，要使用动作很简单，使用<code>@action</code>修饰一个函数或者使用<code>action(fn)</code>，把要修饰的函数作为参数即可。继续上面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppState</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略上面的代码</span></span><br><span class="line">	@action.bound</span><br><span class="line">	addOne(name) &#123;</span><br><span class="line">		<span class="keyword">this</span>.list.push(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 或者</span></span><br><span class="line">	@action</span><br><span class="line">	addOne = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.list.push(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们定义了一个函数，用于向列表中添加一个姓名。请注意，ES6 class的写法无法自动绑定到对象，所以使用<a href="mailto:`@action.bound" target="_blank" rel="noopener">`@action.bound</a>` 或者是使用ES6中引入的箭头函数(推荐)。</p>
<h4 id="与React使用"><a href="#与React使用" class="headerlink" title="与React使用"></a>与React使用</h4><ol start="5">
<li>observer<br><code>observer</code>是由<code>mobx-react</code>包(需独立安装)提供的用于让组件变成响应式组件的decorator。官方文档中写到：它用 <code>mobx.autorun</code> 包装了组件的 <code>render</code> 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="comment">// 其余依赖省略</span></span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	addUser = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">		e.preventDefault();</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.uname.value)&#123;</span><br><span class="line">			<span class="keyword">this</span>.props.appstate.addOne(<span class="keyword">this</span>.uname.value);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'must input user name!'</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">			&lt;ul&gt;</span><br><span class="line">				&#123;</span><br><span class="line">					this.props.appstate.list.map((index, name) =&gt; &#123;</span><br><span class="line">						return &lt;li key=&#123;index + 10&#125;&gt;&#123;name&#125;&lt;/li&gt;</span><br><span class="line">					&#125;)</span><br><span class="line">				&#125;</span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;p&gt;当前用户人数：&#123;this.props.appstate.count&#125;&lt;/p&gt;</span><br><span class="line">				&lt;label for="uname"&gt;姓名&lt;/label&gt;</span><br><span class="line">				&lt;input type="text" name="uname" ref=&#123;(ref) =&gt; this.uname = ref&#125;/&gt;</span><br><span class="line">				&lt;button onClick=&#123;this.addUser&#125;&gt;+&lt;/button&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">render(&lt;NameList appstate=&#123;appstate&#125; /&gt;, document.getElementById('app'));</span><br></pre></td></tr></table></figure>
<p>上面是一个响应式组件的例子，结合了上面定义的状态，我们可以查看所有的姓名、数量，并且可以通过点击按钮来改变state。其实<code>observer</code>对非响应式组件仍然有效，同样是上面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> List = observer(<span class="function">(<span class="params">&#123;appstate&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">		appstate.list.map((index, name) =&gt; &#123;</span></span><br><span class="line"><span class="xml">			return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index</span> + <span class="attr">19</span>&#125;&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">		&#125;)</span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>好了，对于<code>observer</code>的介绍就告一段落，更多的Mobx和React连接的方式，以及Mobx提供的生命钩子函数等相关知识你可以查看官方文档来了解。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><blockquote>
<p>自从放了暑假回了家，效率下降特别多，在学校的时候以为回家可以安心学习，到了家才知道一切都变了，该做的事情还没做，还有更多的知识要学习。所以，早早回学校也许是一个不错的选择！所以再过几天，就要启程回学校了，在最后一年里，期待所有的努力都没有白费，期待一个新(好)的开始！</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[响应式布局的那些事]]></title>
      <url>http://yoursite.com/2017/07/31/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>响应式设计在如今的web开发过程中已经是必不可少，它可以针对不同的设备环境对页面进行调整，并且可以在PC端和移动端达到很好效果的情况下，不用开发多套页面，可以提升开发速度，可维护性打打增强。</p>
</blockquote>
<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>响应式布局的一种实现方式的原理是使用CSS3新引入的Media Query来调整元素在不同分辨率下的显示效果，并且通过JavaScript进行交互。总结起来，响应式布局有以下几个需要注意的点：</p>
<ol>
<li>设置Viewport</li>
</ol>
<p>我们知道，在移动设备中，页面被放置在虚拟的窗口中，这个窗口也称作视口(Viewport),对于未进行移动端适配或者是未进行响应式设计的页面，往往页面的宽高都会大于移动设备的宽高，所以为了能够在移动设备上进行页面交互，缩放是不可避免的，但是频繁的放大缩小带来的浏览体验肯定不会好。所以，在响应式设计的第一步，就是要禁止移动设备的缩放，这很容易实现，我们只需要在html页面中的head元素下添加一个meta标签用于规定禁止缩放就可以了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, user-scalable=no, maxinum-scale=1.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用Media Query</li>
</ol>
<p>媒介查询才是响应式布局的关键所在，我们使用Media Query 来实现在不同尺寸下使用不同的样式。Media Query的规则有很多，例如<code>@media screen and (max-width: 980px){...}</code>就表示了在980px下的屏幕下使用在此定义的各种样式，同样还有<code>min-width</code>、<code>orientation(设备方向)</code>等属性，我们需要按需进行设置。</p>
<ol start="3">
<li>使用JavaScript</li>
</ol>
<p>如果能做到上面的两点，在一般情况下，响应式布局是可以实现的。但是如果在布局的过程中需要改变交互，那么JavaScript久必须派上用场了。例如一个菜单栏，在十分小的屏幕下需要折叠，那么就需要用到JavaScript。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>上面是我能够想到的响应式布局的一些要点，在实际学习过程中，我并没有在一些项目中使用相应式设计的方式(貌似很悲哀…)。在目前移动为先的时代，为移动端做更好的优化是不可避免的，无论是使用重新写一套移动端页面，还是使用响应式布局，或者使用其他的例如Flex Box来进行布局。作为一个工作在浏览器端的🐒，这都是我们必须具备的素质。</p>
<p>好了，写一个简单的小例子吧。如果你从未接触过响应式布局，那么希望接下来的code会帮助你更快地了解并应用它。</p>
<p>我们来写一个菜单栏，其HTML结构‍如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"nav-list"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">id</span>=<span class="string">"home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">id</span>=<span class="string">"topic"</span>&gt;</span>Topic<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">id</span>=<span class="string">"today"</span>&gt;</span>Today<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">id</span>=<span class="string">"about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">id</span>=<span class="string">"concat"</span>&gt;</span>Concat<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#nav</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#nav-list</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">	<span class="attribute">list-style</span>: none;</span><br><span class="line">	<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav-list</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">text-decoration</span>: none;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#FFF</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">4em</span>;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">1.4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#nav-list</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#bcbcbc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#nav-list</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/*添加背景色*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#nav-list</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(188, 188, 188, .8);</span><br><span class="line">	<span class="comment">/*添加鼠标移上去的样式*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#nav-list</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">''</span></span><br><span class="line">	<span class="comment">/*使用伪类来添加图标字体等*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们来为屏幕宽度小于768px写一个样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">768px</span>) &#123;</span><br><span class="line">	<span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">		<span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">		<span class="attribute">line-height</span>: <span class="number">60px</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">		<span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		上面的的样式指明了再768px宽度及以下，我们设置a标签的font-size为0，不显示字体。</span></span><br><span class="line"><span class="comment">		设置伪元素所在的图标字体的行高等于a标签的宽度，使其垂直居中。</span></span><br><span class="line"><span class="comment">		通过上面的简单设置，我们在小于768px跨度的屏幕下，对于该菜单就只能看到图标了。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，我们可以为更窄的屏幕设置折叠菜单，我们通过css来绘制折菜单，使用JS来显示和隐藏。具体的实现这里就不贴出来了。</p>
<p>ok，到此为止，我们已经写好了一个响应式菜单栏了(虽然…)。</p>
]]></content>
      
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[孩子]]></title>
      <url>http://yoursite.com/2017/07/25/%E5%AD%A9%E5%AD%90/</url>
      <content type="html"><![CDATA[<blockquote>
<p>对于大多数家庭来说，孩子就是未来、是未来的希望和精神寄托；我们的父母总是不予余力的帮助我们的成长；可是当一个孩子成为家庭的负担呢？看看下面这个家庭的故事(这是一个真实的故事)。</p>
</blockquote>
<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>2017年7月23日，我从济南出发回家“享受”也许是学生时代的最后一个暑假，同往常的匆忙不一样，这一次来到火车站才离火车发车还有1小时，一切都有条不紊的进行，取票、进站、候车…除了在检票的时候闸机不能识别我的车票外、上车、找到座位、驶离济南。故事当然发生在火车上，我的邻座–一位高大的面黄精瘦的头花花白的中年妇女。</p>
<p>为了度过12小时的车程，我一般会准备两部电影用于消遣，食物则是两瓶纯水一个大面包和少许便捷的水果。和往常一样，我在整一上午的时间看完了一部电影，此时已经到了午饭点，火车上的人都开始拿起自己带的食物开始吃起来。我从我的书包拿出大面包，开始啃起来，对两口面包一口水的节奏。我邻座的那位中年妇女也吃面包，可是连水都不要，对，也许她就没带水。出于此，我把书包里剩下的一瓶水给了她，她起先推诿不好意思接受，后来我告诉她我还有她才收下。后来的一段时间，我们有过一段时间的交流，而这故事就包含在短暂的交流中。</p>
<h3 id="侧脸"><a href="#侧脸" class="headerlink" title="侧脸"></a>侧脸</h3><p>经过短暂的聊天，我知道了她来自湖北恩施州，地地道道的农民，来到济南照顾自己生病的孩子。一开始，我并没有问她孩子的具体情况。我打量着她，个头估摸着超过175CM，而身体廋弱得像竹竿，估摸着和自己父母相近的年龄，头发却花白。一眼望过去，正好是侧脸，廋高的颧骨、满脸的雀斑、偏黑的肤色，哇，是经历过怎样事情的人才会在这样的年龄变成这样一个样子。</p>
<p>这个时候，她打了一个电话，我一直在旁听她说话，可是方言的确让人很难懂，唯一知道的就是打给她女儿的。时间很短，更多的像是嘱咐，她挂了电话。看我一副饶有兴致的样子，她给我讲了她打给的是自己的13岁女儿，正在济南住院治疗。她随后的话让我觉得十分震惊：女儿从5岁开始开始患病治疗，直到现在已经治疗了8年，得的是世界罕见的baihua病(这里真的记不住了，根据她的病情描述大概是一种血液病)，中国第一例！8年花掉了超过100万元。如今女孩病情恶化，医院不再收取任何费用，开始进行实验性治疗。她每一个月济南待半个月，回家半个月，连往返车费都是医院帮忙。说完这些，我分明看到她眼角产生着泪花。其实此时不仅仅是我对此时感兴趣，旁边前后排的都有在关注她说的，有人问她这么些年有没有得到社会帮助，她说当地电视台报道了这件事，收到了部分爱心捐助，但是绝大部分的治疗费用还是自己承担。还有人问为什么选择在济南治疗，她说只有那个主治医生能够稍微有效，所以那个医生在哪她们就跟着去哪。当然，还有其他问题，她都一一述说。期间她给我们看了她小孩的照片，看起来就像那种天生聪慧的孩子，可是因为病情没有上过学，不然这个年龄应该是一名初中生了吧。</p>
<p>这样的聊天持续到直到所有发问的人都沉默不语，恰好也快到她下车的站点了。我给她说，我在济南上学，我给她留个电话，如果需要任何我帮忙的，打电话给我。她匆匆忙忙的存下我的号码，拖着好大的行李箱，下车了。那拖着行李箱的背影，突然让我想起了我的母亲(/哭)。</p>
<h3 id="每个人的母亲和作为孩子的我们"><a href="#每个人的母亲和作为孩子的我们" class="headerlink" title="每个人的母亲和作为孩子的我们"></a>每个人的母亲和作为孩子的我们</h3><p>在接下来3个小时的剩余车程中，我回想了我和母亲的一切回忆，由近及远。早上上车时，远在千里之外的母亲挂念着自己的儿子是否能够乘上火车；回家前一天，又千叮呤万嘱咐一定要带够食物；在学校的每个星期，短暂的通话过程中的叮嘱…还有最初母亲反对我去北方读书，送别抹眼泪的情景也是历历在目。时间一晃，那么些年过去了，母亲越来越老，我越来越成熟；母亲越来越唠叨，我越发能够理解。想起小时候，经常和母亲吵架，甚至伤了母亲的心。到后来高中远离父母，到大学更是相隔千里，见到她的时间从一年几次到现在一年一次，从以前因不想见到母亲想要离家出走，到现在即使回到家乡想见母亲一面，母亲却说，太远太热太折腾坚决不让我来。这就是我的母亲，而我是母亲的孩子。</p>
<p>我是从我家乡中为数不多走出的大学生，这一点让母亲十分骄傲。当别人问起孩子，母亲总会告诉他们孩子在XX大学上学，可能对大部分家乡人来说，XX大学如何，985，211这些是什么，他们都不在意，也不知道其中的含义。作为孩子的自己，我有幸能够在这样一个家庭中长大，虽然家庭不算特别贫苦，但是所有的环境都是父母通过自己的劳动带来的。我敬佩我的父母，也期待能早日独挡一面。从小到大，我的事情都是由我做主，大到选择大学选择专业，小到家庭琐事，父母从不干涉的我的决定，最多就是提提建议，并且从任何方面支持我。前段时间我放弃了去企业实习的机会，选择留在学校补修课程等待秋招，父母第一时间支持我，这让我很感动。我想，还有什么理由不努力呢！</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>记得很多个第一次，但是最有感触的莫非第一次在济南生病，母亲得知我生病的消息从早到晚都很焦虑，反而自己生病了。后来的几年，我很少生病，但是只要我生病，我就会去第一时间就医，并且不告诉母亲。到此结束，共勉！</p>
]]></content>
      
        
        <tags>
            
            <tag> 心灵记事 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Demo--Canvas with React]]></title>
      <url>http://yoursite.com/2017/05/27/Demo-Canvas-with-React/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一个使用Canvas处理图片的Demo，使用React + webpack + Redux 的技术栈，非常适合初学者，希望你喜欢！</p>
</blockquote>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>学习canvas已经有一阵子了，忙完了计组课设，考完了数据挖掘，终于有时间来做一点小Demo来巩固自己所学的知识了。就像上面介绍的那样，这是一个使用Canvas进行图片处理的Demo，其可以选择本地图片，改变其R G B 以及透明度，然后可以选择保存到本地。并且为了重温很久没碰的React，前端使用了React，使用Redux进行数据的管理(虽然简单到没必要使用),并且使用了css modules 以便直接在组件中使用css。当然这一切都是在使用webpack进行编译打包的情况下。</p>
<p>这个Demo十分简单，特别适合React初学者食用，相信会对你的React学习有所帮助！</p>
<h3 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h3><ol>
<li>从我的<a href="https://github.com/xiaomoer/sample-canvas-with-react" target="_blank" rel="noopener">github</a>上clone到本地;</li>
<li>进入Demo根目录, 执行npm init 安装依赖;</li>
<li>安装完毕后，执行 npm run build 进行构建;</li>
<li>在Chrome浏览器(下载功能只能在Chrome中使用，所以…)中打开index.html。</li>
</ol>
<p>至此，你可以体验这个简单的Demo了。</p>
<h3 id="像什么"><a href="#像什么" class="headerlink" title="像什么"></a>像什么</h3><p>如果你觉得在你的机器上run很麻烦，或者你只是想看看长得怎么样。</p>
<p>在浏览器器中打开，是这个样子的：</p>
<p><img src="http://olro3ke8a.bkt.clouddn.com/init.png" alt="初始化效果"></p>
<p>我承认的确很简单，简单到显得简陋了！接下来你可以选左下角的选择文件按钮来选择任何一张图片，比如我选择了一张图片后:</p>
<p><img src="http://olro3ke8a.bkt.clouddn.com/init_pic.png" alt="初始化图片"></p>
<p>任何被选中的图片都会被居中显示，宽高都会适应600*400的图片操作区域。现在，可以对图片进行操作了：</p>
<p><img src="http://olro3ke8a.bkt.clouddn.com/after.png" alt="处理后"></p>
<p>我们选择对图片的R、G、B、以及透明度进行调整，实时调整的效果将会在左侧的图片区域实时显示出来。</p>
<p>第四步，点击图片区下的按钮，就可以吧处理过的图片下载到本地了，我们打开下载后的图片和处理的图片进行对比，就像这样：<br><img src="http://olro3ke8a.bkt.clouddn.com/save.png" alt="保存与对比"></p>
<p>至此，我已经演示完了所有的功能。</p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>如果你细心一点的话，你会发现这个Demo还有很多问题：</p>
<ol>
<li>我们导入任何宽高的图片，其都会被自适应到框中，所以处理后的图片品质会下降。</li>
<li>保存图片只能在Chrome浏览器中进行，已测试在Firfox中无法使用这个功能。</li>
<li>右侧的工具栏在选择新图片后不会被初始化。</li>
<li>功能单一。</li>
<li>界面简陋</li>
<li>…</li>
</ol>
<h3 id="你需要注意的是"><a href="#你需要注意的是" class="headerlink" title="你需要注意的是"></a>你需要注意的是</h3><p>如果你想学习React和canvas，那么我希望我的这个Demo会对你有所帮助，这里提几个需要注意的点，这些点也是我在开发过程中遇到的问题：</p>
<ol>
<li>如何使用input file来选择一张图片并绘制到canvas中。</li>
<li>如何保存图片。</li>
<li>图片在React中绘制的时机。</li>
<li>如何使用redux进行数据管理，特别是如何使用带参数的action。</li>
<li>你所关注的。</li>
</ol>
<h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>这虽然是一个很简单的Demo，但是我会在此基础上进行继续跟进，现在能想到的是解决上面提到的不足，比如设置两种模式，处理图片品质下降的问题；兼容主流浏览器；增添新功能；修改工具栏的状态初始化的bug；以及其它我以后能够想到并且我能够实现的。</p>
<p>以及…我目前有想法开发一个可交互的视频编辑器，有兴趣的同学可以关注下咯！</p>
<h3 id="写到后面"><a href="#写到后面" class="headerlink" title="写到后面"></a>写到后面</h3><p>还有不到3个小时我就21岁了，想想前面走过的20年，尤其是上大学的三年来，感慨颇多。谢天谢地，就算无论如何，我都完好无损的度过了。接下来的一岁中，我将面临人生中一个个重大的转折点，实习、毕业、工作、走向社会。从小到大，我对我所有的事情做出选择，接下来，也不例外。我做好准备了，并且一直在准备着！</p>
<p>共勉！</p>
<h3 id="新！"><a href="#新！" class="headerlink" title="新！"></a>新！</h3><p>5.28日 </p>
<ol>
<li>解决了再次选择图片工具栏初始化的问题；</li>
<li>工具栏的调节精度下沉到0.01；</li>
<li>修改页面细节。</li>
</ol>
<p>现在看起来长这样！<br><img src="http://olro3ke8a.bkt.clouddn.com/new.png" alt="新的页面"></p>
<p>6.3日</p>
<ol>
<li>同样的功能，不同的界面和实现方式，采用react但是去除redux使用state进行状态管理；</li>
<li>操作更加主流和人性化；</li>
<li>已知BUG，下载某些图片的时候可能会失败，暂不知原因。</li>
</ol>
<p>新版地址：<a href="https://github.com/xiaomoer/picture-editor-with-canvas" target="_blank" rel="noopener">https://github.com/xiaomoer/picture-editor-with-canvas</a></p>
<p>看起来是这样的：<br><img src="http://olro3ke8a.bkt.clouddn.com/%E5%88%9D%E5%A7%8B%E6%95%88%E6%9E%9C.png" alt=""><br>还有这样：<br><img src="http://olro3ke8a.bkt.clouddn.com/style.png" alt=""></p>
<p>加油！</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识 requestAnimationFrame]]></title>
      <url>http://yoursite.com/2017/05/12/%E5%88%9D%E8%AF%86-requestAnimationFrame/</url>
      <content type="html"><![CDATA[<blockquote>
<p>事情的起因是这样的，前段时间面试的时候面试官问我会canvas不，作为一名未来的前端猿，我只有过一点了解，后来居然收到了offer，当然在闲暇之余是要学习一下canvas，并且在学习过程中首次接触到了本文的主角<code>requestAnimationFrame</code>。</p>
</blockquote>
<h3 id="web中实现动画"><a href="#web中实现动画" class="headerlink" title="web中实现动画"></a>web中实现动画</h3><p>老实说，如果有人问我如何在web开发中实现动画，我第一时间想到的就是使用定时器<code>setTimeout()</code>或者<code>setTimeInterval()</code>来实现。其实实现的方式远远不止这一种，在CSS3的时代，我们实现动画有了更多的选择，比如使用关键帧动画，使用<code>transition</code>，我们也可以在<code>canvas</code>上绘图来实现动画；当然，还有<code>requestAnimationFrame</code>。</p>
<p>使用<code>setTimeout()/setInterval()</code>实现的方式很简单，我前面有一篇文章就简要介绍了JS中的定时器。使用这种方式实现动画其实是有其性能瓶颈的，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    setTimeout(animation, <span class="number">1000</span>/<span class="number">60</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们以60帧/秒的速度执行动画，但是如果浏览器不是60帧/秒，就会掉帧；并且由于JS单线程的特点，所有不能保证每一次执行回调都是<code>1000/60</code>毫秒；还有，当窗口处于非激活状态的时候，它同样可能会执行。</p>
<p>其实很好理解，作为定时器，<code>setTimeout/setInterval</code>并不是专门做动画的，存在各种各样的问题也是很好接受的，但是当我们认识到这种实现动画的方式的各种缺点时，我们也许会考虑另一种动画的实现方式，而<code>requestAnimationFrame</code>是一种更好的方案。</p>
<h3 id="初识-requestAnimationFrame"><a href="#初识-requestAnimationFrame" class="headerlink" title="初识 requestAnimationFrame"></a>初识 requestAnimationFrame</h3><blockquote>
<p>当我们执行window.requestAnimationFrame(callback)的时候，浏览器会在下次重绘的时候执行回调函数，它会告诉浏览器马上就要执行动画了，而callback则是用于更新动画。</p>
</blockquote>
<p><code>requestAnimationFrame</code>使用起来很简单，通过递归不断来执行回调来更新画面从而让画面动起来，我们甚至不需为其指定动画执行的时间和帧率。其优点是：1）从名字上就可以看出这是一个专门用于实现动画的API，优化是自然少不了的；2）其如果处于非激活状态，会自动暂停执行，有效节省了CPU资源。</p>
<h3 id="小实例"><a href="#小实例" class="headerlink" title="小实例"></a>小实例</h3><p>我们在做动画的时候，有时希望背景移动起来，结合目前正在学习的canvas，我们可以很轻易的做到这点.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> image = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveBackground</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  ctx.translate(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">  ctx.drawImage(image, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  j++;</span><br><span class="line">  <span class="keyword">if</span>(j &lt; <span class="number">20</span>)&#123;</span><br><span class="line">    requestAnimationFrame(moveBackground);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> moveBtn  = <span class="built_in">document</span>.getElementById(<span class="string">'move'</span>);</span><br><span class="line">moveBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  requestAnimationFrame(moveBackground);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们点击button的时候，开始执行动画，通过不断的坐标变换和清除重绘，达到背景图片向右移的效果。</p>
<p>最后，请注意，不是所有浏览器都支持该方法，所以你可能需要一个polyfill，关于如何实现这个polyfill，网络上的资源比较多了，这里就不在赘述。</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实用的JavaScript技巧、经验总结]]></title>
      <url>http://yoursite.com/2017/04/21/%E5%AE%9E%E7%94%A8%E7%9A%84JavaScript%E6%8A%80%E5%B7%A7%E3%80%81%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<ol>
<li><p>避免给一个未申明变量赋值，因为这会直接创建一个全局变量。</p>
</li>
<li><p>总是使用 ‘===’ 而不是 ‘==’，’===’会直接比较，而’==’必要时会进行类型转换等造成错误。</p>
</li>
<li><p>使用typeof instanceof 应当小心。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="keyword">instanceof</span> A <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> A() <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>arguments 对象转换成一个数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.ptototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">arguments</span>) <span class="comment">//ES6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>验证一个参数是否是数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.toString.call(a) === <span class="string">'[object Array]'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取得一个数组中最大值与最小值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"><span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用splice删除数组中某一个/一些元素，而不是使用delete，如果使用delete的话，相当于只是把原值变为undefined</p>
</li>
<li><p>使用for .. of来遍历数组，使用for .. in 要避免遍历到原型上面的可枚举属性，使用hasOwnProperty()来检测</p>
</li>
<li><p>不要扩展Object.prototype，因为这会给所有(?)对象增加属性/方法，从而产生很多意想不到的行为和错误！</p>
</li>
<li><p>对于一个构造函数，总是使用 new进行构造函数调用，否则默认返回空(对象)。</p>
</li>
<li><p>arguments.callee() 可执行当前函数，不推荐使用。</p>
</li>
<li><p>认识 ‘+’运算符， 对于对象而言，会转换成字符串，对于其他运算符则会尝试转成数字。</p>
</li>
<li><p>在使用if语句是，如果需要在条件中赋值，需要加上括号：<br><code>`</code>javascript<br>if((x = y)){<br>// do something<br>}<br>并且结果是否为真取决于y的真假。</p>
</li>
<li><p>判断一个数是否为NAN使用 x !== x,为true则该变量为NAN(NAN不等于自身)</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Express中使用Cookie]]></title>
      <url>http://yoursite.com/2017/03/16/%E5%9C%A8express%E4%B8%AD%E4%BD%BF%E7%94%A8cookie/</url>
      <content type="html"><![CDATA[<blockquote>
<p>文章来自于我在express框架上使用cookie引发的一些问题，但在具体介绍cookie以及如何正确的使用cookie之前，我觉得我有必要说一说<code>cookie</code>到底是什么。</p>
</blockquote>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>Cookie是服务器保存在浏览器中的一段小(一般而言size&lt;4KB)的文本信息，而浏览器每次想服务器发出请求，就会携带上这段信息。Cookie一般包含了key、value、到期时间、所属域名、所属路径等信息。</p>
<p>在浏览器中我们只需要使用<code>document.cookie</code>来得到当前页面所属的cookie。请注意，返回的cookie是以字符串形式存在的，不同的key-value之间通过’;’来分割，所以如果你想对齐进行进一步操作，需要相应的处理。</p>
<p>这里需要注意的是，<code>document.cookie</code>属性是可写的，这就意味着你可以手动添加cookie，使用<code>document.cookie=&quot;name=value&quot;</code>的形式。注意，这里是添加，而不产生覆盖。</p>
<p>好了，关于cookie的属性的具体含义和用法，大家可以自行去了解。</p>
<h3 id="我的问题"><a href="#我的问题" class="headerlink" title="我的问题"></a>我的问题</h3><p>我在使用服务器端使用cookie的时候出现了问题，出现这样问题的原因很简单，首先我对cookie存在错误的理解，请务必注意，cookie是服务器发送给客户端，而客户端在发起请求的时候携带cookie而已。在正确认识cookie之后，并且成功的将cookie发送到浏览器过后，问题又来了，我在请求的时候，cookie却不能发送到服务端。我使用的是下面一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/login?'</span>+stringify_data, &#123;</span><br><span class="line">        method: <span class="string">'GET'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res.json();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(json.status);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'oh ! error!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我使用了fetch API，在能够正确的发送请求的情况下，服务器无法读取到相应的cookie信息，同样在chrome开发者工具中查看请求头也发现请求并没有携带cookie信息。我想着一定是fetch API的问题，所以我赶快写了一个使用Ajax的请求，很显然，能够正确的发起携带cookie的请求。好吧，写到现在，我想的确是fetch API的问题了，阅读文档发现fetch API发送的请求默认是不带cookie的，必须手动设置(无论是出于什么样的考虑，但还是觉得坑)！好吧，问题迎刃而解，我们只需要在fetch函数第二个参数设置<code>credentials: &#39;include&#39;</code>就可以发送cookie了/无奈！</p>
<h3 id="在express中使用cookie"><a href="#在express中使用cookie" class="headerlink" title="在express中使用cookie"></a>在express中使用cookie</h3><p>在express中使用cookie是一件十分惬意的事情，因为如果你使用<code>cookie-parser</code>中间件的话，那么我们只需要使用<code>res.cookie(name, value[,options])</code>就可以设置cookie了，关于options相关的参数可以自行学习！</p>
<p>如果想删除cookie，也很简单，使用<code>res.clearCookie(name)</code>就可以啦。</p>
<p>当然如果想获取请求头发过来的cookie，我们只需要使用<code>req.cookies</code>就可以了，这里返回的是一个JS对象，我们直接可以使用<code>name</code>来读取值，从而做进一步的操作。</p>
<p>在使用了<code>cookie-parser</code>中间件过后，在服务端操作cookie已经足够简单，并且<code>cookie-parser</code>不但提供了非签名使用的方式，还提供了签名的使用方式，具体使用是在使用中间件的时候添加一个secret，<code>app.use(cookieParser(&#39;secret&#39;))</code>即可，当然，在获取cookie的时候使用 <code>req.signedCookies</code>属性就好了。</p>
<p>好了，如果你不想使用<code>cookie-parser</code>，我们也能够通过<code>req.headers.cookies</code>(感到罪恶所以不推荐/无奈)访问到cookie，如果想写cookie的话，使用<code>res.setHeader(name, value)</code>(再次感到罪恶)或者<code>res.writeHead(status[,options])</code>就可以了…</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>一般情况下，文章末尾，我总会写一点鸡汤/无奈，这次也不例外。距离写上一篇博客已经过了很久了，起初有两篇想写的文章，一篇是在RN中使用Navigator，另外一篇则是介绍我自己正在学习的几种分类算法。可是当创建好文件准备开工时，我因为写一篇文章可能需要2-3个小时(我速度慢)或者是因为真的动笔写的时候反而觉得没什么要说的就放弃了。然后一段时间过后，或许是因为忙，或许是因为懒，或许是因为浮躁，就是没有去实践，没有去巩固，而把一切都抛之脑后，然后把前面学习到的忘得一干二净！</p>
<p>嗯，这的确的真实的！仅此而已！</p>
<p>END</p>
]]></content>
      
        
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[兑水的心灵鸡汤]]></title>
      <url>http://yoursite.com/2017/02/28/%E5%85%91%E6%B0%B4%E7%9A%84%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/</url>
      <content type="html"><![CDATA[<p>好久不逛简书！</p>
<p>记不住曾经是以什么方式登录过简书，在我把QQ，微信，手机号，微博都试了一遍过后，我终于登录上去了。随便翻了翻首页，第一篇文章就是《心灵鸡汤是怎么忽悠我们的？》。匆忙看完，尚在回味之中，突然发现自己曾经也是一个鸡汤高手，生产过数十篇鸡汤软文，然后着急翻看，发现果真如此！</p>
<p>总结下来，我熬的心灵鸡汤大概有这样的特点：写自己的故事，还算完美的结局，极高的迷惑性，不认真看或者不了解我的人根本意识不到他们已经喝了我的鸡汤。</p>
<p>丑小鸭都能变成白天鹅，所以一切都会变好的。可实际上，丑小鸭之所以能够成为白天鹅，并不仅仅是因为它努力，勤奋，而是他的父母本身就是白天鹅。</p>
<p>爱笑的女孩子运气都不会太差。可实际上，如果一个女孩运气一直不好，她怎么可能笑得出来？</p>
<p>刚刚看完自己三年前的一篇鸡汤文，讲述的是一个不起眼的男孩的成长历程。这个故事就像丑小鸭的故事那样，那个男孩通过不懈的努力最终成为佼佼者。当然那个男孩不是我自己，而我的真实情况却是，整个高中三年，我因上课期间逃到校外上网不下10次，每个星期天唯一的半天假期我大都在网吧度过；由于我对手机的痴狂，我甚至一个月会换好几个手机；篮球水平也没有那么好。而至于我最终为什么能够考上大学，这个我真的不知道，也许我真有过刻苦和努力的那段时光吧。</p>
<p>我开始揣摩我当时的心理，可是依然没有任何头绪。我猜，我写文章的时候从来没想过让别人看见，我在给自己炖鸡汤，然后自己大口大口的喝下去。当刚刚喝完的时候可能我很解气，顿时觉得神清气爽有精神，可一段时间过后，我又感到烦躁无比，因为我又要面对摆在眼前那么真切的问题，我最终从自己幻想的那个世界中爬出来，面对强烈的反差，消极和怠慢丛生，然后开始耽误，一天，一周，一年，一辈子…</p>
<p>我继续看文章，有几篇是在我在外校做交流生的时候写的。不知道能不能算鸡汤文吧，但至少还是有一股鸡汤味。然后我又发现了一个共性，所有的文章都是我在遇到问题踌躇满怀的时候写的，比如刚来到陌生校园而找不到上课教室过后，和室友闹了小矛盾过后，离别的时候。这又能说明什么问题呢？当我开始把心中所有的烦躁和愤怒写出来过后，我的确好了很多，因为在构思一篇文章的时候，我出奇的冷静。当文章写完，消极和愤怒开始消退，短时间内信心爆棚，此时鸡汤的功效正在起作用；一段时间过后，我又开始烦躁，负能量急速增长，我想，我似乎得了鸡汤依赖症。所以不断的熬鸡汤，不断的喝自己熬的鸡汤，已经成为了我的常态。</p>
<p>做菜也许是我为数不过get到的技能，所以文章的最后讲讲我认为的好的熬鸡汤的方式。</p>
<p>材料：4-6个月母鸡，腌制萝卜整只多只，当归若干，枸杞少量，鲜竹笋数只，姜蒜，料酒，食盐若干。<br>步骤：</p>
<ol>
<li>在剔除多余的胸脯肉和鸡腿肉过后，切成小块洗净；</li>
<li>加入食盐，料酒搅拌均匀静置半小时；</li>
<li>使用60度热水清洗干净，放锅里炒干水汽备用(可适当加入油和盐)；</li>
<li>加入适当清水，片状的姜，整只蒜，以及大块的腌制萝卜，大火煮开；</li>
<li>倒入鸡肉，枸杞，小火炖上1小时；</li>
<li>加入切好的竹笋，再小火炖上1小时，鸡汤就可以出锅了，如果觉得不够鲜，还可以加入适当鸡精调味。</li>
<li>热腾腾的鸡汤，享用吧！</li>
</ol>
<p>曾经有人给我说过，做程序员写代码要开心，不然就不要写了。我想说，鸡汤要好好做，不然还不如不做。</p>
<p>共勉！</p>
<p>END</p>
]]></content>
      
        
        <tags>
            
            <tag> 心灵记事 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flex弹性布局]]></title>
      <url>http://yoursite.com/2017/02/22/Flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<blockquote>
<p>说起布局，我脑子里一下就想到了DIV+CSS布局，毕竟曾经被那么多写着DIV+CSS网页开发的书籍洗过脑，然后到现在还不怎么会用这种大众的布局方式。当然了，其实页面还有其它的一些布局方式，比如表格布局，框架布局这样已经逐渐被淘汰的布局方式，也有今天的主角–一颗冉冉上升的新星，弹性盒子布局。</p>
</blockquote>
<p>Flex是Flexible Box的简称，我们这里把其翻译为弹性布局，至于为什么不叫“灵活的盒子布局”。额，这个问题也许会在读完本篇文章找到答案。好吧，正式开始。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>flex是display的一个属性，当然对于行内元素还有一个叫做flex-inline的属性，这里我们不多说，但是要注意的是，一旦对一个元素的display属性设为flex，那么它的子元素就不能使用“浮动(float)”这个神奇的属性，而这个元素将会一跃成为容器(container)，而其的子元素将会成为项目。好吧，先从容器说起。</p>
<p>一旦把一个元素的display属性设置成为’flex’，这个元素就成为一个<code>容器</code>，<code>容器</code>有几个比较重要的属性，学习和掌握这几个属性是学习弹性布局的关键。它们分别是：</p>
<ol>
<li>flex-direction: 决定子元素(项目)的排列方向。</li>
<li>justify-content: 指定子元素在主轴上的对齐方式。</li>
<li>flex-wrap: 指定多行显示以及显示形式。</li>
<li>align-items: 决定项目在交叉轴上的对齐方式。</li>
<li>align-content: 定义项目在多轴线上的对齐方式。</li>
</ol>
<p>好吧，大概就是这几个了，我们注意到在上面解释的时候提到了<code>主轴</code>和<code>交叉轴</code>，这里我先简单解释一下：对于这个概念，我们可以很简单的在一个容器上画一个十字坐标轴，如果我们设置flex-direction为row(行)，那么横坐标就为主轴，纵坐标就是交叉轴，这里要注意坐标轴的指向，因为同样有一个属性为<code>row-reverse</code>，此时主轴的方向指向和设置为<code>row</code>的相反方向。</p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>作为容器的子元素，项目同样有几个重要的属性：</p>
<ol>
<li>order: 控制项目的排列，默认为0，值越小则越靠前。</li>
<li>flex-grow: 用于定义Flex项目的放大比例，默认为0，即使存在剩余空间，也不放大。</li>
<li>flex-shrink: 用于定义Flex项目的缩小比例，默认为1，即空间不足，Flex项目将等比缩小。</li>
<li>align-self: 允许单个Flex项目有不同于其他Flex项目的对齐方式。</li>
</ol>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>我并不会把每一个属性具体来讲，因为这样的文章在网络上的确太多了。我正在学习RN，所以在这里就写一个界面，其中的布局将会采用弹性布局，中途我会对布局进行简单的分析，以加深理解。<br>当写到这里的时候我就开始布局这个简单的页面，然后到现在才布局好，时间用了那么长，感觉像是过了一年…好了，不多说了，最终的界面如下图所示。<br><img src="http://olro3ke8a.bkt.clouddn.com/images/hexoSimulator%20Screen%20Shot%2022%20Feb%202017,%209.38.36%20PM.png" width="300px" height="500px"><br>其实我也不知道自己写了啥，还是勉为其难的就叫其“登录页面”吧，现在我来分析一下这个页面哪些元素是容器和项目(当然都是项目啦)，又在什么地方使用了什么属性。</p>
<p>页面整体采用了弹性布局，所以从整体来看我们一定使用了flex-direction属性，并且其值是<code>column</code>，所以这里的主轴一定是Y轴并且是方向向上。并且我们能够观察到，页面上所有的元素都是居中的，我们于是想到了在交叉轴上的对齐方式是: align-items: ‘center’，而其主轴上的对齐方式则是默认的justify-content: ‘flex-start’。</p>
<p>接下来来看两个不明显的，页面上有两个输入框，每个输入框其实都是一个<code>View</code>组件包裹，那么在这个组件内部，我们仍然使用了弹性布局(竖轴为主轴)，为了让输入框上下居中，这里必须让justify-content: ‘center’；紧接着最后一行有两个按钮，这两个按钮同样在一个<code>View</code>组件中，并且这个<code>View</code>也是弹性布局，并且一定要设置flex-direction: ‘row’才能让这两个按钮排列在一行。我们同样可以给每个按钮赋予不同的order值，让其进行排序。</p>
<p>总结一下：<br>我们是用弹性布局完成了一个基本页面的布局(虽然这真的很丑陋)，在这个简单的布局中我们使用到的属性并不多，但是的确比使用css+div布局来得更快，尤其是垂直上的居中，css是比较难以实现的。这里我们一共有四个容器，分别是最外层容器，每一个输入框外层容器，按钮组外层容器，当然，这里面所有的元素都能称为项目，这里就不在多说。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>说了这么多，那么我对flex布局的态度到底是什么？一句话总结，学习它，了解它，使用它。弹性布局我在刚开始学习React的时候就有了解过，过了也快半年了吧，当时看着阮一峰老师的文章，感觉怎么都不明白，然后渐渐抛之脑后。直到学期开始，我开始学习RN，再一次接触到Flex布局，才想起来画一些时间去了解，然后试着使用，最后再让自己记忆下来。相比第一次我接触Flex布局，我做出了改变，而这种改变是在时间并不充裕的情况下，弥足珍贵的。希望自己能够加油，也希望和我有同样压力的同学加油！</p>
]]></content>
      
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[生成器]]></title>
      <url>http://yoursite.com/2017/02/11/%E7%94%9F%E6%88%90%E5%99%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>大家对于<em>异步</em>这个词想必都不陌生，看到异步我可能最先想到的就是使用回调，再者我会使用Promise，可是使用回调处理异步控制流是有缺陷的：第一，基于回调的异步方式实在不适合大脑对于任务的思考(这点我深有体会)；第二，存在控制反转的问题。而Promise链提供了我们以顺序的方式处理和表达异步流。而这篇文章的主角生成器(generator)也是一种顺序和看似同步的处理异步的方式，并且它比Promise更加优秀。</p>
</blockquote>
<h3 id="有关函数"><a href="#有关函数" class="headerlink" title="有关函数"></a>有关函数</h3><p>不知道大家有没有这样思考过，一个函数一旦执行，其是否能够中断，我也没有仔细想这个问题，并且当看到这个问题，我会经验判断函数在执行过程中不会中断。到底是否中断，我们先写一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  bar();</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>运行上面这个例子，最终的结果是3，这就意味着，当函数执行完a++后，函数foo从表面上来看被中断了，然后执行了bar函数，最后执行权交给foo，函数返回已经被修改的变量a的值。虽然通过上面的小例子，并且因为JS单线程的特性，我们似乎能够肯定JS是抢占式的，但实际情况是JS并不是抢占式的，虽然函数bar的执行打断了函数foo的执行，但这其实是一种“关联”(参考原型继承)。</p>
<h3 id="初识生成器"><a href="#初识生成器" class="headerlink" title="初识生成器"></a>初识生成器</h3><p>现在让我们来认识生成器表达式，<br>同样是上面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a++;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iter = foo();</span><br><span class="line">iter.next();</span><br><span class="line">bar();</span><br><span class="line">iter.next(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>分析一下：<br>首先我们创建了一个生成器foo(注意*)，该函数里面多了一个yield，有过python经验的大概知道这是干什么的。然后创建了一个函数bar；再来看执行，这里var iter = foo()并没有执行生成器foo，而是构建了一个迭代器，然后使用next方法启动了迭代器foo，并且在碰到yield停止执行，此时已经执行了x++，然后执行函数bar，执行完后，x经过两轮自增，此时x的值为3；最后我们调用next方法，从上一次中断处继续执行，并且没有碰到yield表达式，一直执行到函数结束，打印变量x的值为3。</p>
<p>现在我们来回答什么是生成器，其是一个特殊的函数，在函数声明的时候函数名前面包含一个”*“，并且能够多次启动和暂停。好了，我认为仅此而已。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><p>为了把生成器运用到异步流程控制中，我们还需要更深层次的了解生成器。</p>
<h4 id="生成器仍然是一种函数"><a href="#生成器仍然是一种函数" class="headerlink" title="生成器仍然是一种函数"></a>生成器仍然是一种函数</h4><p>既然说生成器其本质上还是一种函数，所以其仍然具备函数最基本的特性，能够传递参数，也能返回值。我们不妨写一个例子测试一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">test</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = test(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">it.next();</span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res.value); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<p>其实生成器和普通函数的一个很大区别是在运行期间，它不会直接运行，而是创建了一个迭代器，然后每调用迭代器的next方法，便向下执行直到到碰到yield或者执行完成暂停。而我们注意到调用next方法返回的其实是一个对象，其包含一个value属性，如果生成器返回值的话，那么该属性的值就为生成器返回的值。总的来说，生成器的运行到目前为止完全是依托迭代器。</p>
<p>好了，继续。</p>
<p>继续来看例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">yield</span> a;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> mid = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(mid.value); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res.next); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子想表达的就是对于生成器而言，yield表达式总会返回一个值，而我们可以通过迭代器next方法生成的对象来得到。</p>
<p>继续来看一个更复杂的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a + (<span class="keyword">yield</span> <span class="string">'ok return!'</span>);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res.value); <span class="comment">// ok return!</span></span><br><span class="line">res = it.next(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.value); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子向我们展示了生成器是如何双向传递消息的，yield表达式可以发出消息响应next(…)的调用，而next(…)可以向暂停的yield表达式发送值。</p>
<h4 id="多个迭代器"><a href="#多个迭代器" class="headerlink" title="多个迭代器"></a>多个迭代器</h4><p>一个生成器的多个实例可以并发执行，并且可以彼此交互。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a + (<span class="keyword">yield</span>)</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it1 = gen(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> it2 = gen(<span class="number">2</span>);</span><br><span class="line">it1.next();</span><br><span class="line"><span class="keyword">var</span> res = it1.next(<span class="number">3</span>).value;</span><br><span class="line">it2.next();</span><br><span class="line"><span class="built_in">console</span>.log(it2.next(res).value); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子想说明的是一个生成器的多个实例可以并发执行，并且是互不干扰的。</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Prototype]]></title>
      <url>http://yoursite.com/2017/02/03/Prototype/</url>
      <content type="html"><![CDATA[<blockquote>
<p>JS为了模拟面向对象“类”的实现，为了模拟类的复制行为，可能会使用一种叫做“混入”的方法，当然，这种方法和我们今天要说的<em>原型</em>并没有多大的关系。使用<em>mixin</em>的方式来模拟“类”的实现不常见，当然为了模拟”类“所付出的代价也会让我们得不偿失，JS中不并存在”类”，而是存在一种叫做<em>原型</em>的东西，请容我细细说来。</p>
</blockquote>
<h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>我们直接来讲文章的主角<em>Prototype</em>，其实JavaScript中每个对象都有一个叫做[[prototype]]的属性，这个属性就是对其他对象的一个引用。基本上所有的对象在初始化时[[prototype]]都会被赋予一个值，关于这个值是什么以及如何访问这个[[prototype]]属性，我会在后面提到。</p>
<p>还是先看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码我们创建了一个对象obj，其包含一个属性a，我使用Object.create(obj)创建了一个新的对象，并把该对象的[[prototype]]属性赋值为obj，最后我们打印obj2中并没有显式声明的变量a，令人惊奇的是，我们成功的访问到了变量a，并且该变量的值为[[prototype]]属性引用对象obj的属性a的值！</p>
<p>我想解释下为什么要对这段代码写这么详细的解释，因为对于大多数接触过JS的童鞋而言，原型已经是见怪不怪了，可是当初我学习JS的时候，脑子里完全没有原型的概念，直到有一天我慢慢开始懂得原型，那个时刻，我的心情就像现在写这段解释的时候这么激动!</p>
<p>看完上面这段代码和冗长的解释，即使不了解JS的童鞋也对原型有了一定的认识。在这里我想再说一下，[[prototype]]到底有什么用，其实很简单，当我们试图引用某个对象的时候，在底层其实调用的是一个GET方法，而这个方法首先会查找对象本身存在这个属性与否，如果不存在则通过[[prototype]]访问其原型对象，如果还是不存在的话，则访问原型的原型对象(别忘了原型对象也是普通对象)，知道找到或者达到尽头(Object.prototype)。这个道理很简单，如果你使用for…in循环遍历一个数组的话，也许你得到的结果除了数组成员，还包含一些其它成员(不信你试试看)，这些成员就来自原型对象，并且是<em>可枚举</em>的，而对于in关键字，也会查找原型链上面属性。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在说类的时候，也许更恰当的是给类打上一个引号，因为JS中根本就不存在”类”，JavaScript中只存在对象，我们不使用“类”创建对象，更多时候我们直接创建对象。可有些时候，我们使用<em>new</em>关键字来初始化一个对象，我们甚至在ES6后开始使用class，extend等属于类的关键字，这貌似和我前面说的矛盾了…<br>接着看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(A.prototype);<span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// object</span></span><br></pre></td></tr></table></figure></p>
<p>我们创建了一个函数A，并且这个函数有一个属性prototype，如果没记错的话，这是本篇文章第一次访问原型，然后我们使用<em>new</em>初始化了一个对象，有传统面向对象语言基础的同学就知道，这简直像极了“类”！我再次强调，JS中不存在类，而且此<em>new</em>非彼<em>new</em>，这里函数A在<em>new</em>关键字的作用下，新建了一个空白对象，并让其prototype指向的对象赋值给新建对象a的[[prototype]]属性(关联)，当然这里面还会做一些其它的工作，不过大体上就这样了，很简单吧！</p>
<p>在JavaScript中，并不存在类的复制，我们不能创建一个类的多个实例，只能创建过个对象，只不过通过<em>new</em>这种方式创建的对象，其内部的[[prototype]]属性关联到同一个对象，这里所说的关联是建立一个联系，并不存在复制。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>既然不存在类了，这构造函数听着也很别扭，我们暂且给它打个引号吧。上面我们在说“类”的时候，我们就用到了”构造函数”，函数A就是所谓的“构造函数”，其本质上就是一普通函数，是JS的一等公民，要说真要有什么区别，函数名首字母大写算吗？也许是吧。</p>
<p>再来写一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(B.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(B.prototype.constructor === B);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="built_in">console</span>.log(b.constructor === B);</span><br></pre></td></tr></table></figure></p>
<p>我感觉我放了一个大招，突然让自己迷惑起来，这里我要说明的是，B.prototype和对象b有一个叫做constructor的属性，并且默认指向函数B。这个属性的名字会让我们对JS的误解加深，四级没过的都知道，constructor翻译过来可叫做“构造器”啊，那么既然B.prototype.constructor指向了B，我们还有什么理由不说B不是“构造函数”？讲到这里，我很无奈…</p>
<p>其实呢，JS中根本不存在什么“构造函数”，其就是普普通通的函数，只不过一旦加上new关键字，这个函数调用再也不是普通的函数调用，我们把它叫做“构造函数调用”。</p>
<p>这里不想再说下去了，写个复杂点的例子先：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, city</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.city = city;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.showInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, from: <span class="subst">$&#123;<span class="keyword">this</span>.city&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'limoer'</span>, <span class="string">'Chongqing'</span>);</span><br><span class="line">stu.showInfo(); <span class="comment">// name: limoer, from: Chongqing</span></span><br></pre></td></tr></table></figure></p>
<p>这里有两个值得注意的地方，每个通过”构造函数调用”而生成的对象都存在两个属性name和city；我们给Student.prototype上添加了一个“方法”，这样所有的新建对象都<strong><em>关联</em></strong>了这个对象，可以引用这个“方法”，关于<em>this</em>的使用，这里就不在提了。</p>
<p>在说了这么多过后，我想把“构造函数”称为“关联函数”，因为所谓的“构造函数”其实并不存在，或者说是，我们并不知道一个函数在创建好后是否是“构造函数”，而如果我们把它叫做“关联函数”，因为它本质上做的工作包含了建立对象和其原型对象的关联，当然，这个叫法是不恰当的。</p>
<p>再来看看constructor属性，一般情况下，任何一个普通对象都存在一个constructor属性，其实这个属性并不是其本身就有，而是当引用该属性的时候，其可以在该对象的原型链中找到。现在我急切的想写一个例子来表明一个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">C.prototype = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="built_in">console</span>.log(c.constructor === C); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>我不啰嗦了直接看问题，这里对象c的constructor属性竟然指向的不是创建它的那个函数C，这也侧面印证了我上面说的话，通过构造函数调用创建的对象不直接持有属性constructor而是从其原型链中“继承”而来，所以当我们想写一段包含继承的代码时，如果还想用constructor属性，需要做必要的修正。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  Main.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Main);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br></pre></td></tr></table></figure></p>
<p>在结束“构造函数”讨论的时候，提醒一句，尽量不要使用constructor属性，要问原因？我想我已经不那么直观的在前面说出来了。</p>
<h3 id="如何关联"><a href="#如何关联" class="headerlink" title="如何关联"></a>如何关联</h3><p>我在上面提到把“构造函数”叫做“关联函数”，这虽然是不恰当的，但也不是一无是处，因为使用<em>new</em>关键字的“构造函数调用”，其在创建一个对象过后，也把该对象的[[prototype]]属性关联到该函数的prototype上。当然，如何关联不止这一种方法，这里介绍一种使用更为普遍的方法，Object.create(proto)。</p>
<p>还是例子为先吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  info: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'info'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(obj)</span><br><span class="line">obj1.info(); <span class="comment">// info</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们使用字面量的直接形式创建了一个对象obj，该对象包含一个方法<em>info</em>，然后使用Object.create()创建了一个新的对象，并且该对象内部的[[prototype]]属性指向obj，概括点来说，该方法创建了一个对象，并把其关联到指定的对象。</p>
<p>Object.create()是ES5才引进的，在这里我实现一个polyfill代码作为本篇的结束：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Object</span>.create)&#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    Foo.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，这个版本的polyfill代码无法做到更复杂的功能，而Object.create第二个参数可以指定要添加到新建属性的属性名、值等。</p>
<h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>我们如果要访问一个并不存在的属性，在内部将会使用[[GET]]方法，并且查找该对象[[prototype]]所关联的对象，该关联实际上定义了一条“原型链”，在查找属性的时候会遍历整个“原型链”。</p>
<p>关联两个对象的最常用的两种方法是：（1）使用new关键字进行“构造函数调用”，创建一个新对象并进行关联；(2)使用Object.create()，创建新的对象，并时期和传入对象关联。</p>
<p>最后再次强调，JavaScript并不存在类，所有继承的实现完全是基于原型链，不存在复制。</p>
<blockquote>
<p>注：到底前面所说的原型链的尽头到底在哪里呢？答案是Object.prototype，对于一般的原型链而言，其最终都指向了Object.prototype，这个对象包含了许多对象通用的方法，例如obj.toString()&amp;obj.valueOf()等。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[this]]></title>
      <url>http://yoursite.com/2017/02/01/this/</url>
      <content type="html"><![CDATA[<blockquote>
<p>JavaScript中的<em>this</em>关键字一直都是学习JS的一个难题，我们往往不能准确的理解this在上下文中的含义，往往导致一些问题的发生。对于<em>this</em>关键字，我们需要知道的是：this即不指向函数自身也不指向函数的词法作用域，this在函数调用时被绑定，也就是说，它指向什么完全取决于函数在哪里被调用。</p>
</blockquote>
<h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>在探讨具体的绑定规则时，我们先来看一个函数调用位置的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'call foo'</span>);</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'call bar'</span>);</span><br><span class="line">  baz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'call baz'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>我们声明了三个函数，相互嵌套。现在来寻找各个函数的调用位置，foo在全局作用域中被调用，bar的调用位置则是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; 下面来看看几种一般性的绑定规则</span><br><span class="line"></span><br><span class="line">#### 默认绑定</span><br><span class="line">看一个例子：</span><br><span class="line">```javascript</span><br><span class="line">var name = &apos;limoer&apos;;</span><br><span class="line">function showName()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">showName(); //limoer</span><br></pre></td></tr></table></figure></p>
<p>这里<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#### 隐式绑定</span><br><span class="line">隐式绑定的规则是调用位置是否有上下文对象，即是否被某个对象拥有或者包含。</span><br><span class="line"></span><br><span class="line">来看一个例子：</span><br><span class="line">```javascript</span><br><span class="line">function showName()&#123;</span><br><span class="line">  return this.name</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;limoer&apos;,</span><br><span class="line">  msg: showName</span><br><span class="line">&#125;</span><br><span class="line">obj.msg(); // limoer</span><br></pre></td></tr></table></figure></p>
<p>对于函数showName而言，其在obj对象中被引用，即函数此时引用有上下文的对象，此时使用隐式规则，this将被绑定到这个上下文对象，所以<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">两点注意：</span><br><span class="line">（1）属性引用链只有或则说是最后以层才会影响调用位置，修改下上面的例子：</span><br><span class="line">```javascript</span><br><span class="line">function showName()&#123;</span><br><span class="line">  return this.name</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;limoer&apos;,</span><br><span class="line">  msg: showName</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  name: &apos;lindo&apos;,</span><br><span class="line">  obj: obj</span><br><span class="line">&#125;</span><br><span class="line">obj2.obj.msg(); //limoer</span><br></pre></td></tr></table></figure></p>
<p>（2）this的绑定与函数的调用位置息息相关，一个常见的问题就是被隐式绑定的函数会丢失绑定对象，即应用了默认绑定规则。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'lindo'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'limoer'</span>,</span><br><span class="line">  msg: showName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> show = obj.msg;</span><br><span class="line">show(); <span class="comment">// lindo</span></span><br></pre></td></tr></table></figure></p>
<p> 函数show虽然函数showName的一个引用，但是由于其指向的是函数的本身，此时bar是一个不带任何修饰的函数调用，应用了默认绑定规则。</p>
<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>和隐式绑定相反，显式绑定是一种“强制性”手段，把this绑定到某个对象上，JavaScript提供了这样的函数,call()&amp;apply()，这两个函数是如何使用的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  msg: <span class="string">'inner'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">&#125;</span><br><span class="line">showMsg.call(obj)</span><br></pre></td></tr></table></figure></p>
<p>call 和 apply方法的区别仅仅是参数上的问题，除了第一个参数外，apply可以使用数组来传入剩余参数，而call则是以多参数的形式写出来。除了call和apply以外，还有一个bind方法，它接收一个对象，返回绑定了该对象的这个函数，此种方法是硬绑定，也就意味着，绑定不可更改，这里不再多做介绍。</p>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>这是最后一种绑定方式，即“构造函数绑定”。会在将new关键字的时候在阐述此种绑定。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后<br>就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p>
<ol>
<li>由new调用?绑定到新创建的对象。</li>
<li>由call或者apply(或者bind)调用?绑定到指定的对象。</li>
<li>由上下文对象调用?绑定到那个上下文对象。</li>
<li>默认:在严格模式下绑定到undefined，否则绑定到全局对象。<br>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定，你可以使用一个DMZ对象，比如ø = Object.create(null)，以保护全局对象。<br>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这 其实和ES6之前代码中的self = this机制一样。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[提升]]></title>
      <url>http://yoursite.com/2017/01/30/%E6%8F%90%E5%8D%87/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我们都知道<em>对于任何声明在某个作用域内的变量，都将属于某个作用域</em>。但是对于JS而言，变量的声明与作用域还存在一种微妙的联系，这种联系我们叫做<strong>提升</strong>。</p>
</blockquote>
<p>首先来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'limoer'</span>;</span><br><span class="line">age = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> age;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子很好的体现了<em>提升</em>，输出name的时候，由于变量的声明在输出语句之后，想当然的使用RHS查找，查找失败抛出错误。但实际情况却输出了undefined，这是因为对于变量name，其声明被提升了，但是赋值语句却没提前，所以输出undefined。而对于age变量，赋值在输出前，我们理所应当的认为前面的赋值会被覆盖，但是程序却出乎意料的输出了2，这同样是因为变量age的声明提升到了首部，然后再进行赋值，最后输出了结果2。</p>
<p>上面的例子可以改写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">name = <span class="string">'limoer'</span>;</span><br><span class="line"><span class="keyword">var</span> age;</span><br><span class="line">age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其实，对于提升的讨论就是“先有蛋还是先有鸡”的讨论，通过上面的分析，显然我们可以得出“先有蛋（声明），后有鸡（赋值）”的结论。</p>
</blockquote>
<p>继续看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// call foo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'call foo'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'call bar'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子说明了三个问题：<br>（1）函数声明存在提升；<br>（2）函数表达式不存在提升；<br>（3）每个作用域都会存在提升。<br>这里我只想解释一下为什么上面运行<em>bar()</em> 抛出类型错误，由于变量声明存在提升，所以实际执行的是下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar;</span><br><span class="line">bar();</span><br><span class="line">bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<em>bar</em>的提升，调用bar()的时候并没有发生赋值操作，此时bar为undefined，所以对undefined进行函数调用会抛出一个TypeError而不是ReferenceError。</p>
<blockquote>
<p>那么问题来了，既然变量和函数声明都存在提升，那么当这两个同时出现的时候，谁的优先级更高呢？</p>
</blockquote>
<p>同样，写一个例子如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// call foo function</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'call foo function'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'call foo expressions'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，我们得出的结论是：函数声明提升的优先级更高。</p>
<p>注意：这里尽管foo的声明在函数foo声明之前，但是由于存在这样的规则所以被当做重复声明被忽略了，但是如果是函数声明，照样可以覆盖前面的声明。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>ES6引入的const和let关键字的一大特点就是使用这两个关键字声明的标识符<strong>不存在提升</strong>，这就意味着无法引用未声明的标识符，从而可以避免由提升带来的一些列问题。</p>
<p>对于<code>var a = 1;</code>这样常见的变量声明方式，我们应该把它想象成两个步骤：首先是在预编译阶段对变量a进行声明，接下来是执行阶段，对a进行赋值，而提升则是将所有的声明“移动”到作用域顶部的过程。加油！</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS作用域浅析]]></title>
      <url>http://yoursite.com/2017/01/28/JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我们都知道，JS的作用域其实包含了一系列的<strong>气泡</strong>，这些<strong>气泡</strong>包含了标识符(函数和变量)的定义,而这些气泡相互嵌套并且整齐排列。而在JavaScript中，这种气泡指的是<strong>函数作用域</strong>和<strong>块级作用域</strong>。</p>
</blockquote>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数作用域是JS中最基本也是最常见的一种作用域。所谓函数作用域，指的是在函数声明的过程中产生的一个“气泡”，这个“气泡”可以包含标识符。</p>
<p>来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 失败</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 失败</span></span><br><span class="line">bar(); <span class="comment">//失败</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的这段代码中，函数foo所形成的作用域包含了标识符变量<em>a</em>以及函数<em>bar</em>,而函数<em>bar</em>所形成的作用域包含了变量<em>b</em>。当然，全局作用域中也包含标识符<em>函数foo</em>。</p>
<p>当然，就像上面程序的运行结果一样，直接访问变量a，b，函数bar都将失败。因为在函数作用域中，其声明的变量和函数中能在其内部(包含嵌套的作用域)使用。</p>
<p>由于函数作用域的特性，将会带来很多优点，譬如函数作用域可以隐藏函数内部的实现(非常重要)，也可以避免变量在声明过程中产生的冲突以及覆盖。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>有Java学习经验的童鞋对<em>块级作用域可谓是了解</em>，然而在JS中，块级作用域可不是那么常见(至少是在ES6出现以前)。</p>
<p>在let和const关键字出现以前，如果想找到块作用域的影子，那么只有with和try…catch语句了。</p>
<p>with关键字是JS块作用域的一个典型，在该作用域的范围内声明的变量都只在with语句块中有效。</p>
<p>而块作用域的另一个应用则是在try…catch中，相信即使对JS不够了解的童鞋都知道异常处理，对于JS中的try…catch语句，在catch块中将会产生一个err对象，而这一个对象只能在catch块中才能使用。看下面一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  showName()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(e);</span><br></pre></td></tr></table></figure></p>
<p>上面的这个例子showName函数内部试图打印一个并不存在的变量name，这里将使用一个RHS查找，并且在失败后抛出一个引用错误，我们可以在catch捕获到这个错误对象，但是我们没法在全局作用域上使用这个错误对象。</p>
<p>好了，除了这两个使用<em>块作用域</em>的典型，在ES6标准中，还新增了let和const关键字来实现块作用域。这里简单介绍一下，对ES6感兴趣的的童鞋们可以点<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">这里</a>来进一步了解ES6。</p>
<p>let和const都是有别于var的另外两种声明方式，let用于声明变量，该变量将会被绑定在{…}中，也就是说使用let声明的变量具有块级作用域。使用let声明的变量不但具有块级作用域，同时变量也不会提升。而const则用于声明常量，同样具有块级作用域，并且也不存在提升。let可以很好的用于循环，防止变量对于环境的污染。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>函数是JS中最常见的作用域，声明在函数内部的变量和函数将会被很好的隐藏起来，这是一种良好的设计原则。而在ES6中，块级作用域再次被人们所日常使用。块作用域到底是不是函数作用域的替代方案，我认为到目前为止，不是！我们应该自己选择使用何种作用域，如何结合使用这两种作用域，来创造更加可读和健壮的程序。</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[词法作用域]]></title>
      <url>http://yoursite.com/2017/01/27/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作用域模式有两种，一种是词法作用域，另一种是动态作用域，JavaScript采用的是词法作用域。</p>
</blockquote>
<p>大部分的编译器会在编译阶段把程序进行词法化，也就是会对源代码中的字符进行解析，并且赋予词语语义。简单来讲，词法作用域就是词法阶段的作用域，词法作用域是由你在写代码时讲变量和块写在哪里决定的，当词法分析器在处理代码时会保持作用域不变。</p>
<p>考虑下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'limoer'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showNameAPI</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> city = <span class="string">'Chongqing'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showCity</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cid = <span class="string">'CN'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(city + cid);</span><br><span class="line">  &#125;</span><br><span class="line">  showCity();</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">showNameAPI(name)</span><br></pre></td></tr></table></figure></p>
<p>这个代码一共包含三个逐级嵌套的作用域，全局作用域中声明了变量name，全局函数showNameAPI,函数作用域中showNameAPI所创建的作用域，包含标识符city以及showCity，最后是showCity创建的作用域,包含了标识符cid。</p>
<p>作用域查找会在找到第一个匹配的标识符时停止。这里的查找是由内而外的，并且在多级嵌套的作用域内可以定义同名的标识符，但是会产生覆盖。因为<strong>作用域查找的规则就是找到第一个匹配的标识符后停止</strong>。</p>
<p>无论函数在哪里被调用，也无论其是怎么被调用的，其词法作用域只与其被声明的位置有关。</p>
<h3 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h3><p>上面说到词法作用域是在是完全在书写代码是就已经决定，但是也可以通过下面的两种方式在运行时来改变词法作用域。</p>
<p>当然，不出意外的，这两种方式会是不那么讨人喜欢的eval()和with。</p>
<p>我们首先来回顾一下eval()，这个函数接收一个字符串作为参数，这个字符串好像是运行时写在这里的代码一样。这明显是一种词法欺骗，其假装是在书写期间就在那里，而在运行时修改词法作用域。但是引擎对此并不知情，所以其依旧照常按照词法作用域进行查找。<br>看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'limoer'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">showName(<span class="string">"var name = 'lindo'"</span>) <span class="comment">// lindo</span></span><br></pre></td></tr></table></figure></p>
<p>eval(‘name=”lindo”‘)会被引擎误认为在书写时就在那里，由于执行了上面的语句，此时name的值已经被修改了，并且产生了覆盖，遮蔽了外部同名的变量name。</p>
<p>在默认的情况下，如果eval中所执行代码中存在一个或者多个申明，其就会对eval()所处的作用域进行修改。无论何情况，eval(..) 都可以在运行期修改书写期的词法作用域。</p>
<p>再来谈with关键字，我们都知道with关键字用于重复引用一个对象的多个属性的快捷方式，而不需要重复引用对象本身。<br>看下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'limoer'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  city: <span class="string">'Chongqing'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)</span><br><span class="line"><span class="built_in">console</span>.log(obj.age)</span><br><span class="line"><span class="built_in">console</span>.log(obj.city)</span><br><span class="line"><span class="comment">// 重复</span></span><br><span class="line"><span class="keyword">with</span>(obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的这段代码突出了with关键字优点，它可以简化我们的代码，但是我们这里谈的是with关键字的词法欺骗，看下面一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(obj)&#123;</span><br><span class="line">    name = <span class="string">'lindo'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = &#123;</span><br><span class="line">  name: <span class="string">'limoer'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p2 = &#123;</span><br><span class="line">  city: <span class="string">'Jinan'</span></span><br><span class="line">&#125;</span><br><span class="line">info(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// 'lindo'</span></span><br><span class="line">info(p2)</span><br><span class="line"><span class="built_in">console</span>.log(p2.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">//lindo!</span></span><br></pre></td></tr></table></figure></p>
<p>上面的这个例子很好的展示了with关键字的词法欺骗，这里创建了两个对象p1和p2，并通过info函数执行with(obj){…}，这里进行了简单的LHS查找，并将新值赋给name属性。但是请注意，这里p2对象并不存在name属性，也不会创建name属性，所以p2.name为undefined；这里很好理解，但是为什么神奇的是竟然多出了一个全局变量name呢!？</p>
<p>这里执行with(obj){…}的时候，执行的LHS查找，所以当查找不成功时自动隐式创建一个全局变量，如果这样考虑，那么出乎意料的name属性就不难理解了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JavaScript拥有的是词法作用域，所谓的词法作用域就是在进行词法分析时的作用域，也就是说，JS的作用域在代码一旦书写完成就能确定(靠书写位置来确定)。词法作用域的理解很简单，但是我们还是需要注意使用eval()和with语句带来的词法欺骗的原因。也许有人会说，在运行时修改词法作用域有利于实现复杂的功能，又利于扩展，何乐而不为呢？可我们在前面提到，在进行编译的时候，JS引擎会对代码进行优化，而这个优化则是根据代码的词法作用域，预先确定变量和函数的位置，才能在执行过程中快速找到标识符。而eval()和with的出现则有可能打破这样的格局，因为引擎在词法分析阶段并不能知道传入的代码到底是什么，会对词法作用域造成怎样的影响。所以，一切优化都是徒劳的，因为在运行时谁都不能确定此时此法作用域到底是怎么样的，所以JS引擎并不会进行优化，导致代码运行缓慢，性能并不好。所以，尽量不要使用它们。</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解作用域]]></title>
      <url>http://yoursite.com/2017/01/27/%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>JS作用域的问题是老生常谈的问题了，我们都知道JS是不存在块级作用域的(ES6以前，try…catch是一个例外)，可是仍然实际编程过程中由于对作用域的理解不够深刻，踩坑无数，苦不堪言，恰逢寒假，又到了充(wan)电(shuai)的时间，所以把学习的重点放在认识JS语言本身上面。参考了资料《你不知道的JavaScript》。</p>
</blockquote>
<h3 id="实例为先"><a href="#实例为先" class="headerlink" title="实例为先"></a>实例为先</h3><p>首先，我们以var a = 1;这一个语句为例，看看这个过程JS到底干了什么。</p>
<p>毫无疑问JS是一门编译型的语言，但它的编译不是提前编译的，编译过程一般发生在语句执行前几个微秒。并且其和其它典型的编译语言一样，编译的步骤是相似的。首先编译器会把语句进行分词，分成单个的代码块，这些代码块被称为词法单元；接下来编译器会把词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这棵树被称为”抽象语法树AST”；最后一步，代码生成，该过程会把AST转换成可执行代码(机器指令)。</p>
<p>当然，JS的编译过程不会如此简单，其也会包含性能优化等。但这些所有的工作都在执行前几个微秒的时间内完成，并且立即执行它。</p>
<p>在正式的开始了解作用域之前，我们首先认识一下代码在执行时所需要的工具。</p>
<ol>
<li>引擎：负责代码编译到执行过程</li>
<li>编译器：负责词法分析和可执行代码的生成等</li>
<li>作用域：负责收集并维护由所有声明的标识符(变量)组成的一列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限</li>
</ol>
<p>现在开始对var a = 1的执行进行分解：</p>
<p>首先编译器会把这段程序分成词法单元，并且构建AST，当遇到var a的时候，首选编译器会询问作用域，是否已经已经有一个同名的变量存在于这个作用域集合中，如果存在则忽略该语句，否则在该作用域申明一个变量，命名为a；接下来，编译器会为引擎生成可执行代码，用于处理a=1这个赋值操作，引擎会询问当前的作用域是否存在一个名字为a的变量，如果存在，则使用这个变量，否则继续操作。最终，如果找到变量a，则给其赋值为1，否则将抛出错误。</p>
<p>总结：在对变量赋值时会存在两个步骤：首先编译器会在作用域中生成一个变量；然后引擎在运行时查找该变量，如果存在就赋值，否则抛出错误。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>1.嵌套作用域：作用域嵌套这个概念是很好理解的，当一个块嵌套在另一个块或函数中的时候，就会发生作用域的嵌套。当在当前作用域无法找到某个变量的时候，引擎就会在外层的嵌套作用域中寻找，知道抵达到最外层作用域或者找到了该变量为止。</p>
<p>考虑以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>对变量a的查找是无法在add函数内部完成的，所以引擎会向上层作用域中查找，并且在外层作用域中找到。</p>
<h3 id="LHS-amp-amp-RHS"><a href="#LHS-amp-amp-RHS" class="headerlink" title="LHS &amp;&amp; RHS"></a>LHS &amp;&amp; RHS</h3><p>引擎查找变量时常用的两种查找方式，这里需要注意的，如果执行右侧查找，无法找到该变量则会抛出引用错误。而进行左侧查找的时候，如果不成功，则会<strong>自动</strong>的隐式创建一个全局变量(都是在非严格模式下)</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>简单来说，作用域就是一系列的规则，这套规则用于管理引擎如何在当前作用域以及嵌套的<strong>子域</strong>中根据标识(zhi)符名称进行变量的查找。</p>
<p>下一篇，将深入的学习<em>词法作用域</em></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我们的世界]]></title>
      <url>http://yoursite.com/2017/01/26/%E6%88%91%E4%BB%AC%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<p>最近看了一部叫做《我们的世界》的韩国剧情片，讲的是这样一个故事：</p>
<blockquote>
<p>主人公李善被人孤立，没人愿意和她组队玩集体游戏，她总是最后一个被无奈选中，也不出意料的第一个被淘汰，然后孤苦伶仃的站在一旁，不知道是不是要离开。她在学期末结识了转校生韩智雅，不知道这是不是她结交的第一个朋友，但的确度过了一个快乐的假期。智雅父母离异，却在李善家中看到了温诺的家，于是心生情愫，逐渐远离李善，结交了新的朋友。从好朋友到最熟悉的陌生人，李善就这样在新学期开始，再次被孤立。而韩智雅为了不被大家孤立，不但选择装作不认识李善，反而和班上同学一起排挤她，这让李善儿感到很苦恼。父母的不知情以及后面的一系列的事，让她们两个的关系越来越糟糕。韩智雅成为班上的学霸，而李善也成为了以宝拉为首的小团体利用攻击智雅的工具。最终两人走上了互相伤害的道路，智雅说善儿的父亲是酒鬼，而李善儿反击，把自己知道的智雅撒谎的真相公之于众。最后的最后，一直被孤立的李善还是继续被孤立，而韩智雅也成为那个被孤立的人。故事的最后，班上又开始玩丢球游戏，这次大家不想和两个人玩游戏，李善率先被淘汰，站在一边，韩智雅被诬蔑，李善主动站出来为她说话，避免了僵持不下的尴尬和无助。最后两人站在场边，不时偷望对方。我不禁有这般假设，假如没有选择离开，如今又会怎样？可惜小孩子的思想太过复杂，捉摸不透。电影戛然而止，关于她们两个最终和好的画面留给观众去想。</p>
</blockquote>
<p>好了，故事讲完了。李善儿和韩智雅最终还是被孤立，成为了校园冷暴力的受害者。回到现实，我也像她们俩一样，成了受害者，并且顺利的长大了。</p>
<h2 id="故事是这样的"><a href="#故事是这样的" class="headerlink" title="故事是这样的"></a>故事是这样的</h2><p>过了这么多年，对小学和初中那段时光的记忆很微弱了。直到前些日子，小学群里面，有人发了一张毕业照照片，照片中的我站在人群的中央，探出一个脑袋，不注意真还发现不了这个瘦小的孩子。而到了快过年的时间，这个群就特别活跃，我却发现，我根本插不上一句话，好不容易找到一个机会发了一条消息，却被无视了，我开始回想，那段小学的日子里，我也经常这样被忽视，也许到现在，他们根本不记得了我了。</p>
<p>我开始回想上小学的那段时光。低年级的时候，我是班上再平常不过的，个子矮小，学习成绩一般，零花钱少，还特别闷。在我的印象中，那个时候我经常中午要去外婆家吃饭，来回的路上会有很多的孩子，但是没人愿意和我一起走，如果我走过去主动和他们说话他们就跑，或者打我。直到后来，我来回的路上终于有了一个伴，那是外婆村子里读小学的一个半傻子(我也不知道该怎么形容)，我们一起在小河沟捉鱼，玩弹珠，可也因为这样，其他孩子更不愿与我玩。那时候的我，却没有如电影里两个女孩子那样琢磨不透的小心思，只好选择沉默。</p>
<p>好吧，最终我还是有了第二个(第一个是外婆村子里的傻子)好朋友，在我三年级的时候，我和安静的同桌成为了好朋友，我们很多时候会在放学时候一起回家(貌似还不顺路)，开始的时候，我们都不怎么说话，可我发现一个人的字可以写得那么工整，一个人的画可以画得那么漂亮，我开始主动找她说话，后来我们两个人之间似乎有说不完的话，每到下课，我们才不会去和其他同学一样，逛零食店，打乒乓球，玩跳绳。可这段时间没过多久，我的第二个朋友一年后转校离开了。我又开始了被孤立的时光，知道逐渐的适应这样的生活。</p>
<p>这种情况直到小学六年级才得到转机，我的学习成绩也越来越好，我的一个亲戚成了我的班主任，他也很关照我。我虽然依然很闷，但是还是想逃离被孤立。为了融入坏孩子团体，我也开始变‘坏’，我开始在学校小卖店赊账，大部分都是请同学吃了零食；我开始和他们放学不回家跑到网吧去玩，这也是我最开始接触到网络的时候。可即便是这样，我仍然无法摆脱不了被孤立，我能够打很好的乒乓球但是没人愿意加我一个，我也能玩弹珠，但是又有人和我玩？</p>
<p>后来，大家都升入了初中，整个初中我都是在极力的融入这个环境，总在坏孩子和好学生的角色切换，这样的生活我过了三年。初中毕业后，我只身一人去了一个陌生的学校读书，也就和当初的坏孩子军团失去了联系，也许他们也不记得了，那个曾经总是在帮他们跑腿和揽责(背锅？)的我，这个坏孩子。</p>
<p>我的那段故事讲到这个就要画上一个句号了，因为我在高中结识了最要好的几个朋友，我再也是那个被孤立的对象。虽然在不熟识我的人眼里，我仍然很闷，就像刺猬一样，让人不得接近，可现实中的我，不是这样😂</p>
<h2 id="那么，我到底想说什么"><a href="#那么，我到底想说什么" class="headerlink" title="那么，我到底想说什么"></a>那么，我到底想说什么</h2><p>我相信在小时候的学生时代，被迫承受孤独的还有很多人。他们是多么渴望有个人成为他们的朋友，玩伴。可奈何无论怎么努力，却还是一再的被孤立。大概是因为差异，微小的差异让我们成为了受伤害的对象。也许是因为我矮小，抑或是我长得丑，家庭条件不好，甚至因为我成绩好…这些都成为了我们被排挤的理由。我们在任何时间段都会受到这样的伤害，成人学会了忍耐，而对于小孩子，他们很多就像李善和韩智雅一样，最终互相伤害。当我们还小时，因该是我们率真的时候，我们的小心思却伤害了我们。当然，这一切的一切，学校和家长并不知情，这样的伤害也许就会持续下去，伴我们成长。</p>
<h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>我是先看完简介的时候再看电影的，整个过程我心情很失落，我看到了我的小时候，我并没有被无尽的孤立的所吞噬，我也没有反抗去伤害他人，反而我适应了这样的生活，逐渐的我习惯了过一个人的生活。直到现在，当独处的时候，我会回想，如果如曾经厌倦了无尽的孤立选择伤害反抗，抑或是我本身就是孤立别人的’坏孩子’，如今我又怎样。奈何时间没有倒带，人生不会从头再来。</p>
]]></content>
      
        
        <tags>
            
            <tag> 心灵记事 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[给自己立个寒假计划吧]]></title>
      <url>http://yoursite.com/2017/01/11/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%AB%8B%E4%B8%AA%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92%E5%90%A7/</url>
      <content type="html"><![CDATA[<p>从坐错公交，打不到车，取不出票，到最后如期上了回家的车；再到火车晚点，冒雨给人指路，凌晨等车回家；最后，谢天谢地，我安全的回来了，时间刚好定格在凌晨一点；又饿又冷度过了一夜，醒来已经是8点半了，我的寒假生活正式开始。<br>说实话，一到放假懒散病加拖延症又犯了，就拿这第一天来说吧，早上起床吃完饭，就开始守在电脑前闲逛，打开炉石刷完任务，用150金币开了竞技场，抓牌太烂扔掉开出金橙；以为成功脱非怒买40包检验血统，结果只有一橙5紫，非洲血统无疑！血统验完吃了中午饭，分掉金卡，做了血法和墨水大师，组了一套宇宙无敌超级垃圾的宇宙法，直接试天梯，被龙牧和海盗战吊起来摩擦，打了一个半小时竟然还是18级。这时才想到寒假的第一天不是应该有一个好的开始吗，然后开始打开慕课网到处闲逛，在为数不多的React课程中看了几则短教程，虽然这些基本的知识都有了解。晚上吃完饭已经8点半了，打开某鱼直播288010房间，听着某丸唱歌，我开始想给自己写一个计划，对!就是关于这个寒假我该怎样度过的。不出意外，我会在十点半写完，然后继续看直播网络闲逛到12点睡觉，然后眼睛一闭一睁就又过了一天啦。</p>
<p>额，好吧，用这么欢快的语气写了一段过后，我觉得有必要再严肃一点。毕竟碰见就有人问，明年考研还是就业呢。而我，不知道…</p>
<p>我从学校带了三本书回来，因为我将有很长一段寒假时间会断绝网络所以实在没事做的时候还是可以看看书打发时间的。这三本书包含了数据结构和简单的算法(python)版本，JS设计模式，以及我急需的JS知识要点巩固。由于回家的旅途太过煎熬，所以并没办法呆很多书，并且我不认为我能够在寒假看很多书，而且我喜欢看电子版的。</p>
<p>下学期期末过后，不出意外的话我就要开始找实习工作了，虽然作为一个软件工程数据科学方向的同学，当初选数据科学竟然是为了能够在课堂上学习非关系型数据库！好吧，我的兴趣当然在前端，我毫不掩饰表达出我对前端的喜爱，虽然我到现在能力有限，还处在非常非常初始的阶段。</p>
<p>我想总结一下自己目前学习前端的状态，HTML和CSS没有系统的学习过，只能说能用；JS接触不到一年时间，期间也是断断续续的在学习，总的来说还是有所掌握的，ES6有匆匆忙忙看过一本书，花了在学校的三个月时间断断续续的学习了React和了解了其全家桶，目前处于遗忘的状态。Node一直在关注，但是没开发过实际的项目。总的来说，系统学习JS和React，做过小的课设，但是就没有了其它应用。基本水平还是处在能够照着DEMO写DEMO的水平。</p>
<p>寒假是一个很好的时间用在学习上，并且我给自己的目标是打好基础。</p>
<p>除了好好学习看书以外，当然还有其它的。比如每天坚持锻炼，早睡早起。如果要落实在每天的话,我想计划也许是这样的：</p>
<ol>
<li>每天早上8点起床，</li>
<li>吃完早饭看会NBA(如果有直播的话)学习一会，</li>
<li>中午吃完饭休息一会，下午是看书学习时间,</li>
<li>晚上是一个绝佳的时间用在回顾整理并时间，</li>
<li>睡觉</li>
</ol>
<p>当然，也可以有意外，比如我会和同学出去玩，我会选择一个好天气出去钓鱼，或者打篮球也是一个不错的选择。当然，也许会有很多时间花在了走亲访友上，虽然我不喜欢，但是也得去对吧！</p>
<p>写到这里，我突然想起了几个月前，我好哥们突然说他报了班进军编程界，当时我站在一个“过来人”的角度还给了他很多建议，不知道如今的情况怎么样了，赶快写<br>完打个电话寒暄一番！</p>
<p>如论就像上面写的那样，我能够好好的规划自己的时间，还是三分钟热情，亦或是根本就把学习的事，抛在脑后，至少有一点，让自己的寒假生活过得满意。至于什么才算满意，只有等到时间所剩不多或者已经过了的时候，你才知道。从小到大，所有的路都是我固执选的，就连自己如今的专业，也仅仅是因为高中三年，对于智能手机的热爱。时间还足够长，长到我还可以继续浑浑噩噩再过上一年半，可又很短，我对当初初到西电交流的情景历历在目，如今却还在为补课的事而担忧。</p>
<p>在发明双绞线和光纤之前，我们使用古老的磁介质来进行存储和信息交流。如果一盘磁带能装10首歌曲，总容量为10MB，重量是50克，占用空间为0.00005m^3，一辆笨卡车拉着两吨也就是40000盘磁带，折和400GB容量，A-B地长度是100km，需要两个小时的才能到达。那么带宽将会是近450Mbps，远超目前家庭光纤的速度，那么问题来了，为什么这种传统而古老的方式会被取代呢？因为太麻烦了，写入到磁带和读取的时间太长了。所以，不要低估一辆拉着磁带在马路上狂奔的卡车的带宽，也不要盲目的高估它。我想，这就是我目前需要的。</p>
]]></content>
      
        
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网路复习笔记之网络层基础]]></title>
      <url>http://yoursite.com/2017/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="网络层基础"><a href="#网络层基础" class="headerlink" title="网络层基础"></a>网络层基础</h2><p>网络层关注的是如何将源端数据送到另一方，为了将数据送到另一方，可能会经过很多跳中间路由器。网络层处理的是端到端的数据。<br>为了达到这样的目的，网络层必须知道网络的拓扑结构。并从中选取适当的路径传输；此外，网络层还得仔细选择路由器，避免线路拥塞和路由器负载过重，而其他路由器则很清闲。<br>当源端数据和接收端数据来自不同网络时，需要网络层来解决。</p>
<h3 id="1-网络层的设计问题"><a href="#1-网络层的设计问题" class="headerlink" title="1.网络层的设计问题"></a>1.网络层的设计问题</h3><p>5.1存储数据包与网络交换<br>如果一台主机需要发送一个数据包，它将数据包传递给就近的路由器，路由器可能在它自己所在的LLAN上，也可能在通往IPS的点到点的链路上；<br>在数据包到达路由器后，路由器的链路层对其进行校验和验证后，它首先会被存储在路由器上；接着沿路径被转发到下一个路由器，直至达到目标主机。<br>这是一种存储-转发数据报交换的模式。</p>
<h3 id="2-无连接服务的实现"><a href="#2-无连接服务的实现" class="headerlink" title="2.无连接服务的实现"></a>2.无连接服务的实现</h3><p>无连接的服务：所有数据包将会被独立的注入到网络中，并且每个包独立路由，不需要任何的提前设置。这里我们把数据包也称为数据报，对应的网络被称为数据报网络。<br>有连接的服务：在发送数据包之前，需要建立一条源路由器到目标路由器的路径，我们把这个连接称为<strong>虚电路</strong>。其类似于电话系统中建立的物理电路，该网路也被称为虚电路网络。</p>
<p>每个路由器将含有一个路由表，它指明了每一个可能的地址应该将数据包送到哪里去。每个表项由两部分组成，目标地址和通往目标地址所使用的出境线路。<br>每个路由表是可变的，管理这些路由表并作出路由选择的算法是路由算法。<br>IP协议是Internet的基础，它是无连接协议的范例。每个数据包携带一个IP地址，路由器根据IP地址来单独的转发每一个包。</p>
<h3 id="3-有连接的服务"><a href="#3-有连接的服务" class="headerlink" title="3.有连接的服务"></a>3.有连接的服务</h3><p>有连接的服务需要一个虚电路，为了避免数据包选择一条新的路径。需要使用路由表记录下来已经确认的路径，当连接被释放，虚电路消失。在面向连接的服务中，每个数据包都带有一个标识符，指明它属于哪一条虚电路。</p>
<p>这里的路由表是这样的，对于某个路由器而言，其包含了入境和出境两个逻辑列，每个列含有两行，分别指定了路由器和标识符。这里的出境标识符是可变的(为了解决某些冲突需要改变一下标识符)。这个改变出境标识符和的过程也被称为<strong>标签交换</strong>。</p>
<h3 id="4-简单的比较"><a href="#4-简单的比较" class="headerlink" title="4.简单的比较"></a>4.简单的比较</h3><p>使用虚电路需要有一个花费时间并且耗费资源的建立过程，之后处理数据包非常容易；在数据报网络中，不需要建立连接，但路由器需要一个更复杂的查找过程。对于数据报网络而言，需要使用更长的目标地址，因此如果在数据量很小的情况下，目标地址承担了巨大的开销，宽带资源被浪费。<br>在控制拥塞方面虚电路表现得更好，因为在建立连接时，资源可以提前预留。最后是事务处理和健壮性，虚电路网络并不能够表现得很好，因为其需要花费大量的时间用于建立和清除虚电路并且一旦发生宕机，虚电路终端，所有的数据都会受到影响。</p>
<h2 id="路由算法-⭐️"><a href="#路由算法-⭐️" class="headerlink" title="路由算法(⭐️)"></a>路由算法(⭐️)</h2><p>路由算法属于网络层软件的一部分：其负责确认一个入境数据包应该被发送到哪一条输出线路上。如果网路选择了数据报，那么路由器需要对每一个到达的数据包重新选择路径，因为自上次选择了过后，可能最优路径已经发生改变；对于使用虚电路时，只有在新建一条虚电路时，才需要路由决策，这种情形被称为<strong>回话路由</strong>。 </p>
<p>我们可以把一个路由器内部想象成为有两个进程，一个用于接收数据包，检查数据包并且<strong>转发</strong>，一个则用于更新路由表。</p>
<p>路由算法需要含有的特性：正确性，简单性，鲁棒性，稳定性，公平性和有效性。</p>
<p>路由算法分类：</p>
<ol>
<li><p>非自适应算法：不会对当前进行测量，或者估算流量和拓扑结构来调整路由决策，相反所有路由都是在离线条件下计算好，并在网络启动时下载到路由器中，这个过程也被称为静态路由。该算法只适用于对路由选择已经很清楚的情况。</p>
</li>
<li><p>自适应算法：改变路由决策以便反应出拓扑结构的变化，通常也反映出流量的变化。<br>这些<strong>动态路由</strong>算法在各个方面也有表现不同，获取信息的来源不同，改变路径时间的不同，对路由的优化度量不同等。</p>
</li>
</ol>
<h3 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h3><p>最优路径的一般陈述：如果路由器J在路由器I到K的最优路径上，那么从J到K的最优路径仍然遵循同样的路由。</p>
<p>汇集树：作为最优化原则的一个直接结果，从<strong>所有的源</strong>到一个指定目标的最优路径的集合构成的一颗<strong>以目标节点为根</strong>的树。<br>汇集树不一定是唯一的。<br>汇集树<strong>不含有环</strong>，因此在指定的跳数内一定可以完成对数据包的传递。<br>每一个路由器都有一颗汇集树，根节点就是该路由节点。</p>
<h3 id="具体的路由算法"><a href="#具体的路由算法" class="headerlink" title="具体的路由算法"></a>具体的路由算法</h3><h4 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h4><p>构建一张网络图，图中的每个节点代表一个路由器，每条边代表一段通信线路。为了选择一对给定路由器的路由，算法只需要在图中找到他们的最短路径。<br>采用Dijkstra算法（这里的思想完全一致）。</p>
<h4 id="泛洪算法"><a href="#泛洪算法" class="headerlink" title="泛洪算法"></a>泛洪算法</h4><p>路由器将数据包发送给到达线路之外的所有出境线路。<br>分析：这样的做法会导致大量的冗余数据包，并且如果不加限制的话，将产生无数个重复的包。<br>限制的做法有：</p>
<p>(1) 在每个包头加上一个跳计数器，每经过一个路由器，跳数减一，跳数为0时，丢弃掉该包。理想情况下，计数器的大小是源端到目的端跳长度；最坏的情况是整个网络的最长路径。</p>
<p>(2) 追踪已经泛洪过的数据包，避免第二次发送它们。每个源路由器在接收数据包时给数据包添加上一个序号，每个路由器为源路由器建立一个表，其中包含了这些已经泛洪过的数据包的序号，如果某个数据包的序号在这张表中，则不再泛洪该包。<br>(3)为了防止这张表无限膨胀，每个表使用一个计数器k作为参数。它表示直到k的所有序号都已经观察到了。当一个数据包入境时，很容易检测该包是否被泛洪过，只需要比较和k的大小，如果泛洪过，丢弃该包。</p>
<p>泛洪算法对于广播是一种有效的手段，但是对于其他用途而言不切实际。泛洪算法的鲁棒性非常好，如路由器损坏导致拓扑结构发生变化，仍然能够起比较好的作用。</p>
<h4 id="距离矢量算法⭐️"><a href="#距离矢量算法⭐️" class="headerlink" title="距离矢量算法⭐️"></a>距离矢量算法⭐️</h4><p>每个路由器维护一张表，表中列出了当前已知到每个目标的最佳距离以及所使用的链路。这些表通过邻居之间相互交换信息而被不断更新，最终每个路由器都了解到达每个路由器的最佳链路。</p>
<p>路由器维护的表一共有两项，第一项是目的路由，第二项是到其的最优路径的跳数(也可以是一个综合计算的数值)。通过邻居分享的路由表可以计算出新的信息，如果有最佳路径，就更新该路由器的路由表。<br>注：感觉这里是绝对的重点，一定要掌握如何计算和更新路由表。</p>
<p>距离矢量算法会产生一个无穷计算的问题，关于什么是无穷计算，这里需要看书。<br>距离矢量算法的另一大缺点就是：当网络拓扑结构发生变化时，路由算法需要太长的时间才能收敛到稳定的状态(无穷计数问题引起)</p>
<h4 id="链路状态路由算法⭐️"><a href="#链路状态路由算法⭐️" class="headerlink" title="链路状态路由算法⭐️"></a>链路状态路由算法⭐️</h4><p>步骤：</p>
<ol>
<li>发现其邻居节点，并掌握它们的网络地址</li>
<li>设置到每个邻居节点的长度值(或者说是成本度量值)</li>
<li>构造一个包，包含上述信息</li>
<li>将这个包发送给所有其他路由器，并且接受来自其他路由器的包</li>
<li>计算出到每个其它路由器的最佳路径</li>
</ol>
<p>对于发现邻居，其实是很好理解的，每个路由器在启动过后都发送一个特殊的HELLO数据包，其邻居接到过后就会返回一个应答，包含了自己的网络地址等信息。</p>
<p>链路成本的计算：一种常用的选择是成本与链路带宽成反比。或者使用延迟估算来作为成本计算的方式。</p>
<p>构造链路状态包：<br>包含了以下内容：发送方的标志，序号，年龄(后面介绍)，邻居和其成本的二元组。</p>
<p>构建链路状态包的时期为：周期性的构建或者当网络拓扑结构发生变化了进行构建。</p>
<p>对于发送包和接收包，这里使用的是泛洪算法，age字段的作用是防止数据包无限的生存下去，递减到0时则丢弃该包（这里不是到达一个路由器age-1）而是每过一个时间减一，比如说一秒。</p>
<p>计算新路由：使用的是Dijkstra算法计算。</p>
<p>链路状态路由算法相比距离矢量算法需要更多的内存和计算，对于一个具有n个路由器的网络，每个路由含有k个邻居，则用于存储输入数据的内存与kn成正比，并且计算时长的增长快过kn，在大型网络中运行这个算法仍然是个问题。不过在实际过程中，由于其并没有慢收敛的问题，因此工作的还不错。</p>
<h4 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h4><p>对于规模特别大的网络，可以把网络分成区域，对于区域内部仍然构建详细的路由，对于区域外部，只构建层次的路由表项，不关心内部。这样可以减小一个路由器维护的路由表的大小。</p>
<h4 id="广播路由"><a href="#广播路由" class="headerlink" title="广播路由"></a>广播路由</h4><p>使用泛洪算法，使用逆向路径转发的思想构建一颗汇集树。<br>生成树：网络的一个子集，包含所有路由器并且不含环路。汇集树属于生成树的一种。</p>
<h4 id="组播路由"><a href="#组播路由" class="headerlink" title="组播路由"></a>组播路由</h4><p>为了防止给不是该组成员发送，在采用广播的思想上，需要对生成的汇聚树进行剪枝。通过把不是改组成员去掉，可以构建组播树。</p>
<p>如果使用的是链路状态路由算法，每个路由器知道完整的拓扑结构，并且知道每个路由器是属于哪个组的情况下，可以使用最简单的组播算法。每个路由器针对组内每个发送者构建一颗它自己修剪后的组播树。具体的做法是首先构建一颗简单的汇聚树，然后再把不是该组的链路去掉即可。</p>
<h3 id="拥塞控制算法⭐️"><a href="#拥塞控制算法⭐️" class="headerlink" title="拥塞控制算法⭐️"></a>拥塞控制算法⭐️</h3><p>拥塞：网络中存在太多的数据包导致数据包被延迟和丢失，从而降低了传输性能。</p>
<p>拥塞控制和流量控制</p>
<p>拥塞控制的途径：简单来说需要增加资源和减小负载。在时间尺度上，要么事先避免拥塞，要么在发生拥塞过后迅速做出反应。</p>
<p>基本方法是建立一个与流量匹配的良好网络；<br>根据流量模式制定路由（改变最短路径权重等）；<br>如果无法增加容量，那么可做的就是降低负载了。例如对于有连接的服务，如果此时负载很大，应该拒绝建立虚电路的请求，这样的控制也被称为准入控制。</p>
<h4 id="流量感知路由"><a href="#流量感知路由" class="headerlink" title="流量感知路由"></a>流量感知路由</h4><p>把链路权重设置成为一个带宽，延迟，负载，排队延迟的多方面函数，在其他条件都相同的情况下，最小权重的路径更青睐那些轻负载的路径。</p>
<p>早期的流量感知路由存在一个问题，把负载考虑进链路权重过后，如果某一条链路非常拥挤而另外一条很空闲，那么下一时刻负载将会转移到这条链路，但是下一时刻有回到原先的链路，从而导致网络抖动。解决办法是不考虑负载，只考虑带宽和传输延迟，这样的问题就不会发生。</p>
<h4 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h4><p>这是一种用于虚电路网络，防止出现拥塞的技术。其基本思想很简单：除非网络可以携带额外的流量而不会变得拥塞，否则不再建立新的虚电路。准入控制可以和流量感知路由结合，在建立虚电路的过程中，避开负载高的线路。</p>
<h4 id="流量调节"><a href="#流量调节" class="headerlink" title="流量调节"></a>流量调节</h4><p>必须要解决的两个问题：</p>
<p>（1）路由器必须确定何时快要接近拥塞(链路利用率，丢包数和排队包数)，每个路由器连续监测它正在使用的资源<br><br>（2）路由器必须及时把信息反馈给造成拥塞的发送方 <br><br>对于信息的反馈,这里有下面几种方法：</p>
<ol>
<li>抑制包，路由器随机选择一个被拥塞的数据包，给数据包的源主机发送一个抑制包。同时打上标记，以防在发送的图中产生更多的抑制包。</li>
<li>显式拥塞通知，基本原理如下，路由器给每个转发的数据包打上标记，表明目前该链路正经历着拥塞，当包到达接收方时，接收方在回复应答包的时候会携带流量调节的信息，从而告诉发送方控制发送的速度。</li>
<li>逐跳后压，存在一种这样的情况，当发送方速率很快的时候，即使抑制包发送出去后，在到达发送方之前，仍然会注入大量的数据导致网络更加拥挤，所以这里可以这样：让抑制包抑制它经过的每一跳，这样的话，短时间内抑制效果将会生效，来达到快速缓解负载很大的链路段的压力。</li>
</ol>
<h4 id="负载脱落"><a href="#负载脱落" class="headerlink" title="负载脱落"></a>负载脱落</h4><p>当流量感知路由，准入控制和流量调节都没办法消除拥塞是，路由器可以使用负载脱落来消除拥塞。其思想很简单，当路由器快要被淹没时，直接丢弃掉这些数据包。<br>这里有一个问题，丢弃什么包呢？当然是丢弃掉不那么重要的包，这里的选择是这样的，发送方在发送包之前就给每一个包打上标签，表明这个包有多么重要，这样在丢包的时候可以参考这个标签，丢弃掉不那么重要的包。</p>
<p>随机早期检测算法（RED ⭐️）：为了确定何时丢包，路由器要维护一个运行队列长度的平均值，在这个值超过某个阈值时，该链路就被认为即将拥塞，因此路由器丢弃一小部分的包（随机）来避免拥塞。<br>这里使用随机丢包的好处是可以更高概率的丢掉速率很快的发送方的包，因此发送方不得不重传这些被丢掉的包，而上层协议也会建议该发送方放慢速度，来达到避免拥塞的效果。</p>
<h3 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h3><p>有些应用对于网络的需求特别大，并不满足于网络的“尽力而为“，这个时候网络需要提供良好的服务质量来达到要求。</p>
<p>最简单的方式就是<strong>过度配置</strong>：建设有足够网络容量的网络，可以满足任何的流量需求。这不是可笑的想法，因为电话系统就是一个很好的例子。</p>
<p>确保服务质量必须解决下面的四个问题：<br><br>（1）应用程序需要网络什么样的质量？<br><br>（2）如何规范进入网络的流量？ <br><br>（3）为了保障性能如何在路由器预留资源？ <br><br>（4）网络能否安全的接受更多的流量？<br></p>
<h4 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h4><p>流：从源端发送到一个接收方的所有数据包被称为一个流。对于每个流的需求可以以下面四个参数来衡量：带宽，延迟，抖动，丢失。不同的应用这四个方面的要求不同。</p>
<h4 id="流量整形"><a href="#流量整形" class="headerlink" title="流量整形"></a>流量整形</h4><h5 id="漏桶算法和令牌桶流量"><a href="#漏桶算法和令牌桶流量" class="headerlink" title="漏桶算法和令牌桶流量"></a>漏桶算法和令牌桶流量</h5><p>想象一个漏桶，无论倒入水的速率有多大，只要漏桶还有水，其速率恒定；如果没有水，速率为0；如果超出漏桶容量，额外进入桶的水都会通过桶侧分流，最终流失掉。</p>
<p>概念上，每个主机连接到网络接口中含有一个漏桶，为了向网络层发送数据包，必须往网络中注入更多的水。如果漏桶满了来了一个数据包，该数据包必须排队等待漏桶空出来时再接纳，或者直接被丢弃。</p>
<p>令牌桶：把网络接口想象成为一个漏桶，正在往里灌水，速率为R，桶容量为B。现在，为了发送一个数据包，我们必须能够从桶内掏出水或者令牌。桶内只可以累积固定数量的令牌，如果桶是空的，那么必须等到累积到一定的令牌才能发送一个数据包。</p>
<h5 id="包调度"><a href="#包调度" class="headerlink" title="包调度"></a>包调度</h5><p>定义：在同一个流之间以及在竞争流之间分配路由器资源的算法成为包调度算法。<br>不同的流可以预约潜在的资源有以下三种：带宽，缓冲区，CPU周期。<br>包调度算法负责分配带宽和其他路由器资源，具体的做法是确定下一次把缓冲区中的哪些数据发送到输出线路。最简单的方式是先进先出FIFO。<br>FIFO路由器在队列满时通常丢弃新到的数据包，由于新到的数据包会排在末尾，因此这种行为也被称作<strong>尾丢包</strong>。<br>FIFO容易实现但是无法提供较好的性能。<br>公平队列：针对每一条输出线路，路由器为每个流设置单独的队列。当路线空闲时，路由器循环扫描各个队列，然后分别取一个进行发送。这样就保证了绝对的公平，但是也有不足(宽带需求小的往往占据了更多的带宽)。</p>
<p>其他的调度算法：<br>加权的公平队列<br>优先级调度<br>时间戳先后发送</p>
<h3 id="网络互联"><a href="#网络互联" class="headerlink" title="网络互联"></a>网络互联</h3><h4 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h4><p>处理两个处于不同网络相互连接时的情况超级困难，然而却存在一种非常常见的情形，就是源主机和目的主机的网络类型是完全相同的。但是其中间却隔着一个不同的网络。解决这样问题的技术被称为隧道技术。<br>隧道技术广泛被用于那些因使用了其他网络而被隔离的的主机和网路。结果生成的网络就被称为<b>覆盖网络</b>，因为它有效的覆盖在了基础网络之上。<br>隧道的缺点就是无法到达位于隧道之下的网络的主机，因为数据包无法从隧道中逃生。</p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计网复习之介质访问控制子层复习笔记]]></title>
      <url>http://yoursite.com/2017/01/03/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E4%B9%8B%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="介质访问控制子层"><a href="#介质访问控制子层" class="headerlink" title="介质访问控制子层"></a>介质访问控制子层</h1><p>传统信道分配FDM&amp;TDM的缺点是带宽利用率不高，并且存在高延迟<br>动态信道分配</p>
<h2 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h2><p>纯ALOHA协议：当用户有数据时就传送，解决冲突的办法是，在一个站发送了一个帧过后，把该帧广播到所有其他站。不监听信道，所以冲突是很容易发生的。</p>
<p>分槽ALOHA：将时间分成离散的时间间隔，这些时间间隔就为时间槽，每个时间槽对应一帧。<br>最佳的效率为1/e</p>
<p>载波监听多路访问协议：站监听是否存在载波(即是否有传输)，并依据此进行相应的操作。</p>
<p>1-坚持载波监听多路访问：站点在发送数据前监听信道，如果信道上有其他数据正在传输，则等待，直到信道变得空闲；然后发送该帧，如果发生冲突，则等待一个随机时间，在监听信道，重复上面的操作。<br>存在的问题：<br>（1）当等待发送的帧不为1时，若信道出现空闲，所有的帧将在同一时刻发送，必将导致冲突。<br>（2）信号的传播延迟也会带来冲突。如果一个站刚开始发送并且信号并没到达一个准备发送的站点，此时这个站点也将发送从而导致冲突。</p>
<p>非坚持式CSMA：<br>和前面坚持式协议不同的是，同样该协议会监听信道，但是不会一直监听信道，也就是说，当信道忙时，其直接会等待一定的时间，在尝试监听信道，直到信道空闲，才发送该帧。<br>该算法很好的解决了冲突的问题，但也带来了更高的延迟。</p>
<p>P-坚持式CSMA:适用于分槽的信道。当一个站准备好要发送数据时，其监听信道，如果信道是空闲的，则其按照概率p发送该帧，以1-p的概率讲该帧推迟到下一个时间槽发送。如果下一个时间槽也为空，则其同样以p概率发送这一帧，以1-p的概率延迟该帧到下一个时间槽，以此往复，直到这个帧被发送出去。如果发生冲突，则等待一个随机时间再进行尝试发送。</p>
<p>带冲突检测的CSMA：<br>检测到冲突过后立即停止传输该帧，等待一段时间再尝试发送。这种方式可以有效的节省时间和带宽。<br>带冲突检测的CSMA会交替的出现传输期，竞争期和空闲期。</p>
<p>检测冲突的最小时间是将信号从一个站点播到另一个站点所需要的时间t。<br>所以一个站点认为自己“抓住”了信道，最坏的情况下需要的时间是二倍于传送到另一个站点所需要的时间2t，当然这是最坏的情况。</p>
<h2 id="无冲突的协议"><a href="#无冲突的协议" class="headerlink" title="无冲突的协议"></a>无冲突的协议</h2><p>上面带冲突检测的CSMA虽然如果一个站抓住了信道，冲突就不在发生。但是冲突还是会发生在竞争期中，特别是当延迟很大，线缆很长而帧特别短的情况下，冲突会浪费带宽，并且让一个帧的发送时间动荡不定，无法很好的适应实时流量。</p>
<p>无冲突的协议在整个帧的发送过程中都不会产生冲突。</p>
<ol>
<li>位图协议。每个竞争周期都包含N个槽，若某个站要发送一个帧，则在相应的槽中插入一位来表明自己将要发送。当经过了所有的N个槽后，所有的站点都知道哪些站希望传递数据，这个时候就可以按照数字顺序开始发送了。传输数据之前需要广播自己传输意愿的的协议被称为预留协议。高序号站点平均只需要等待0.5N个槽时间，而低序号站需要等待的平均时间是1.5N个槽的时间。对于所有站而言，需要平均等待的时间为N个槽的时间。<br>在低负载的情况下，每一帧的额外开销为N位，数据长为d，则信道的利用率为d/(d+N).</li>
<li>令牌环协议。如果一个站点有需要发送的队列，则其发送一帧，并把令牌传递给下一个站点，如果该站没有要发送的帧，则只是简单的传送一下令牌而已。这里的令牌指的是发送帧的权限。等待时间为令牌传递N-1次的时间和N-1个站点发送一个帧的时间。</li>
<li>二进制倒计数。解决站点多的问题。这里每个站点以二进制串的形式广播自己的地址，从高位序开始，所有站的地址都有相同的长度，对于同一时刻，对发送进来的位进行布尔或。并且存在一个仲裁规则：bool或为为1时，舍掉为0的站点，bool或为0时，继续比较下一位。信道利用率为<br>d/(d+log2N)，经过优化甚至可以达到100%。</li>
</ol>
<h2 id="有限竞争协议"><a href="#有限竞争协议" class="headerlink" title="有限竞争协议"></a>有限竞争协议</h2><p>竞争的协议在负载低的情况下具有非常低的延迟，非竞争协议在负载高的情况下具备很好的信道利用率，因此有限竞争协议结合了这两种协议的优势，在低负载的情况下使用有竞争的协议，在高负载的情况下使用无竞争的协议。<br>有限竞争协议是这样做的：<br>将所有的站点划分成组，只有0号组才用时间去竞争0号槽，类似的只有n号组才能去竞争n号时间槽，若出现冲突，直接往后面推到下一个时间槽。<br>当负载很低时，每个时间槽的站点数就可以多一些，若负载很高的时候，每个时间槽的站点就需要低一点，甚至为了避免冲突只使用一个站一个组。</p>
<h2 id="无线局域网协议"><a href="#无线局域网协议" class="headerlink" title="无线局域网协议"></a>无线局域网协议</h2><p>冲突发生在接收端而不是发送端，两种问题：隐藏终端问题和暴露终端问题(好好理解）。<br>这里有一个协议：冲突避免多路访问（MACA），其原理是这样的：如果一个站点想要给另一个站点发送帧，那么其先发送一个RTS帧，然后接收方再发送一个CTS帧作为应答，然后就可以发送了。如果一个其他站点听到了RTS帧，那么它一定离该站点很近，其必须保持沉默，等待足够长的时间使CTS返回给这个站点。如果一个站点收到了CTS，其必须保持沉默，知道该帧被顺利的发送(可以根据帧长来估计等待的时间)。</p>
<h2 id="二进制指数后退的CSMA-CA"><a href="#二进制指数后退的CSMA-CA" class="headerlink" title="二进制指数后退的CSMA/CA"></a>二进制指数后退的CSMA/CA</h2><p>使用1-坚持CSMA算法，在发生冲突过后立即停止传输，并等待一定的时间尝试传输。如果再发生冲突，则随机等待的时间槽的最大值按指数级增长。<br>例如如果两个站点冲突一次，则选择随机等待0或者1个时间槽，若再次冲突，等待的时间槽为0，1，2，如果冲突n次，则随机等待的时间槽的为0-2^n -1之间的一个随机数。当达到1023的最大值的时候，便不再增加。<br>该算法可以动态的确定发送站的数量，如果随机数的最大值为1023，则冲突的可能性就很小了；如发生冲突，平均的等待时间将会是数百个时间槽，从而延迟时间特别大。这种算法只能保证两种情况：（1）在冲突只有少量发生的情况下，可以确保较低的延迟；（2）当许多站点发生冲突的时候，可以在一个合理的时间间隔解决冲突。</p>
<h2 id="交换式以太网"><a href="#交换式以太网" class="headerlink" title="交换式以太网"></a>交换式以太网</h2><p>使用交换机来处理不断增长的负载。<br>交换机：把帧传输到该帧想去的端口。当交换机接收到来自某个站的帧，其检查该帧的以太网地址，确认该帧去的目的地端口。并且是全双工的，并不用担心任何的冲突，因为不会发生冲突。交换机可以同时发送多个帧(发往不同的端口），如果同时有多个帧需要经同一个端口发送出去，那么只需要交换机含有缓存。<br>交换机也能够更安全的发送，因为其不是以广播的形式发送出去的，它只会发给某一个特定的端口，经由该端口被发送出去。所以相比集线器，其更加安全。</p>
<h2 id="千兆以太网"><a href="#千兆以太网" class="headerlink" title="千兆以太网"></a>千兆以太网</h2><p>设计目标：提升10倍的性能，并保持与现有以太网标准的兼容。<br>提供单播和广播的无确认数据报服务，采用48位的地址，保持相同的帧格式，包括最大最小帧的要求等。<br>为了达到距离经典以太网100倍的速度提升，在其他不变的情况下，最大的线缆长度下降了100倍，即为25米。考虑到25米在实际运用中的限制，这里使用了两种方法吧线缆长度深升到了200米。</p>
<p>（1）载波扩充：让硬件在帧的后面加上一定的长度，将帧的长度扩展到512字节，再又硬件去除填充。这里存在一个问题，利用率不高(填充大多数是无用的)</p>
<p>(2)帧突发：将多个帧连在一起，如果不满512字节再进行填充。这种方案是比较有效的(但前提是存在那么多帧)</p>
<p>没有写入标准的还有巨形帧，可以达到9KB，但与较老的标准并不兼容。</p>
<h2 id="以太网传输中的冲突和帧大小的关系"><a href="#以太网传输中的冲突和帧大小的关系" class="headerlink" title="以太网传输中的冲突和帧大小的关系"></a>以太网传输中的冲突和帧大小的关系</h2><p>以太网的最大传输长度为2.5km，信号在介质上传输的速度为2*10^8m/s<br>那么延迟为2500/v = 12.5us<br>最坏的情况下是若发送一个很小的帧，则检测冲突需要的时间为2t，25us。<br>在长的线缆上进行传输，需要经过4个中继器。因此传输的延迟最坏为50us，这里取到51.2us，在一个10Mbps的经典以太网上，其帧最小长度为512位=64B。这里的51.2us指的是传输间隙。<br>最小长度的定义：为了使发送方能够在一个帧的传输时间内检测到此帧是否在链路上发生冲突。<br>若帧小于了最小帧长，那么就无法检测是否发生了冲突了。</p>
<h2 id="802-11"><a href="#802-11" class="headerlink" title="802.11"></a>802.11</h2><p>增加可靠性：（1）降低传输速率（2）减小帧的长度(拆分帧)<br>节省电源,<br>服务质量,对等流量传输</p>
<h2 id="802-11帧结构"><a href="#802-11帧结构" class="headerlink" title="802.11帧结构"></a>802.11帧结构</h2><p>数据帧的格式：<br>帧控制字段(2字节，含有11个子字段)<br>持续时间(2字节)：告诉本帧和其确认帧会占据信道的时间，其他站点根据该值管理各自的NAV机制。<br>地址字段(3个，各6字节)：第一个接收方地址，第二个发送方地址，第三个指明远程端点。<br>序号字段(2字节)：帧的编号，用于重复字段的检测<br>数据字段：0-2312字节<br>校验字段：4字节</p>
<p>和管理帧(数据字段不相同)以及控制帧略有不同</p>
<h2 id="802-11服务"><a href="#802-11服务" class="headerlink" title="802.11服务"></a>802.11服务</h2><ol>
<li>关联：把移动站点连接到AP上(我们常说的连接Wi-Fi)</li>
<li>重新关联：允许移动站点改变它的首选AP(切换Wi-Fi)</li>
<li>认证（WPA WPA2）</li>
<li>QoS流量调度：给予视频和语音更高的优待</li>
<li>发射功率限制</li>
<li>动态频率选择</li>
</ol>
<h2 id="802-16"><a href="#802-16" class="headerlink" title="802.16"></a>802.16</h2><p>基站使用了更大的功率和更好的天线，传输距离至少是802.11答十倍以上，并提供了更多的差错处理。</p>
<h2 id="数据链路层交换"><a href="#数据链路层交换" class="headerlink" title="数据链路层交换"></a>数据链路层交换</h2><p>网桥：连接多个局域网组成更大的局域网，实际上网桥就是以太网交换机。网桥工作在数据链路层，通过检查数据链路层的地址来转发帧。<br>路由器：检查数据包的地址，并且基于这些地址路由包，它只能按照预先设计好的协议工作。</p>
<p>网桥的作用：（1）连接多个LAN，可构建更大的容量（2）增加了传输的可靠性(可以决定转发什么不转发什么)（3）完全透明，安装和使用简便。</p>
<p>网桥是如何工作的呢？<br>它接收隶属于每个端口的站发送的帧，网桥必须选择丢掉或者转发一个帧，作出决定的是依据帧的目标地址。</p>
<p>简单的方法是为每个网桥配备一个大的哈希表。该表列出每个可能的目标地址以及隶属的输出端口。</p>
<p>当网桥初次被使用到网络中的时候，其哈希表是空的。因此为了构建这样一个哈希表，网桥将使用泛洪算法，其对于每个未知目标地址的入境帧，网桥将会把其输出到所有的出境端口，网桥将会学习每个目标地址在哪买。一旦知道了一个目标地址，下一次发送直接就被放到正确的端口上发送。</p>
<p>网桥所用的算法是后向学习法。<br>当打开，关闭或移动网桥或机器的时候，网络的拓扑结构就会发生变化。为了记录这种动态的拓扑结构，一旦构造出一个哈希表项时，帧的到达时间也被记录在表项中。并且网桥会有一个进程扫描哈希表，清除那些时间值有几分钟的项(表示几分钟未使用)。这样的算法也意味着，如果一台计算机静止了几分钟，那么其再进行通信，帧仍然会被泛洪。</p>
<p>下面是一个详细的流程：</p>
<ol>
<li>如果去往目标地址的端口和源端口相同，则丢弃该帧(不需要经过该网桥)。</li>
<li>如果去往目标地址端口与源端口不同，则以目标端口发送该帧。</li>
<li>如果目标端口未知，则使用泛洪算法。</li>
</ol>
<h2 id="生成树网桥"><a href="#生成树网桥" class="headerlink" title="生成树网桥"></a>生成树网桥</h2><p>解决冗余链路导致的无限循环。构建一颗生成树来解决这样的问题。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>中继器:物理层，用于处理自己所连线缆上的信号，一般用于增强信号。<br>集线器：集线器，将多个线路连接在一起，从任何线路发来的信号都将发送到其他所有线路上。如果两帧同时到达，那么将会发生冲突。<br>网关<br>网桥，交换机：数据链路层，多端口，用于连接过个局域网在一起。<br>路由器：网络层，当一个数据包进入路由器，帧头和帧尾被去掉，帧的有效载荷字段送到路由软件。路由软件根据帧的头信息来选择输出线路。这个地址指的是IP地址，而不是48位的IEEE802地址。</p>
<p>网关：传输网关，将使用了两台不同传输协议的的计算机连接起来。<br>网关，应用网关，理解数据的格式和内容，并且根据需要将数据包重新进行格式化。</p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的2016]]></title>
      <url>http://yoursite.com/2016/12/31/%E6%88%91%E7%9A%842016/</url>
      <content type="html"><![CDATA[<p><img src="https://d13yacurqjgara.cloudfront.net/users/952958/screenshots/3186188/2017.png" alt="2017"><br>图片来自<a href="https://dribbble.com/shots/3186188-Happy-New-Year" target="_blank" rel="noopener">https://dribbble.com/shots/3186188-Happy-New-Year</a></p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>最近发现有好多童鞋都在回顾自己的2016，好吧，我也顺应一次潮流，来写写我的2016年。</p>
</blockquote>
<p>2016年的最后一天，也就是今天。我是这样过的：<br>睡到10点起，<br>  看了一场NBA，<br>    中午开始写一个实验到下午饭点，没写出来，<br>      晚上6点到9点，图书馆自习，复习了<strong>计网</strong>第一章,<br>        回来看直播，同时玩炉石到11点，<br>          跑去其它宿舍唠嗑，11点半，<br>            开始写软文，现在<br>              …<br>在一天的最后十几分钟里，回想一下，上面描述的总总已经成了我2016最后一个月的常态，并且持续时间超过了21天，已经从入门到精通…<br>更可恨的是，最后一个月诸事不顺！不但挂了科，还…嗯..好像就挂了科，还开到了橙卡，成功脱非。<br>我严肃的说，这真是我真实的写照…哈哈！😂</p>
<blockquote>
<p>写了一通废话，还是进入正题吧。先总结一下，2016过的不能再平凡了，成绩还是老样子不上不下，编程技术有所进展，选定目标专注前端，大部分的时间过的还算充实。好了，写完了，这就是我的2016，我希望我的2017能够找一份实习工作，顺利补完所有没修的课，然后2018顺利毕业。对，听着就很实在对不对。<br>。</p>
</blockquote>
<p>可是<br>…<br>…<br>…<br>…<br>…<br>…<br>…<br>…</p>
<hr>

<p>如果有一个比惨大会的话，我一定会拿冠军的😢</p>
<h2 id="负气"><a href="#负气" class="headerlink" title="负气"></a>负气</h2><blockquote>
<p>我负气不是说我过得不好，而是有那么些不甘心</p>
</blockquote>
<p>任何人心有不甘，那么他一定是自卑了。而我的自卑完完全全是看到旁边有那么多优秀的人，无论是在西电还是在山大。没人会承认比别人差，我也是这样，所以我觉得自卑也好，负气也罢，一定程度上让我能够平静下来，去追寻自己想要的东西。2017，仍然是我负气的一年。</p>
<h2 id="离开"><a href="#离开" class="headerlink" title="离开"></a>离开</h2><blockquote>
<p>我特别不想回望过去，因为一定有离别</p>
</blockquote>
<p>2016年7月，我离开了呆了十个月的西安和呆了一学年的西电，在我的印象里，我对西安和西电抱怨了不下十次，最开始我甚至不想待在这里，到最后我离开也是头也不回。可是，我是真的喜欢那里，我临走之前，有过这样的想法，我一定要考研来这里，然而时过境迁，我已没了要去考研的念头；我喜欢在那里生活，喜欢它给我提供的前所未有的学习生活体验，虽然我说过我不认识这个学校99%的人，但是我认识的那1%都是那么可爱，他们会过来和你聊过去，会叫你参加集体活动，会鼓励你登上舞台，虽然有意见不合，可也会和你合作…<br>还记得最后匆匆忙忙离开的那天，在等车的时候，我偷偷拍了两张在北门的照片，藏起来，后来回到家翻出来看泪水花了一脸，我真是舍不得离开。<br>在这里我结识了我最好的朋友杨&amp;张,加入了小团体，真正的编程入门，甚至篮球水平都有不错的长进。<br>我喜欢深夜11点的时候回宿舍，因为那一段路太长了，长得你可以一个人昂着头哼着歌，思考着人生，嗯！那是最美妙的20分钟。</p>
<h2 id="再出发"><a href="#再出发" class="headerlink" title="再出发"></a>再出发</h2><blockquote>
<p>我对未来充满了期待，所以我提前来了</p>
</blockquote>
<p>2016下半年是我过得最充实的半年，内心从来没有这么平静过，我把精力更多的放在了学习技术上面，我带上耳机，感觉与世隔绝，我追随心所向，开始慢慢摸索。我的2017，注定也会在摸索中慢慢度过，我喜欢这样的生活。</p>
]]></content>
      
        
        <tags>
            
            <tag> 晨记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React全家桶网络学习资源汇总]]></title>
      <url>http://yoursite.com/2016/12/12/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉，学习React时间已经超过三个月了。虽然这几个月断断续续，也算把我所了解的React全家桶学习了一遍，虽然我现在还是什么都不会😂<br>好了，接下来，我会把我学习过程中用到的一些网络资源都整理在这篇文章里面，分享给大家。</p>
<h2 id="学习react之前"><a href="#学习react之前" class="headerlink" title="学习react之前"></a>学习react之前</h2><p>学习react之前，你最好有js(ES6)的基础，下面是JS学习资料搜集汇总。<br>两本来自于阮一峰大神的开源书籍：<br>JavaScript标准参考教程<a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">这里</a><br>ES6入门指南<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">强烈推荐，看过实体书，ES6入门很实用</a><br>来自廖雪峰的官方网站的JS教程<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">特别适合快速入门和新手回顾</a></p>
<p>JavaScript Promise迷你书<a href="http://liubin.org/promises-book/#introduction" target="_blank" rel="noopener">全面了解Promise的书籍</a><br>深入理解JavaScript系列<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">汤姆大叔翻译，比较全面，值得推荐</a></p>
<h2 id="react学习"><a href="#react学习" class="headerlink" title="react学习"></a>react学习</h2><p>需要明确的一点的是，学习react最好的方式是阅读官方文档，这里列出一些资源，可作为学习的参考和补充：<br>react入门实例教程<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">没错，还是来自于阮一峰大神</a><br>Learn React &amp; Webpack by building the Hacker News front page<a href="https://github.com/theJian/build-a-hn-front-page" target="_blank" rel="noopener">强烈推荐，手把手教你构建一个前端页面</a><br>react-组件生命周期详解<a href="http://blog.csdn.net/slandove/article/details/50748473" target="_blank" rel="noopener">当我很混淆的时候，就是看这篇博文弄懂的</a><br>React入门：关于JSX语法<a href="http://www.css88.com/archives/5632" target="_blank" rel="noopener">虽然JSX很好理解，但是还是推荐一篇吧，比较详细了</a><br>React入门<a href="http://zexeo.com/home" target="_blank" rel="noopener">来自则修网的视频教程，一共有两门教程，这一门非常适合入门</a><br>react文档<a href="https://hulufei.gitbooks.io/react-tutorial/content/introduction.html" target="_blank" rel="noopener">中文翻译版本，推荐结合英文文档使用</a></p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack作为一个打包工具，如今已经十分出色。<br>一小时包教会 —— webpack 入门指南<a href="一小时包教会 —— webpack 入门指南">不敢保证一小时能不能教会，但是写得还是很详细，值得一看</a><br>webpack中文文档(类似于官方文档，比较详细的介绍了webpack的方方面面)(<a href="http://webpackdoc.com/" target="_blank" rel="noopener">http://webpackdoc.com/</a>)</p>
<h2 id="flux-amp-redux"><a href="#flux-amp-redux" class="headerlink" title="flux &amp; redux"></a>flux &amp; redux</h2><p>Flux 架构入门教程<a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" target="_blank" rel="noopener">阮一峰大神目前专注于react啊，什么都有他</a><br>Redux 入门教程<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">还是阮一峰的</a><br>Redux Tutorial 中文翻译<a href="https://github.com/xiaomoer/redux-tutorial-cn" target="_blank" rel="noopener">适合没有耐性看完官方文档的同学</a><br>Redux中文文档<a href="http://www.redux.org.cn/" target="_blank" rel="noopener">英文翻译版，适合英语基础较薄弱的同学观看,貌似还可以下载下来</a><br>redux其他学习资源<a href="https://github.com/xiaomoer/awesome-redux" target="_blank" rel="noopener">我fork的</a></p>
<h2 id="mocha-amp-chai"><a href="#mocha-amp-chai" class="headerlink" title="mocha &amp; chai"></a>mocha &amp; chai</h2><p>测试框架Mocha 实例教程<a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">不用我说来自哪里了吧</a><br>官方文档<a href="http://mochajs.org/" target="_blank" rel="noopener">最好的学习教程</a><br>chai<a href="http://chaijs.com/api/" target="_blank" rel="noopener">强大的断言库，学习途径目前只有中文文档</a></p>
<h2 id="react单元测试-amp-enzyme"><a href="#react单元测试-amp-enzyme" class="headerlink" title="react单元测试 &amp; enzyme"></a>react单元测试 &amp; enzyme</h2><p>React 测试入门教程<a href="http://www.ruanyifeng.com/blog/2016/02/react-testing-tutorial.html" target="_blank" rel="noopener">点这里</a><br>enzyme <a href="https://www.gitbook.com/book/imbubble/enzyme-docs/details" target="_blank" rel="noopener">是用于react单元测试的一个库，类jquery的风格，比官方那一套写起来顺手多了，推荐.</a></p>
<h2 id="react-router-amp-其他"><a href="#react-router-amp-其他" class="headerlink" title="react-router &amp; 其他"></a>react-router &amp; 其他</h2><p>React Router 是完整的 React 路由解决方案<br>React-Router中文文档<a href="http://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">看这个就够了</a></p>
<p>immutable.js是一个数据不可变的一个库，据说结合React可以让性能提升十倍,学习的时候有了解过.<br><a href="https://www.w3ctech.com/topic/1595" target="_blank" rel="noopener">Immutable 详解及 React 中实践</a><br><a href="http://facebook.github.io/immutable-js/docs/" target="_blank" rel="noopener">官方文档</a></p>
<p>lodash 其实不属于react全家桶成员(虽然我觉得inmutable也不是),但是作为一个高性能和模块化的JS工具库，值得大家去了解和使用<br><a href="http://lodashjs.com/docs/" target="_blank" rel="noopener">中文文档,未翻译完全版本</a></p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>上面的资料和文档也许可以很容易就能通过baidu或者其他什么的得到，我算是列举了我学习时候参考的资料吧，不一定适合大家，也许有更适合入门的资料只是我没找到而已。上面列举的也并不是react全家桶的所有技术，包括css-module，覆盖率测试这些我也是刚刚才了解，并没有深入的使用，所以我这里就不列出了。在我看来，react发展到现在，已经不能说其只是一个前端框架的view层了，它是一个技术栈，一种解决方案，并且只有使用其全家桶才能发挥出其威力，作为一个前端初学者而言，这个过程并不会太痛苦，因为我们并没有对传统的web开发思维根深蒂固，所以如果你想学习react，不妨放下心中的顾虑，现在就开始。</p>
<p>学习react不难，但是真的想写好react太难了，angular也是，vue也是，所以不要轻易说你学会了它们。我们仅仅是轮子的使用者而已，可我真想哪天我也能成为造轮子的人，加油！</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用webpack+npm进行React开发]]></title>
      <url>http://yoursite.com/2016/11/19/%E4%BD%BF%E7%94%A8webpack-npm%E8%BF%9B%E8%A1%8CReact%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这一期的知识我早就想写了，因为在学习React之初，心里面就有很多疑问，当然其中一个就是：我能不能不把所有的Component写在一个文件中，当然后面没有关注这样的问题，直到前些日子学习Flux才重视起来，恰逢周六，在这里写一篇，关于如何使用webpack+npm进行React开发。</p>
<h2 id="webpack–脚手架工具而已"><a href="#webpack–脚手架工具而已" class="headerlink" title="webpack–脚手架工具而已"></a>webpack–脚手架工具而已</h2><p>在这里我并不打算详细介绍webpack如何使用，webpack只是一个前端脚手架工具而已，在进行React开发的时候，我们只是使用babel转换ES6的代码而已，但是webpack也是一个好用而简单的打包工具，想了解更多关于webpack的知识，点击<a href="http://webpackdoc.com/index.html" target="_blank" rel="noopener">这里</a>。<br>好吧，正式开始吧！<br>首先我们需要安装node 和 npm, 因为webpack也是依赖node的，安装好node和npm后我们就可以开始安装webpack了，首先安装webpack：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br></pre></td></tr></table></figure></p>
<p>当然这里你也可以不全局安装，使用<code>npm init</code>初始化一个package.json文件，使用<code>npm install --save webpack</code>安装。</p>
<p>这里我将会跳过使用命令进行打包，直接进到使用配置管理文件就好了，如果想更深层次的了解webpack，点击上面的介绍咯(真的很详细)。</p>
<p>首先介绍一下这个配置文件，默认命名为webpack.config.js，其是一个node的文件，就像如下的这个样子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">	<span class="built_in">module</span>.exports = &#123;</span><br><span class="line">		entry: <span class="string">'./base.jsx'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'./output.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    	loaders:[</span><br><span class="line">    		&#123;</span><br><span class="line">            test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">            loader: <span class="string">'babel'</span>,</span><br><span class="line">            query: &#123;</span><br><span class="line">                presets: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好吧，介绍一下上面的这个文件到底描述了些什么，首先我们输出了一个配置对象，<code>entry</code>定义了要引入的文件，当然如果需要引入多个文件的话可以使用一个数组。<code>output</code>顾名思义定义要输出的文件名，这里可以把它理解为打包好存放的文件。<br>最后，下面的这个<code>module</code>属性用于定义加载器，比如我们需要使用babel来吧jsx转为普通的js代码，test属性表示给所有匹配的jsx执行解析，<br>exclude表示将会不解析node模块和通过bower安装的模块。loader表示使用解析工具，query则表示的扩展参数，这里表示应用es6和react的解析规则。<br>好了，对示例文件的简单介绍就告一段路，当然还有一个属性plugins，用于使用插件，有关插件的使用请移至官方文档。</p>
<h2 id="搭建react的开发环境"><a href="#搭建react的开发环境" class="headerlink" title="搭建react的开发环境"></a>搭建react的开发环境</h2><p>细心的童鞋可以发现了，上面我演示的配置文件就是一个用于开发react的基本配置文件。好吧，直接开始，首先安装react，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react</span><br><span class="line">npm install --save react-dom</span><br></pre></td></tr></table></figure></p>
<p>接着安装babel用于解析jsx和es6，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-loader</span><br></pre></td></tr></table></figure></p>
<p>最后安装一些解析规则<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-transform-es2015-arrow-functions --save-dev</span><br><span class="line">npm install babel-preset-es2015 --save-dev</span><br><span class="line">npm install babel-preset-react</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们就安装完了开发react所需要的模块了，好吧，直接进入最后一步，在这里我将写一个和小很小的例子</p>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputComp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">		<span class="keyword">super</span>(props);</span><br><span class="line">		<span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">this</span>.state = &#123;</span><br><span class="line">			value: <span class="string">''</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handleChange(e)&#123;</span><br><span class="line">		<span class="keyword">var</span> newvalue = e.target.value.trim();</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: newvalue&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;input ref=<span class="string">"name"</span> type=<span class="string">"text"</span> defaultValue=&#123;<span class="keyword">this</span>.props.tag&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</span><br><span class="line">				&lt;p&gt;&#123;<span class="keyword">this</span>.state.value&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">InputComp.propTypes = &#123;</span><br><span class="line">	tag: React.PropTypes.string.isRequired</span><br><span class="line">&#125;</span><br><span class="line">InputComp.defaultProps = &#123;</span><br><span class="line">	tag: <span class="string">'输入点什么东西吧！'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tag = <span class="string">'请输入'</span>;</span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">InputComp</span> /&gt;</span>,document.getElementById('app'));</span></span><br></pre></td></tr></table></figure>
<p>上面的小例子来源于react首页上面的一个例子，这里使用react的写法，对es6不是很了解的童鞋可以点<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">这里</a>,关于适用ES5开发react和使用es6开发有什么区别，可以看我的上一篇博客，这里就不做过多的介绍，<br>接下来，使用webpack进行打包就好了，使用上面举例的config文件，运行命令<code>webpack</code>就可以了，然后将输出文件引入到html文件中就可以看到效果了，当然如果你不想每一次修改都运行一遍命令的话那就使用监听更新模式，运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --progress --watch</span><br></pre></td></tr></table></figure></p>
<p>当你修改完文件后，其会监听到文件的改变而做出增量的修改打包（当然第一次还是得手动打包）</p>
<h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>写到这里，这篇文章就算完了，当你一步步完成上面的步骤，你就搭建了一个十分简陋的React开发环境，这里所说的的是简陋，我并没有加载对css文件的打包，这里大家可以根据自己的需求添加不同的loader来完成。作为一个React的初学者，感觉React这一个体系是十分庞大的，庞大到学习React一个多月仍然觉得力不从心，作为一个大三孩纸，每天被上不完的专业课实验课所压着，抽出来学习的时间并不多，再有自身比较懒惰所以…<br>好吧，不多说了，好好努力吧，毕竟路都是自己选的。</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用ES6语法写React]]></title>
      <url>http://yoursite.com/2016/11/15/%E4%BD%BF%E7%94%A8ES6%E8%AF%AD%E6%B3%95%E5%86%99React/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>最近在学习Redux，不可避免使用npm + webpack的方式来写React Component，由于不是很熟悉ES6踩了很多坑，在这里作为笔记写下来，供以后回顾。 </p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>惯例，先写一个例子吧<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">	<span class="keyword">import</span> &#123; PropTypes &#125; <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">InputComp</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">		<span class="keyword">super</span>(props);</span><br><span class="line">		<span class="keyword">this</span>.state = &#123;</span><br><span class="line">			name: <span class="string">''</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> newvalue = e.target.value.trim();</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;[e.target.name]: newvalue&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state; </span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;input name=<span class="string">"name"</span> type=<span class="string">"text"</span> value=&#123;value&#125; defaultValue=&#123;<span class="keyword">this</span>.props.tag&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</span><br><span class="line">				&lt;p&gt;&#123;value&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">InputComp.propTypes = &#123;</span><br><span class="line">	tag: PropTypes.string.isRequired</span><br><span class="line">&#125;</span><br><span class="line">InputComp.defaultProps = &#123;</span><br><span class="line">	tag: <span class="string">'输入点什么东西吧！'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是使用ES6语法写的一个简单的Component，有过ES6基础的同学对<code>class</code>, ‘extends’关键字等不会陌生，简单来说，这算是js的语法糖了吧。<br>组件是一个自定义的js对象，在es5中使用React.createClass();在es6中必须继承React.component。</p>
<p>上面的小例子没什么特别的，我们只需要注意两点就好了：<br>对于props,我们不能使用getDefaultProps()来添加默认的props，在ES6中有一个属性defalutProps,同理属性校验器propTypes,我们也必须写在外面，内容都和以前一样。也可以把这两个属性都写在’类’里面，使用static关键字申明.<br>对于state,我们不能使用getInitialState()来设置state的初始值，转而在构造器中使用state属性设置值即可。<br>对于事件而言，this指向的是当前创建的Component对象，所以需要手动绑定。<br>还有一些其他的差别，比如es6支持解构等<br>好吧，简单的就写在这里了</p>
<blockquote>
<p>好忙好忙，语言都没办法组织了!<br>加油！</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS定时器知多少]]></title>
      <url>http://yoursite.com/2016/11/06/JS%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9F%A5%E5%A4%9A%E5%B0%91/</url>
      <content type="html"><![CDATA[<p>在JavaScript中，定时器是一个经常被误用且不被大家所熟识的特性。但在构建应用时其却非常有用。<br>定时器提供了一种让一段代码在一定的时间之后运行的能力。由于JS的单线程特性，其同一时间只能执行一处代码，而定时器跳出了这一性质，以其特有的方式来执行代码。</p>
<p>在浏览器环境当中，window对象下有两组方法，setTimeOut()/clearTimeOut()以及setInterval()/clearInterval()分别用于设置定时器让其在一段时间后执行/让其停止和每隔一段时间就会执行一次/清除该定时器。<br>比如下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// do somethign</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// do this code every 1s</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码分别创建了一个一次执行定时器和循环执行的定时器，每隔一秒钟，function就会被执行一遍</p>
<p>咋一看，setInterval就像周期性执行setTimeout一样，但是他们有很多不同之处。<br>举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeOut(<span class="function"><span class="keyword">function</span> <span class="title">repect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	setTimeOut(repect, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// do some thing</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面两段代码的功能几乎是一样的，但是实际上却不是。setTimeOut()代码中执行前一个回调结束后100毫秒甚至更多，才会执行下一个回调<br>而setInterval()不一样，每隔100毫秒就会尝试执行，不会受到前面回调的影响。那为什么执行一个setTimeOut()执行回调的时间会更长呢？因为js单线程的特性，当计时时间到，回调函数会被放入执行队列排队，并且执行回调是需要时间的，所以执行时间只会大于设置的时间。setInterval()也一样，但有一点，由于其不关注前一个回调执行的情况，如果一直被延迟，那么setInterval()在可用后会无延迟执行。</p>
<p>好吧，写个栗子证明一下上面的结论：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'测试setTimeOut执行的时间'</span>)</span><br><span class="line">setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.timeEnd(<span class="string">'测试setTimeOut执行的时间'</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行结果为：<br>测试setTimeOut执行的时间: 1004.673ms</p>
</blockquote>
<p>关于setInterval()的演示和清除定时器的演示这里就不做了。</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写在星期一之前]]></title>
      <url>http://yoursite.com/2016/10/23/%E5%86%99%E5%9C%A8%E5%8E%BB%E6%98%9F%E6%9C%9F%E4%B8%80%E4%B9%8B%E5%89%8D/</url>
      <content type="html"><![CDATA[<p><img src="https://d13yacurqjgara.cloudfront.net/users/175710/screenshots/2024231/dribbble-corgi.png" alt="心情记事"></p>
<p>我想给自己做一个上面这样的表情，因为一个星期又要过完了，而我又把任务拖到下一个星期，然后假装下面这样的表情，显得无辜又可怜。</p>
<p><img src="https://d13yacurqjgara.cloudfront.net/users/398490/screenshots/2722077/taco-preloader.gif" alt="图片"></p>
<p>在星期日的晚上仔细一想，还真是这样，然后本着无所谓的态度，高高兴兴上学去！</p>
<p><img src="https://d13yacurqjgara.cloudfront.net/users/285475/screenshots/2087117/dog_dribbble.gif" alt="上学去啦"></p>
<p>这就是我的常态，患了<strong>拖延症</strong>！</p>
<p>我病了，月初患的感冒还不见痊愈，精神萎靡。<br>我病了，得了一种叫拖延症的病，不容易治愈！<br>我病了，找不到方向，就快要迷失方向！</p>
<p>当我病入膏肓的时候，最悲哀的是，我还以为自己还有救！</p>
<p>然后…明天启程去苏州了，无论是旅游也好，只希望好好享受这个过程，不虚此行！</p>
<p>细细想来，我的确还有事件自救，因为上面的总总根本就没发生在我身上！</p>
<p>可是，像我这样，离发生还远吗？</p>
<p>对，还有时间，去改变！</p>
]]></content>
      
        
        <tags>
            
            <tag> 晨记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈JS闭包]]></title>
      <url>http://yoursite.com/2016/10/21/%E6%B5%85%E8%B0%88JS%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>了解JS的人都知道，在ES6之前JavaScript中只有函数作用域和全局作用域，而没有块级作用域(try…catch是一个例外)。该怎么理解这句话呢？我们先来看一个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`i=<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>当运行完一个for循环后，i=4。由于JS中不存在块级作用域，所以这里在for循环中申明的变量i是一个全局变量，因此可以在外部访问到。<br>现在我们来看下一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'limoer'</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	sayHello();</span><br><span class="line">&#125;</span><br><span class="line">init(); <span class="comment">// hello limoer</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们定义了一个函数，函数中申明了一个局部变量<code>name</code>，并且在函数内部定义了一个内部函数<code>sayHello</code>，这个函数只能在函数init内使用，然而<code>sayHello</code>并没有自己的局部变量，但是其可以访问到函数外部的变量，即其父级函数的name变量</p>
<p>通过上面的两个例子可以清楚的知道，变量的作用域完全是由它在源代码中的位置决定的，并且嵌套的函数也可以访问其外层作用域中的变量。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包和变量的作用域息息相关。现在我们来修改上面的这个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'limoer'</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sayHello</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayHelloFunc = init();</span><br><span class="line">sayHello(); <span class="comment">// hello limoer</span></span><br></pre></td></tr></table></figure>
<p>注意修改的地方，我们这次是直接返回这个内部函数，然后在外部执行这个函数。<br>但是，通常来说，当函数一旦运行完成，其局部变量就不可用了，在这里是当执行了<code>var sayHelloFunc = init();</code>后name应该不可用了。但是实际运行情况是成功访问到了<code>name</code>这个属性。</p>
<p>原因是因为这里sayHelloFunc已经成为了一个闭包。它由两部分组成，返回的函数本身以及创建该函数的环境。<br>而所谓的环境是由闭包在创建时其作用域内的变量组成的。对于上面的这个例子，这里的变量就是指的<code>name</code></p>
<p>再看一个闭包的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSome</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(num + y)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add10 = addSome(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> add1 = addSome(<span class="number">1</span>);</span><br><span class="line">add10(<span class="number">1</span>); <span class="comment">// 11</span></span><br><span class="line">add1(<span class="number">10</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure></p>
<p>对于上面的这个例子，addSome()做为一个函数工厂产生了两个闭包，它们共享了函数的定义，但是却又保存了不同的环境。</p>
<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>通过上面的描述，知道闭包其实就是将函数和其作用环境相互关联起来，达到保存变量的目的。</p>
<p>把上面的例子稍微改一下，我们可以把它用到实践中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">	&lt;button id="toBlue"&gt;切换背景为蓝色&lt;/</span>button&gt;</span><br><span class="line">	&lt;button id=<span class="string">"toYello"</span>&gt;切换背景为黄色&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">	&lt;button id="toGreen"&gt;切换背景成绿色&lt;/</span>button&gt;</span><br><span class="line">	&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">changeBgColorTo</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="built_in">document</span>.body.style.backgroundColor = type;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">var</span> toBlue = changeBgColorTo(<span class="string">'blue'</span>);</span><br><span class="line">		<span class="keyword">var</span> toYellow = changeBgColorTo(<span class="string">'yellow'</span>);</span><br><span class="line">		<span class="keyword">var</span> toGreen = changeBgColorTo(<span class="string">'green'</span>);</span><br><span class="line">		<span class="built_in">document</span>.getElementsById(<span class="string">'toBlue'</span>).addEventListener(<span class="string">'click'</span>, toBlue);</span><br><span class="line">		<span class="built_in">document</span>.getElementsById(<span class="string">'toYellow'</span>).addEventListener(<span class="string">'click'</span>, toYello);</span><br><span class="line">		<span class="built_in">document</span>.getElementsById(<span class="string">'toGreen'</span>).addEventListener(<span class="string">'click'</span>, toGreen);</span><br><span class="line">	&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的例子展示了如何使用闭包来定义公共函数，来减少代码的冗余。</p>
<h2 id="一个常见的错误，使用闭包来解决"><a href="#一个常见的错误，使用闭包来解决" class="headerlink" title="一个常见的错误，使用闭包来解决"></a>一个常见的错误，使用闭包来解决</h2><p>直接贴代码吧：<br>html:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">"help"</span>&gt;Helpful notes will appear here&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;E-mail: &lt;input type="text" id="email" name="email"&gt;&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;Name: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;p&gt;Age: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"age"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure>
<p>上面的代码是我们实际开发过程中非常常见的错误。我们使用循环来给每一个输入框绑定一个事件，从而实现当聚焦到不同的输入框是产生不同的输出。<br>但是，上面的代码显然不能完成这样的工作，因为当循环完成后，此时item已经指向了helpText的最后一项，而给onfocus绑定的是一个匿名函数，当聚焦到某一个输入框时，执行<code>showHelp(item.help)</code>而item早已是<code>helpText</code>中的最后一项了，所以造成了错误.</p>
<p>知道错误后，我们就知道改怎样修改了。我们需要保存运行时的环境，返回一个闭包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> 		<span class="keyword">var</span> helpText = [</span><br><span class="line">     		&#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">     		&#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">     		&#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">   	];</span><br><span class="line"></span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">   		<span class="keyword">var</span> item = helpText[i];</span><br><span class="line">   		<span class="built_in">document</span>.getElementById(item.id).onfocus = (<span class="function"><span class="keyword">function</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">     			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     				showHelp(help)</span><br><span class="line">     			&#125;</span><br><span class="line">   		&#125;)(item.help);</span><br><span class="line"> 		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，简单的对于闭包的介绍就到这里了！<br>想更系统的学习JS点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">这里</a></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[踩过React表单的坑后有感]]></title>
      <url>http://yoursite.com/2016/10/13/%E8%B8%A9%E8%BF%87React%E8%A1%A8%E5%8D%95%E7%9A%84%E5%9D%91%E5%90%8E%E6%9C%89%E6%84%9F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>如题所示，最近捣鼓React表单踩坑了，才捣鼓没多少时日，心就变浮躁了，开始看不下去文档，也不谷歌百度直接开码，然后就是各种报错，越报错心越急越得不到解决心情越差，好不容易静下心来搜集资料准备搞定表单，这里先记下来，以备不时只需！</p>
</blockquote>
<h2 id="踩过的坑…"><a href="#踩过的坑…" class="headerlink" title="踩过的坑…"></a>踩过的坑…</h2><p>直接开写吧：</p>
<p>input标签忘记闭合导致报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SimpleComp = React.createClass(&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"随便输入点什么吧！"</span>&gt;</span></span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">SimpleComp</span> /&gt;</span>, document.body)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行上面的这段代码，发现并页面渲染异常，打开浏览器console一看，下面的出现了错误，并且是下面这样的:</p>
</blockquote>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2v0Y33291e1E240k0k0J/Image%202016-10-13%20at%207.35.27%20%E4%B8%8B%E5%8D%88.png?v=0ba59abc" alt="报错图片"></p>
<blockquote>
<p>清清楚楚明明白白，标签并没有闭合，并且直指9行行最后渲染出了问题，然后我就一直找一直找，没错误啊，可始终还是报错<br>最后经过各种尝试才知道，input标签要强制闭合的，不然就会转换错误<br>知道真相的我眼泪掉下来，原来是这么回事啊，平时html写得飞起，细节这些什么的，都没注意哎！<br>再有，控制台上打印的异常和错误可千万别轻信，以前已经在这个被坑过了</p>
</blockquote>
<h2 id="受控与不受控"><a href="#受控与不受控" class="headerlink" title="受控与不受控"></a>受控与不受控</h2><blockquote>
<p>有过React基础的童鞋都知道，React内部通过props和state来传递属性和状态，其中属性经由组件外属性传入，作用于组件后无法改变<br>state 产生于组件内部， 通过setState()来改变状态，每一次改变状态，组件将会被重绘<br>对于表单来说，props和state用得都很频繁，所以在这里提及一下</p>
</blockquote>
<p>先来看非受控组件吧，顾名思义就是组件的状态不受控制，从代码上体现出来的就是，一个input不含有value属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> NotControlComp = React.createClass(&#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">defaultValue</span>=<span class="string">&#123;this.props.placeholder&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line">ReactDOM.render(&lt;NotControlComp placeholder='随便输入点什么吧！' /&gt;, document.body)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上面的一段代码定义了一个非受控的input，接受用户的输入而改变状态<br>注意：这里使用到的defaultValue属性作用类似于placeholder属性</p>
</blockquote>
<p>好吧，事实上我们使用非受控组件的情况比较多，我们会监听input的onChange时间，通过state来更新状态<br>下面是一个简单的获取用户输入的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ExampleComp = React.createClass(&#123;</span><br><span class="line">	getDefaultProps()&#123;</span><br><span class="line">		<span class="keyword">return</span>&#123;<span class="attr">placeholder</span>: <span class="string">'输入吧'</span>&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	getInitialState()&#123;</span><br><span class="line">		<span class="keyword">return</span>&#123;</span><br><span class="line">			val: <span class="string">''</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	handleChange(e)&#123;</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;<span class="attr">val</span>: e.target.value&#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span>(</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;input type=<span class="string">"text"</span> defaultValue=&#123;<span class="keyword">this</span>.props.val&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</span><br><span class="line">				&lt;p&gt;你输入了：&#123;<span class="keyword">this</span>.state.val&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">ExampleComp</span> <span class="attr">placeholder</span>=<span class="string">'随便输入点什么吧!'</span> /&gt;</span>, document.body)</span></span><br></pre></td></tr></table></figure></p>
<p>那么受控组件就很显而易见了，受控的input定义了一个value属性，并且value部位null<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ControlComp = React.createClass(&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"不要尝试修改这个值啦！"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">ControlComp</span> /&gt;</span>, document.getElementById('app'))</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>好了，最简单的受控组件就写好了，当你尝试去修改表单中的值的时候，发现根本无法修改<br>这点明显和我们平时写html不一样，同样的input标签在html中就可以修改但是到了react中就没办法修改了，想过原因吗？<br>官方文档中给出了答案： 不比HTML，React组件必须在任何时间点呈现视图的状态而不仅仅是在初始化的时候， 好好理解！</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><p>不要通过添加子节点的方式给<code>&lt;textarea&gt;</code>添加内容，应该使用defaultValue或者value属性,避免产生歧义，因为JSX本身就是javascript</p>
</li>
<li><p>你可以通过selected属性来选中一个下拉栏， 但是为了组件的可操作性，请使用value 或者 defaultValue来代替就像这样：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SelectComp = React.createClass(&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span>(</span><br><span class="line">			&lt;select value=<span class="string">'B'</span>&gt;</span><br><span class="line">				&lt;option value=<span class="string">'A'</span>&gt;A&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">				&lt;option value='B'&gt;A&lt;/</span>option&gt;</span><br><span class="line">				&lt;option value=<span class="string">'C'</span>&gt;A&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>select&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">SelectComp</span> /&gt;</span>, document.body)</span></span><br></pre></td></tr></table></figure>
<p> 想要非受控组件的话，就使用defaultValue属性好了<br> 当然了，可以通过传入一个数组来达到多选的目的, 前提是给select添加<code>multiple={true}</code>就可以了</p>
</li>
</ol>
<p>看到这里，也许有人心里还有疑问，受控的组件既然不能修改那到底该怎么用？<br>对于这个问题，请看下面：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ControlComp = React.createClass(&#123;</span><br><span class="line">	getInitialState()&#123;</span><br><span class="line">		<span class="keyword">return</span>&#123;<span class="attr">value</span>: <span class="number">0</span>&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	handleClick(e)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; /&gt;</span><br><span class="line">				&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> </span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		)</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;ControlComp /</span>&gt;, <span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure></p>
<p>好了，我们添加了一个button来控制受控组件的值，当然还有很多方式，比如我们可以给受控组件添加一个onChange事件监听</p>
<blockquote>
<p>好了，React表单的基本知识就说到这里，感谢那些曾经让我烦躁无比的坑！</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在React中使用mixin]]></title>
      <url>http://yoursite.com/2016/10/12/%E5%9C%A8React%E4%B8%AD%E4%BD%BF%E7%94%A8mixin/</url>
      <content type="html"><![CDATA[<h2 id="mixin到底为何方神圣？"><a href="#mixin到底为何方神圣？" class="headerlink" title="mixin到底为何方神圣？"></a>mixin到底为何方神圣？</h2><p>mixin被理解为‘混入’的意思，<br>我们知道，如果你经常使用某一段相同的代码的时候，你会把它进行抽象，封装成类或者function，<br>‘混入’也一样，它可以解决代码段重复的问题。</p>
<h2 id="jade中的Mixins"><a href="#jade中的Mixins" class="headerlink" title="jade中的Mixins"></a>jade中的Mixins</h2><blockquote>
<p>jade(pug)是一个高性能的模版引擎，它使用javascript实现，并提供给Node使用.<br>我在使用Jade模版引擎接触到了Mixin, 下面给出一个例子理解下</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mixin box(styles)</span><br><span class="line">           .conponent</span><br><span class="line">               -each style <span class="keyword">in</span> styles</span><br><span class="line">                   .squire</span><br><span class="line">                       -<span class="keyword">var</span> x = styles.indexOf(style) + <span class="number">1</span>;</span><br><span class="line">                       a(href='/users/' + x + '/list') #&#123;style&#125;</span><br><span class="line">   .container</span><br><span class="line">   	mixin([<span class="string">'lin'</span>, <span class="string">'limoer'</span>])</span><br><span class="line">   .links</span><br><span class="line">   	mixin([<span class="string">'parents'</span>, <span class="string">'classmates'</span>, <span class="string">'others'</span>])</span><br></pre></td></tr></table></figure>
<p>你可以无视jade的语法，如果你想学习jade，点<a href="https://segmentfault.com/a/1190000000357534#articleHeader0" target="_blank" rel="noopener">这里</a></p>
<blockquote>
<p>首先我使用mixin 关键字申明了一个带参数mixin结构，然后依据传入的参数生成了很多url<br>这个mixin 结构可以在这个模版文件中使用，通过不同的参数来生成url<br>从上面可以看出，mixin的确可以解决代码重复的问题</p>
</blockquote>
<h2 id="React中的Mixin"><a href="#React中的Mixin" class="headerlink" title="React中的Mixin"></a>React中的Mixin</h2><blockquote>
<p>首先来写一个例子</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TimerComp = React.createClass(&#123;</span><br><span class="line">	getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="attr">secondsElapsed</span>: <span class="number">0</span>&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	tick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stateState(&#123;<span class="attr">secondsElapsed</span>: <span class="keyword">this</span>.state.secondsElapsed + <span class="number">1</span>&#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">	componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.interval = setInterval(<span class="keyword">this</span>.tick, <span class="number">1000</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		clearInterval(<span class="keyword">this</span>.interval)</span><br><span class="line">	&#125;,</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;p&gt;Seconds Elapse &#123;<span class="keyword">this</span>.state.secondsElapsed&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>简单的说一下，这里定义了一个定时器组件，会随着时间的增加来自动计时<br>但是一个应用需要多个计时器呢？我们第一时间想到了组件的嵌套，但是组件的嵌套不但会增加组件的复杂程度<br>而且，想要修改计时器也是比较困难的<br>好了，解决代码复用的问题，我们可以使用Mixin， 让其混入进其他组件就好了</p>
</blockquote>
<blockquote>
<p>码起，还是计时器的例子！</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MixinTimerComp = React.createClass(&#123;</span><br><span class="line">	mixins: [MixinInterval(<span class="number">1000</span>)],</span><br><span class="line">	getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="attr">secondsElapsed</span>: <span class="number">0</span>&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	onTick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;<span class="attr">secondsElapsed</span>: <span class="keyword">this</span>.state.secondsElapsed + <span class="number">1</span>&#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;p&gt;Seconds Elapse &#123;<span class="keyword">this</span>.state.secondsElapsed&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我们使用了mixins属性，把自定义的MixinInterval对象混入了Timer组件</p>
</blockquote>
<p>来看看MixinInterval的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MixinInterval: <span class="function"><span class="keyword">function</span>(<span class="params">interval</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		componentDidMount() &#123;</span><br><span class="line">			<span class="keyword">this</span>.__interval = setInterval(<span class="keyword">this</span>.onTick, interval)</span><br><span class="line">		&#125;,</span><br><span class="line">		componentWillUnmount() &#123;</span><br><span class="line">			clearInterval(<span class="keyword">this</span>.__interval)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>就这样实现了一个最简单的问题，和最前面的例子做对比，我们发现，只是把组件中一些代码独立出来成为一个mixin对象<br>但这样做无疑是解决了代码重用的问题，当我们想定义另一个计时器时候，我们只需混入这个mixin代码<br>而不必关心混入的计时处理对象是怎么实现的</p>
</blockquote>
<blockquote>
<p>mixin 实现起来非常简单，React也支持多个mixin的混入(在mixins赋值为一个mixin对象数组)<br>但有一个问题需要注意，在mixin中尝试覆盖state中定义的键的话，React会抛出错误</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">React.createClass(&#123;</span><br><span class="line">	mixins: [&#123;</span><br><span class="line">		getInitialState()&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;<span class="attr">cover</span>: <span class="number">1</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;],</span><br><span class="line">	getInitialState()&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="attr">cover</span>: <span class="number">2</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 错误，尝试覆盖cover属性</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React学习之JSX]]></title>
      <url>http://yoursite.com/2016/10/11/React%E5%AD%A6%E4%B9%A0%E4%B9%8BJSX/</url>
      <content type="html"><![CDATA[<h2 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h2><blockquote>
<p>简单点说，JSX是对javascript的扩展，语法类似于XML，但JSX不是一门新的语言，<br>确切来说只是语法糖，每一个XML都会被响应的转换工具转换成纯的javascript代码。<br>在使用React时，你没有必要使用JSX来构建组件，但是推荐使用JSX，因为这样可以让组件的结构<br>和组件之间的关系看起来更清晰。</p>
</blockquote>
<p>好了，开始使用JSX吧！</p>
<blockquote>
<p>首先我们分别使用JSX和纯js来渲染一个组件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用JSX</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;使用了JSX语法糖&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;,</span><br><span class="line">    <span class="built_in">document</span>.body</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 不使用jsx</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>,</span><br><span class="line">        React.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">'不使用jsx'</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.body</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="html标签和React组件"><a href="#html标签和React组件" class="headerlink" title="html标签和React组件"></a>html标签和React组件</h2><blockquote>
<p>ReactDOM.render()可以渲染html标签，也可以渲染React组件，但是这里有一些命名上的规范</p>
</blockquote>
<p>html标签使用<em>首字母小写</em>的方式，但使用首字母大写也能够正常加载</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> renderDiv = &lt;div&gt;这是一个标签&lt;/div&gt;</span><br><span class="line">ReactDOM.render(renderDiv, <span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure>
<p>React组件使用首字母大写的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RenderComp = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>: &lt;div&gt;这是一个组件&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(&lt;RenderComp /&gt;, document.body)</span><br></pre></td></tr></table></figure>
<p>经过测试，发现如果使用首字母小写的方式，将不会正常渲染组件，也不会报错, 当然你也可以这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RenderComp = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>: &lt;div&gt;这是一个组件&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> renderComp = &lt;RenderComp /&gt;</span><br><span class="line">ReactDOM.render(renderComp, document.body)</span><br></pre></td></tr></table></figure>
<h2 id="js表达式"><a href="#js表达式" class="headerlink" title="js表达式"></a>js表达式</h2><blockquote>
<p>当我们想要在React中使用js变量或者是表达式时候,使用{}来进行包裹，不能够出现””,否则会被当作字符串。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SampleComp = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            iscls: <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 表达式</span></span><br><span class="line">            &lt;div className=&#123;<span class="keyword">this</span>.state.iscls ? <span class="string">'cls'</span> : <span class="string">'no_cls'</span>&#125;&gt;</span><br><span class="line">            <span class="comment">// 变量</span></span><br><span class="line">            &lt;h2&gt;&#123;<span class="keyword">this</span>.props.msg&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(&lt;SampleComp msg='学习搬砖中...' /&gt;, document.body)</span><br></pre></td></tr></table></figure>
<p>这里提示一下，在JSX中，标签的class和for属性分别使用className和htmlFor代替了</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><blockquote>
<p>在给标签添加style属性的时候，应该这样写:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;&#123;<span class="attr">display</span>: <span class="string">'none'</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以把要应用的样式赋值给一个变量，再使用变量</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style = &#123;</span><br><span class="line">    color: red,</span><br><span class="line">    display: none</span><br><span class="line">&#125;;</span><br><span class="line">&lt;div style=&#123;style&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HTML转义，为了防止XSS攻击，React默认是使用转义的,所以当你想使用一些富文本这里就必须注意<br>为了不让其转义，我们可以这样写：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mesg = <span class="string">'&lt;h2&gt;这里的字体大小是多少?&lt;/h2&gt;'</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;div dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: mesg&#125;&#125;&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">    document.body</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>刚开始学习React的时候对JSX是生畏的，以为会很难理解。当慢慢的接触React，踩过一些小坑，<br>发现使用JSX是那么好掌握, 它仅仅是语法糖而已，并且转换的规则也很简单</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写在正式学习React之前]]></title>
      <url>http://yoursite.com/2016/10/10/%E5%86%99%E5%9C%A8%E6%AD%A3%E5%BC%8F%E5%AD%A6%E4%B9%A0React%E4%B9%8B%E5%89%8D/</url>
      <content type="html"><![CDATA[<p>如果你还不知道大名鼎鼎的ReactJS, 先去<a href="https://facebook.github.io/react/" target="_blank" rel="noopener">这里</a>看看吧</p>
<blockquote>
<p>在使用过了诸如BootStrap, Foundation这类的前端框架后，在初识React就被其虚拟DOM和组件化的开发深深的吸引。<br>然后在接下来的几天，我慢慢的对React产生的恐惧，模式转变得太快，让我很不舒服。<br>然后又经过几天玩坏了，我才返现React简直是一股清流，开始爱上它了！</p>
</blockquote>
<p>好了，开始使用React吧！</p>
<h2 id="安装React"><a href="#安装React" class="headerlink" title="安装React"></a>安装React</h2><p>请先安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node</a>和npm</p>
<p>使用React之前，先来安装一下<a href="https://segmentfault.com/a/1190000000349555" target="_blank" rel="noopener">bower</a>吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g bower</span><br></pre></td></tr></table></figure>
<blockquote>
<p>安装bower后我们来正式的进入React的学习中来</p>
</blockquote>
<p>新建一个目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir proj</span><br></pre></td></tr></table></figure>
<p>使用以下命令来安装React</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bower install react</span><br></pre></td></tr></table></figure>
<p>安装完后我们在proj目录下会看见一个bower_components目录,目录里面有一个React目录，ok！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch index.html</span><br></pre></td></tr></table></figure>
<p>使用文本编辑器打开index.html, 开始码起！</p>
<h2 id="第一个React-helloworld"><a href="#第一个React-helloworld" class="headerlink" title="第一个React helloworld"></a>第一个React helloworld</h2><blockquote>
<p>引入react.js和react-dom.js（在head,或者body中引入都可以，但是必须在我们开写地方的上面）</p>
</blockquote>
<p>就像这样<br><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3x0G1z2L1J3S3O2k1V1l/Image%202016-10-10%20at%209.34.45%20%E4%B8%8B%E5%8D%88.png?v=a8b26e20" alt="引入图片"></p>
<blockquote>
<p>接着申明一个script标签</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这里的type是<code>text/babel</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloWorldComponent = React.createClass(&#123;</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">				&lt;h1&gt;开始学习使用工具搬砖啦！&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloWorldComponent</span> /&gt;</span>, document.body)</span></span><br></pre></td></tr></table></figure>
<p>好了，不出意外的话，我们将会在浏览器中看到<br><img src="https://d17oy1vhnax1f7.cloudfront.net/items/320E0g0c3B2s2P2z1N2l/Image%202016-10-10%20at%2010.14.14%20%E4%B8%8B%E5%8D%88.png?v=b564cf5d" alt="结果图"></p>
<blockquote>
<p>好啦，我们的第一个react组件算是开发完成了，这里讲一讲我们到底做了什么<br>首先我们使用了JSX语法，有关JSX的知识会单独的加深了解,但是最基本的规则就是，遇到{}解析成js，遇到‘&lt;’解析成html<br>然后使用了React提供的createClass来创建一个组件类，类名一定要大写，实现了其中一个必须要实现的render方法，返回一个h1标签<br>最后使用ReactDOM.render()渲染到body中去<br>搞定</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[依偎]]></title>
      <url>http://yoursite.com/2016/10/10/%E4%BE%9D%E5%81%8E/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这么晚起床，还不见阳光！    </p>
</blockquote>
<p><img src="https://d13yacurqjgara.cloudfront.net/users/288987/screenshots/2119533/savanna-final.jpg" alt="Scenery"></p>
<blockquote>
<p>以最快的速度看完了《依偎》，结局太出乎意料，细细想来却有觉得情理之中。<br>随心所欲的在图书馆借的书，越看越有味道，以至于，我竟然忘了自己还要学习搬砖…<br>太不真实的两人相遇，相识，从喝藤香茶到寻找虚无飘渺的“藤乡” </p>
</blockquote>
<blockquote>
<p>在一口气读完整本书之后，心里面有一种说不出的滋味，甜甜的，又有些萧索。我想，在最后的最后，“我”会静静地看着安芬，不再去想那虚无缥缈的藤乡，因为，有你在的地方，就是最美的“藤乡”，在那一刻，“我们”相对笑着，往日的种种都不再重要，重要的是，你我此刻，紧紧依偎。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 晨记 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>http://yoursite.com/googlee22a7e1de18f983c.html</url>
      <content type="html"><![CDATA[google-site-verification: googlee22a7e1de18f983c.html]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/about/index.html</url>
      <content type="html"><![CDATA[<p>Nickname: Limoer</p>
<p>Profession: software engineering</p>
<p>Profile: I’m a student from SDU. I’m focusing on browser side developing. I like the amazing and ridiculous language - JavaScript!</p>
]]></content>
    </entry>
    
  
</search>
